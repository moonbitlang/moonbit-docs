# MoonBit

MoonBit æ˜¯ä¸€ä¸ªç”¨äºäº‘è®¡ç®—å’Œè¾¹ç¼˜è®¡ç®—çš„ WebAssembly ç«¯åˆ°ç«¯çš„ç¼–ç¨‹è¯­è¨€å·¥å…·é“¾ã€‚
æ‚¨å¯ä»¥è®¿é—® https://try.moonbitlang.cn è·å¾— IDE ç¯å¢ƒï¼Œæ— éœ€å®‰è£…ä»»ä½•è½¯ä»¶ï¼Œä¹Ÿä¸ä¾èµ–ä»»ä½•æœåŠ¡å™¨ã€‚

## çŠ¶æ€

MoonBit ç›®å‰å¤„äº Pre-alpha é˜¶æ®µï¼Œæ˜¯å®éªŒæ€§è´¨çš„ã€‚æˆ‘ä»¬æœŸæœ›ä»Šå¹´èƒ½è¾¾åˆ° beta é˜¶æ®µã€‚

## ä¸»è¦ä¼˜åŠ¿

- ç”Ÿæˆæ¯”ç°æœ‰è§£å†³æ–¹æ¡ˆæ˜æ˜¾æ›´å°çš„ WASM æ–‡ä»¶ã€‚
- æ›´é«˜çš„è¿è¡Œæ—¶æ€§èƒ½ã€‚
- å…ˆè¿›çš„ç¼–è¯‘æ—¶æ€§èƒ½ã€‚
- ç®€å•ä¸”å®ç”¨çš„æ•°æ®å¯¼å‘è¯­è¨€è®¾è®¡ã€‚

## æ¦‚è¿°

ä¸€ä¸ªæœˆå…”ç¨‹åºç”±ç±»å‹å®šä¹‰ï¼Œå‡½æ•°å®šä¹‰å’Œå˜é‡ç»‘å®šç»„æˆã€‚
æ¯ä¸ªåŒ…çš„å…¥å£ç‚¹æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ `init` å‡½æ•°ï¼Œå®ƒæœ‰ä»¥ä¸‹ä¸¤ä¸ªç‰¹ç‚¹ï¼š

1. åŒä¸€ä¸ªåŒ…ä¸­å¯ä»¥æœ‰å¤šä¸ª `init` å‡½æ•°ã€‚
2. `init` å‡½æ•°ä¸èƒ½è¢«æ˜¾å¼è°ƒç”¨æˆ–è¢«å…¶ä»–å‡½æ•°å¼•ç”¨ã€‚ç›¸åï¼Œåœ¨ä¸€ä¸ªåŒ…åˆå§‹åŒ–æ—¶ï¼Œæ‰€æœ‰çš„ `init` å‡½æ•°éƒ½å°†è¢«éšå¼åœ°è°ƒç”¨ã€‚å› æ­¤ï¼Œ`init` å‡½æ•°ä¸­åªèƒ½åŒ…å«è¯­å¥ã€‚

```moonbit live
fn init {
  print("Hello world!") // OK
}

fn init {
  let x = 1
  // x     // å¤±è´¥
  print(x) // æˆåŠŸ
}
```

MoonBit åŒºåˆ†è¯­å¥å’Œè¡¨è¾¾å¼ã€‚åœ¨ä¸€ä¸ªå‡½æ•°ä½“ä¸­ï¼Œåªæœ‰æœ€åä¸€å¥æ‰èƒ½å†™æˆä½œä¸ºè¿”å›å€¼çš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn foo() -> Int {
  let x = 1
  x + 1 // OK
}

fn bar() -> Int {
  let x = 1
  x + 1 // å¤±è´¥
  x + 2
}

fn init {
  print(foo())
  print(bar())
}
```

### è¡¨è¾¾å¼å’Œè¯­å¥

è¡¨è¾¾å¼åŒ…æ‹¬ï¼š

- å€¼å­—é¢é‡ï¼ˆä¾‹å¦‚å¸ƒå°”å€¼ã€æ•°å­—ã€å­—ç¬¦ã€å­—ç¬¦ä¸²ã€æ•°ç»„ã€å…ƒç»„ã€ç»“æ„ä½“ï¼‰
- ç®—æœ¯ã€é€»è¾‘å’Œæ¯”è¾ƒè¿ç®—
- è®¿é—®æ•°ç»„å…ƒç´ ï¼ˆä¾‹å¦‚ `a[0]`ï¼‰ã€ç»“æ„ä½“å­—æ®µï¼ˆä¾‹å¦‚ `r.x`ï¼‰æˆ–å…ƒç»„çš„å…ƒç´ ï¼ˆä¾‹å¦‚ `t.0`ï¼‰
- å˜é‡å’Œï¼ˆå¤§å†™å­—æ¯å¼€å¤´çš„ï¼‰æšä¸¾æ„é€ å™¨
- åŒ¿åå±€éƒ¨å‡½æ•°å®šä¹‰
- `match` å’Œ `if` è¡¨è¾¾å¼

è¯­å¥åŒ…æ‹¬ï¼š

- å‘½åå±€éƒ¨å‡½æ•°å®šä¹‰
- å±€éƒ¨å˜é‡ç»‘å®š
- èµ‹å€¼
- `return` è¯­å¥
- è¿”å›ç±»å‹ä¸º `unit` çš„ä»»ä½•è¡¨è¾¾å¼

## å‡½æ•°

å‡½æ•°æ¥å—å‚æ•°å¹¶äº§ç”Ÿç»“æœã€‚
åœ¨ MoonBit ä¸­ï¼Œå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€å‡½æ•°å¯ä»¥ä½œä¸ºå…¶ä»–å‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚

### é¡¶å±‚å‡½æ•°

å‡½æ•°å¯ä»¥è¢«å®šä¹‰ä¸ºé¡¶å±‚æˆ–å±€éƒ¨ã€‚
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `fn` å…³é”®å­—å®šä¹‰ä¸€ä¸ªé¡¶å±‚å‡½æ•°ï¼Œ
ä¾‹å¦‚ä»¥ä¸‹å‡½æ•°æ±‚ä¸‰ä¸ªæ•´æ•°ä¹‹å’Œå¹¶è¿”å›ç»“æœï¼š

```moonbit
fn add3(x: Int, y: Int, z: Int)-> Int {
  x + y + z
}
```

æ³¨æ„ï¼Œé¡¶å±‚å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹éœ€è¦æ˜¾å¼æ ‡æ³¨ã€‚

### å±€éƒ¨å‡½æ•°

å±€éƒ¨å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—å®šä¹‰ã€‚å±€éƒ¨å‡½æ•°å¯ä»¥æ˜¯å‘½åçš„æˆ–åŒ¿åçš„ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå±€éƒ¨å‡½æ•°çš„ç±»å‹æ³¨è§£å¯ä»¥çœç•¥ï¼Œå› ä¸ºç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn foo() -> Int {
  fn inc(x) { x + 1 }       // å‘½åä¸º `inc`
  fn (x) { x + inc(2) } (6) // åŒ¿åï¼Œç«‹å³åº”ç”¨åˆ°æ•´æ•°å­—é¢é‡ 6
}

fn init {
  print(foo())
}
```

æ— è®ºæ˜¯å‘½åçš„è¿˜æ˜¯åŒ¿åçš„ï¼Œå‡½æ•°éƒ½æ˜¯ _è¯æ³•é—­åŒ…_ï¼šä»»ä½•æ²¡æœ‰å±€éƒ¨ç»‘å®šçš„æ ‡è¯†ç¬¦ï¼Œ
å¿…é¡»å¼•ç”¨æ¥è‡ªå‘¨å›´è¯æ³•ä½œç”¨åŸŸçš„ç»‘å®šï¼š

```moonbit live
let y = 3
fn foo(x: Int) -> Unit {
  fn inc()  { x + 1 } // OKï¼Œè¿”å› x + 1
  fn four() { y + 1 } // Okï¼Œè¿”å› 4
  print(inc())
  print(four())
}

fn init {
  foo(2)
}
```

### å‡½æ•°è°ƒç”¨

å‡½æ•°å¯é€šè¿‡å‘åœ†æ‹¬å·å†…ä¼ å…¥å‚æ•°åˆ—è¡¨è¿›è¡Œè°ƒç”¨ï¼š

```moonbit
add3(1, 2, 7)
```

è¿™é€‚ç”¨äºå‘½åå‡½æ•°ï¼ˆå¦‚å‰é¢çš„ä¾‹å­ï¼‰å’Œç»‘å®šåˆ°å‡½æ•°å€¼çš„å˜é‡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```moonbit live
fn init {
  let add3 = fn(x, y, z) { x + y + z }
  print(add3(1, 2, 7))
}
```

è¡¨è¾¾å¼ `add3(1, 2, 7)` è¿”å› `10`ã€‚ä»»ä½•æ±‚å€¼ä¸ºå‡½æ•°å€¼çš„è¡¨è¾¾å¼éƒ½å¯ä»¥è¢«è°ƒç”¨ï¼š

```moonbit live
fn init {
  let f = fn (x) { x + 1 }
  let g = fn (x) { x + 2 }
  print((if true { f } else { g })(3)) // OK
}
```

### å¸¦æ ‡ç­¾çš„å‚æ•°

å¯ä»¥ç”¨ `~label : Type` çš„è¯­æ³•ä¸ºå‡½æ•°å£°æ˜å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚å‡½æ•°ä½“å†…å‚æ•°çš„åå­—ä¹Ÿæ˜¯ `label`ï¼š

```moonbit
fn labelled(~arg1 : Int, ~arg2 : Int) -> Int {
  arg1 + arg2
}
```

è°ƒç”¨å‡½æ•°æ—¶ï¼Œå¯ä»¥ç”¨ `label=arg` çš„è¯­æ³•æä¾›å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚`label=label` å¯ä»¥ç®€å†™æˆ `~label`ï¼š

```moonbit
fn init {
  let arg1 = 1
  println(labelled(arg2=2, ~arg1)) // 3
}
```

å¯ä»¥ç”¨ä»»æ„çš„é¡ºåºæä¾›å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚å‚æ•°çš„æ±‚å€¼é¡ºåºä¸å‡½æ•°å£°æ˜ä¸­å‚æ•°çš„é¡ºåºç›¸åŒã€‚

### å¯é€‰çš„å‚æ•°

å¯é€‰çš„å‚æ•°æ˜¯å¸¦æœ‰é»˜è®¤å€¼çš„å¸¦æ ‡ç­¾å‚æ•°ã€‚å£°æ˜å¯é€‰çš„å‚æ•°çš„è¯­æ³•æ˜¯ `~label : Type = default_expr`ã€‚è°ƒç”¨å‡½æ•°æ—¶ï¼Œå¦‚æœæ²¡æœ‰æä¾›è¿™ä¸ªå‚æ•°ï¼Œå°±ä¼šä½¿ç”¨é»˜è®¤å€¼ä½œä¸ºå‚æ•°ï¼š

```moonbit live
fn optional(~opt : Int = 42) -> Int {
  opt
}

fn init {
  println(optional()) // 42
  println(optional(opt=0)) // 0
}
```

æ¯æ¬¡ä½¿ç”¨é»˜è®¤å‚æ•°è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œéƒ½ä¼šé‡æ–°æ±‚å€¼é»˜è®¤å€¼çš„è¡¨è¾¾å¼ï¼Œä¹Ÿä¼šè¢«é‡æ–°è§¦å‘å…¶ä¸­çš„å‰¯ä½œç”¨ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn incr(~counter : Ref[Int] = { val: 0 }) -> Ref[Int] {
  counter.val = counter.val + 1
  counter
}

fn init {
  println(incr()) // 1
  println(incr()) // ä¾ç„¶æ˜¯ 1ï¼Œå› ä¸ºé‡æ–°æ±‚å€¼äº†é»˜è®¤è¡¨è¾¾å¼ï¼Œäº§ç”Ÿäº†ä¸€ä¸ªæ–°çš„ Ref
  let counter : Ref[Int] = { val: 0 }
  println(incr(~counter)) // 1
  println(incr(~counter)) // 2ï¼Œå› ä¸ºä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨äº†åŒä¸€ä¸ª Ref
}
```

å¦‚æœæƒ³è¦åœ¨å¤šæ¬¡ä¸åŒçš„å‡½æ•°è°ƒç”¨ä¹‹é—´å…±äº«é»˜è®¤å€¼ï¼Œå¯ä»¥æå‰ç”¨ `let` è®¡ç®—å¹¶ä¿å­˜é»˜è®¤å€¼ï¼š

```moonbit live
let default_counter : Ref[Int] = { val: 0 }

fn incr(~counter : Ref[Int] = default_counter) -> Int {
  counter.val = counter.val + 1
  counter.val
}

fn init {
  println(incr()) // 1
  println(incr()) // 2
}
```

é»˜è®¤å€¼å¯ä»¥ä¾èµ–äºå‰é¢çš„å‚æ•°ï¼Œä¾‹å¦‚ï¼š

```moonbit
fn sub_array[X](xs : Array[X], ~offset : Int, ~len : Int = xs.length() - offset) -> Array[X] {
  ... // ç”Ÿæˆ xs çš„ä¸€ä¸ªä» offset å¼€å§‹ã€é•¿åº¦ä¸º len çš„å­æ•°ç»„
}

fn init {
  println(sub_array([1, 2, 3], offset=1)) // [2, 3]
  println(sub_array([1, 2, 3], offset=1, len=1)) // [2]
}
```

### è‡ªåŠ¨å¡«å……çš„å‚æ•°

MoonBit èƒ½å¤Ÿè‡ªåŠ¨åœ¨æ¯æ¬¡å‡½æ•°è°ƒç”¨æ—¶å¡«å……æŸäº›ç‰¹å®šç±»å‹çš„å‚æ•°ï¼Œä¾‹å¦‚å‡½æ•°è°ƒç”¨åœ¨æºç ä¸­çš„ä½ç½®ã€‚è¦å£°æ˜è¿™ç§è‡ªåŠ¨å¡«å……çš„å‚æ•°ï¼Œåªéœ€è¦ä½¿ç”¨ `_` ä½œä¸ºå‚æ•°çš„é»˜è®¤å€¼å³å¯ã€‚å¦‚æœåœ¨è°ƒç”¨æ—¶æ²¡æœ‰æä¾›è¿™ä¸ªå‚æ•°ï¼ŒMoonBit å°±ä¼šè‡ªåŠ¨æ ¹æ®è°ƒç”¨å¤„çš„ä¸Šä¸‹æ–‡å¡«å……è¿™ä¸ªå‚æ•°ã€‚

ç›®å‰ MoonBit æ”¯æŒä¸¤ç§ç±»å‹çš„è‡ªåŠ¨å¡«å……å‚æ•°ã€‚ä»£è¡¨æ•´ä¸ªå‡½æ•°è°ƒç”¨åœ¨æºç ä¸­ä½ç½®çš„ `SourceLoc` ç±»å‹ï¼Œä»¥åŠåŒ…å«æ¯ä¸ªå‚æ•°å„è‡ªçš„ä½ç½®çš„ `ArgsLoc` ç±»å‹ï¼š

```moonbit
fn f(_x : Int, _y : Int, ~loc : SourceLoc = _, ~args_loc : ArgsLoc = _) -> Unit {
  println("æ•´ä¸ªå‡½æ•°è°ƒç”¨çš„ä½ç½®ï¼š\(loc)")
  println("å„ä¸ªå‚æ•°çš„ä½ç½®ï¼š\(args_loc)")
}

fn init {
  f(1, 2)
  // æ•´ä¸ªå‡½æ•°è°ƒç”¨çš„ä½ç½®ï¼š<æ–‡ä»¶å>:7:3-7:10
  // å„ä¸ªå‚æ•°çš„ä½ç½®ï¼š[Some(<æ–‡ä»¶å>:7:5-7:6), Some(<æ–‡ä»¶å>:7:8-7:9), None, None]
}
```

è‡ªåŠ¨å¡«å……çš„å‚æ•°å¯ä»¥ç”¨äºç¼–å†™è°ƒè¯•å’Œæµ‹è¯•ç”¨çš„å·¥å…·å‡½æ•°ã€‚

## æ§åˆ¶ç»“æ„

### æ¡ä»¶è¡¨è¾¾å¼

æ¡ä»¶è¡¨è¾¾å¼ç”±æ¡ä»¶ã€ç»“æœå’Œä¸€ä¸ªå¯é€‰çš„ `else` å­å¥ç»„æˆã€‚

```moonbit
if x == y {
  expr1
} else {
  expr2
}

if x == y {
  expr1
}
```

`else` å­å¥ä¹Ÿå¯ä»¥åŒ…å«å¦ä¸€ä¸ª `if-else` è¡¨è¾¾å¼ï¼š

```moonbit
if x == y {
  expr1
} else if z == k {
  expr2
}
```

èŠ±æ‹¬å·ç”¨äºåœ¨ç»“æœæˆ– `else` å­å¥ä¸­ç»„åˆè¡¨è¾¾å¼ã€‚

æ³¨æ„ï¼Œåœ¨ MoonBit ä¸­ï¼Œæ¡ä»¶è¡¨è¾¾å¼æ€»æ˜¯è¿”å›ä¸€ä¸ªå€¼ï¼Œå…¶ç»“æœå’Œ `else` å­å¥çš„è¿”å›å€¼ç±»å‹å¿…é¡»ç›¸åŒã€‚


### While å¾ªç¯

MoonBitä¸­æ”¯æŒ`while`å¾ªç¯ã€‚`while`åçš„å¾ªç¯æ¡ä»¶ä¼šåœ¨å¾ªç¯ä½“ä¹‹å‰æ‰§è¡Œï¼Œå½“å¾ªç¯æ¡ä»¶ä¸ºçœŸæ—¶, æ‰§è¡Œå¾ªç¯ä½“ï¼š

```moonbit
let mut i = 5
while i > 0 {
  println(i)
  i = i - 1
}
```

å¾ªç¯ä½“å†…æ”¯æŒ`break`å’Œ`continue`ã€‚ä½¿ç”¨`break`èƒ½å¤Ÿè·³å‡ºå½“å‰å¾ªç¯ï¼›ä½¿ç”¨`continue`è·³è¿‡æœ¬æ¬¡å¾ªç¯çš„å‰©ä½™éƒ¨åˆ†ï¼Œæå‰è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚


```moonbit 
let mut i = 5
while i > 0 {
  i = i - 1
  if i == 4 { continue }
  if i == 1 { break }
  println(i)
}
```

è¾“å‡º:

```
3
2
```

`while` å¾ªç¯ä¹Ÿæ”¯æŒå¯é€‰çš„`else`å­å¥ã€‚å½“å¾ªç¯æ¡ä»¶è½¬å˜ä¸ºå‡æ—¶ï¼Œå°†ä¼šæ‰§è¡Œ`else`å­å¥ï¼Œç„¶åå¾ªç¯ç»“æŸã€‚

```moonbit 
let mut i = 2
while i > 0 {
  println(i)
  i = i - 1
} else {
  println(i)
}
```

è¾“å‡º:

```
2
1
0
```

å½“å­˜åœ¨ `else` å­å¥æ—¶ï¼Œ`while` å¾ªç¯ä¹Ÿå¯ä»¥è¿”å›ä¸€ä¸ªå€¼ï¼Œè¿”å›å€¼æ˜¯ `else` å­å¥è¯­å¥å—çš„æ±‚å€¼ç»“æœã€‚æ­¤æ—¶å¦‚æœä½¿ç”¨`break`è·³å‡ºå¾ªç¯ï¼Œéœ€è¦åœ¨`break`åæä¾›ä¸€ä¸ªè¿”å›å€¼ï¼Œç±»å‹ä¸`else`å­å¥çš„è¿”å›å€¼ç±»å‹ä¸€è‡´ï¼š


```moonbit 
  let mut i = 10
  let r1 = 
    while i > 0 {
      i = i - 1
      if i % 2 == 0 { break 5 } // è·³å‡ºå¾ªç¯å¹¶è¿”å› 5
    } else {
      7
    }
  println(r1) //output: 5
```

```moonbit 
  let mut i = 10
  let r2 = 
    while i > 0 {
      i = i - 1
    } else {
      7
    }
  println(r2) //output: 7
```

## For å¾ªç¯

MoonBit ä¹Ÿæ”¯æŒ C é£æ ¼çš„ For å¾ªç¯ã€‚å…³é”®å­—`for`åä¾æ¬¡è·Ÿéšä»¥åˆ†å·é—´éš”çš„å˜é‡åˆå§‹åŒ–å­å¥ã€å¾ªç¯æ¡ä»¶å’Œæ›´æ–°å­å¥ã€‚ä¸‰è€…ä¸éœ€è¦ä½¿ç”¨åœ†æ‹¬å·åŒ…è£¹ã€‚
ä¾‹å¦‚ä¸‹é¢çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å˜é‡ç»‘å®š`i`, å®ƒçš„ä½œç”¨åŸŸåœ¨æ•´ä¸ªå¾ªç¯ä¸­ï¼Œä¸”æ˜¯ä¸å¯å˜çš„ã€‚è¿™æ›´åˆ©äºç¼–å†™æ¸…æ™°çš„ä»£ç å’Œæ¨ç†ï¼š

```moonbit
for i = 0; i < 5; i = i + 1 {
  println(i)
} 
// output:
// 0
// 1
// 2
```

å˜é‡åˆå§‹åŒ–å­å¥ä¸­å¯ä»¥åˆ›å»ºå¤šä¸ªç»‘å®šï¼š

```moonbit
for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {
  println(i)
}
```

éœ€è¦æ³¨æ„çš„æ˜¯åœ¨æ›´æ–°å­å¥ä¸­ï¼Œå¯¹äºå¤šä¸ªç»‘å®šå˜é‡å…·æœ‰åŒæ—¶æ›´æ–°çš„è¯­ä¹‰ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæ›´æ–°å­å¥å¹¶ä¸æ˜¯é¡ºåºæ‰§è¡Œ`i = i + 1`ã€`j = j + 1`ï¼Œè€Œæ˜¯åŒæ—¶ä»¤`i`ã€`j`è‡ªå¢ã€‚å› æ­¤ï¼Œåœ¨æ›´æ–°å­å¥ä¸­è¯»å–ç»‘å®šå˜é‡å¾—åˆ°çš„å€¼æ°¸è¿œæ˜¯ä¸Šä¸€æ¬¡å¾ªç¯æ›´æ–°åçš„å€¼ã€‚



å˜é‡åˆå§‹åŒ–å­å¥ã€å¾ªç¯æ¡ä»¶å’Œæ›´æ–°å­å¥éƒ½æ˜¯å¯é€‰çš„ã€‚ä¾‹å¦‚ä¸‹é¢ä¸¤ä¸ªæ— é™å¾ªç¯ï¼š

```moonbit
for i=1;; i=i+1 {
  println(i) // loop forever!
}
```

```moonbit
for {
  println("loop forever!")
}
```

`for` å¾ªç¯åŒæ ·æ”¯æŒ`continue`ã€`break`å’Œ`else`å­å¥ã€‚å’Œ`while`å¾ªç¯ä¸€æ ·ï¼Œ`for` å¾ªç¯åŒæ ·
æ”¯æŒä½¿ç”¨`break`å’Œ`else`å­å¥ä½¿`for`è¯­å¥è¿”å›ä¸€ä¸ªå€¼ã€‚

ä½¿ç”¨`continue`è¯­å¥å°†è·³è¿‡`for`æœ¬æ¬¡å¾ªç¯çš„å‰©ä½™éƒ¨åˆ†ï¼ˆåŒ…æ‹¬æ›´æ–°å­å¥ï¼‰æå‰è¿›å…¥ä¸‹æ¬¡å¾ªç¯ã€‚`continue`è¯­å¥
ä¹Ÿæ”¯æŒåŒæ—¶æ›´æ–°`for`å¾ªç¯çš„ç»‘å®šå˜é‡ï¼Œåªè¦åœ¨`continue`åé¢è·Ÿéšå’Œç»‘å®šå˜é‡æ•°é‡ä¸€è‡´çš„è¡¨è¾¾å¼ï¼Œå¤šä¸ªè¡¨è¾¾å¼ä½¿ç”¨é€—å·åˆ†éš”ã€‚

ä¾‹å¦‚ï¼Œä¸‹é¢çš„ç¨‹åºè®¡ç®—æ•°å­—1åˆ°6ä¸­çš„å¶æ•°çš„å’Œï¼š

```moonbit live
fn main {
  let sum =
    for i = 1, acc = 0; i <= 6; i = i + 1 {
      if i % 2 == 0 {
        println("even: \(i)")
        continue i + 1, acc + i
      }
    } else {
      acc
    }
  println(sum)
}
```

è¾“å‡ºï¼š

```
even: 2
even: 4
even: 6
12
```

### å‡½æ•°å¼å¾ªç¯

å‡½æ•°å¼å¾ªç¯æ˜¯ MoonBit ä¸­ä¸€ä¸ªå¼ºå¤§çš„ç‰¹æ€§ï¼Œå®ƒèƒ½è®©æ‚¨ä»¥å‡½æ•°å¼é£æ ¼ç¼–å†™å¾ªç¯ã€‚

å‡½æ•°å¼å¾ªç¯æ¥å—å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚å®ƒä½¿ç”¨ `loop` å…³é”®å­—å®šä¹‰ï¼Œåè·Ÿå…¶å‚æ•°å’Œå¾ªç¯ä½“ã€‚
å¾ªç¯ä½“æ˜¯ä¸€ç³»åˆ—å­å¥ï¼Œæ¯ä¸ªå­å¥ç”±æ¨¡å¼å’Œè¡¨è¾¾å¼ç»„æˆã€‚
ä¸è¾“å…¥åŒ¹é…çš„æ¨¡å¼ä¼šè¢«æ‰§è¡Œï¼Œå¹¶ä¸”å¾ªç¯å°†è¿”å›è¡¨è¾¾å¼çš„å€¼ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…çš„æ¨¡å¼ï¼Œå¾ªç¯å°†æŠ›å‡ºå¼‚å¸¸ã€‚
å¯ä»¥ä½¿ç”¨ `continue` å…³é”®å­—å’Œå‚æ•°å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯è¿­ä»£ï¼Œä½¿ç”¨ `break` å…³é”®å­—å’Œå‚æ•°æ¥ä»å¾ªç¯ä¸­è¿”å›ä¸€ä¸ªå€¼ã€‚
å¦‚æœå€¼æ˜¯å¾ªç¯ä½“ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåˆ™å¯ä»¥çœç•¥ `break` å…³é”®å­—ã€‚

```moonbit live
fn sum(xs: List[Int]) -> Int {
  loop xs, 0 {
    Nil, acc => break acc // break å¯ä»¥çœç•¥
    Cons(x, rest), acc => continue rest, x + acc
  }
}

fn init {
  println(sum(Cons(1, Cons(2, Cons(3, Nil)))))
}
```

## å†…ç½®æ•°æ®ç»“æ„

### å¸ƒå°”å€¼

MoonBit å†…ç½®äº†å¸ƒå°”ç±»å‹ï¼Œå®ƒæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ã€‚å¸ƒå°”ç±»å‹ç”¨äºæ¡ä»¶è¡¨è¾¾å¼å’Œæ§åˆ¶ç»“æ„ã€‚

```moonbit
let a = true
let b = false
let c = a && b
let d = a || b
let e = not(a)
```

### æ•°å­—

MoonBit æ”¯æŒæ•´å‹å’Œæµ®ç‚¹ç±»å‹ï¼š

| ç±»å‹     | æè¿°                         |   ä¾‹å­   |
| -------- | ---------------------------- | ------- |
| `Int`    | 32 ä½æœ‰ç¬¦å·æ•´æ•°              | `42`      |
| `Int64`  | 64 ä½æœ‰ç¬¦å·æ•´æ•°              | `1000L`   |
| `UInt`   | 32 ä½æ— ç¬¦å·æ•´æ•°              ï½œ`14U`     |
| `UInt64` | 64 ä½æ— ç¬¦å·æ•´æ•°              | `14UL`   |
| `Double` | 64 ä½æµ®ç‚¹æ•°ï¼Œç”± IEEE754 å®šä¹‰ | `3.14`    |

MoonBit æ”¯æŒçš„æ•°å­—å­—é¢é‡ï¼ŒåŒ…æ‹¬åè¿›åˆ¶ã€äºŒè¿›åˆ¶ã€å…«è¿›åˆ¶å’Œåå…­è¿›åˆ¶ã€‚

ä¸ºäº†æå‡å¯è¯»æ€§ï¼Œä½ å¯ä»¥åœ¨æ•°å­—å­—é¢é‡å†…æ’å…¥ä¸‹åˆ’çº¿ï¼Œä¾‹å¦‚ `1_000_000`ã€‚
æ³¨æ„ï¼Œä¸‹åˆ’çº¿å¯ä»¥æ’å…¥åˆ°æ•°å­—ä¹‹é—´çš„ä»»ä½•ä½ç½®ï¼Œè€Œéåªèƒ½åœ¨æ¯ä¸‰ä¸ªæ•°å­—ä¹‹é—´ã€‚

- åè¿›åˆ¶æ•°å’Œå¾€å¸¸ä¸€æ ·ã€‚

```moonbit
let a = 1234
let b = 1_000_000 + a
let large_num = 9_223_372_036_854_775_807L // Int64 ç±»å‹çš„æ•´æ•°å¿…é¡»åç¼€â€œLâ€
let unsigned_num = 4_294_967_295U // UInt ç±»å‹çš„æ•´æ•°å¿…é¡»æœ‰åç¼€â€Uâ€œ
```

- å…«è¿›åˆ¶æ•°çš„å‰ç¼€æ˜¯ 0 åæ¥å­—æ¯ Oï¼Œä¹Ÿå°±æ˜¯ `0o` æˆ– `0O`ã€‚æ³¨æ„åœ¨ `0o` æˆ– `0O`
  ä¹‹åå‡ºç°çš„æ•°å­—åªèƒ½åœ¨ `0` åˆ° `7` ä¹‹é—´ã€‚

```moonbit
let octal = 0o1234
let another_octal = 0O1234
```

- åå…­è¿›åˆ¶æ•°çš„å‰ç¼€æ˜¯ 0 åæ¥å­—æ¯ Xï¼Œä¹Ÿå°±æ˜¯ `0x` æˆ– `0X`ã€‚æ³¨æ„åœ¨ `0x` æˆ– `0X`
  ä¹‹åå‡ºç°çš„æ•°å­—åªèƒ½æ˜¯ `0123456789ABCDEF` ä¹‹ä¸€ã€‚

```moonbit
let hex = 0XA
let another_hex = 0xA
```

### å­—ç¬¦ä¸²

å­—ç¬¦ä¸²`String`å†…éƒ¨ä¿å­˜äº† UTF-16 ç¼–ç å•å…ƒåºåˆ—ã€‚å¯ä»¥ä½¿ç”¨åŒå¼•å·æ¥è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ–è€…é€šè¿‡`#|`æ¥ä¹¦å†™å¤šè¡Œå­—ç¬¦ä¸²ã€‚

```moonbit
let a = "å…”rabbit"
println(a[0]) // output: å…”
println(a[1]) // output: r
```

```moonbit
let b =
  #| Hello
  #| MoonBit
  #|
```

åœ¨åŒå¼•å·åŒ…å›´çš„å­—ç¬¦ä¸²ä¹‹é—´æ”¯æŒä½¿ç”¨`\`è¡¨ç¤ºç‰¹æ®Šå­—ç¬¦è½¬ä¹‰ï¼š

| è½¬ä¹‰åºåˆ—             | è§£é‡Š                         |
| -------------------- | ---------------------------- |
| `\n`,`\r`,`\t`,`\b`  | æ¢è¡Œã€å›è½¦ã€æ°´å¹³åˆ¶è¡¨ç¬¦ã€é€€æ ¼ |
| `\\`                 | åæ–œæ                        |
| `\x41`               | 16 è¿›åˆ¶è½¬ä¹‰åºåˆ—              |
| `\o102`              | 8 è¿›åˆ¶è½¬ä¹‰åºåˆ—               |
| `\u5154`,`\u{1F600}` | Unicode å­—ç¬¦è½¬ä¹‰åºåˆ—         |

MoonBit æ”¯æŒå­—ç¬¦ä¸²æ’å€¼ï¼Œå®ƒå¯ä»¥æŠŠå­—ç¬¦ä¸²ä¸­å†…æ’çš„å˜é‡æ›¿æ¢ä¸ºå˜é‡å…·ä½“çš„å€¼ã€‚
è¿™ä¸ªç‰¹æ€§èƒ½å¤Ÿç®€åŒ–åŠ¨æ€æ‹¼æ¥å­—ç¬¦ä¸²çš„è¿‡ç¨‹ã€‚

```moonbit live
fn init {
  let x = 42
  print("The answer is \(x)")
}
```

ç”¨äºå­—ç¬¦ä¸²å†…æ’çš„å˜é‡å¿…é¡»æ”¯æŒ `to_string` æ–¹æ³•ã€‚

### å­—ç¬¦

å­—ç¬¦`Char`æ˜¯è¡¨ç¤ºä¸€ä¸ª Unicode å­—ç¬¦çš„æ•´æ•°ã€‚

```moonbit
let a : Char = 'A'
let b = '\x41'
let c = 'ğŸ°'
let zero = '\u{30}'
let zero = '\u0030'
```

### å­—èŠ‚

åœ¨ MoonBit ä¸­ï¼Œå­—èŠ‚å­—é¢é‡å¯ä»¥æ˜¯ä¸€ä¸ª ASCII å­—ç¬¦æˆ–ä¸€ä¸ªè½¬ä¹‰åºåˆ—ï¼Œå®ƒä»¬è¢«å•å¼•å·`'`åŒ…å›´ï¼Œå¹¶ä¸”å‰é¢æœ‰å­—ç¬¦`b`ã€‚å­—èŠ‚å­—é¢é‡çš„ç±»å‹æ˜¯ Byteã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn init {
  let b1 : Byte = b'a'
  println(b1.to_int())
  let b2 = b'\xff'
  println(b2.to_int())
}
```

### å…ƒç»„

å…ƒç»„æ˜¯ä¸€ä¸ªæœ‰é™å€¼çš„æœ‰åºé›†åˆï¼Œä½¿ç”¨åœ†æ‹¬å· `()` æ„é€ ï¼Œå…¶ä¸­çš„å…ƒç´ ç”±é€—å· `,` åˆ†éš”ã€‚
å…ƒç´ çš„é¡ºåºå¾ˆé‡è¦ï¼Œä¾‹å¦‚ `(1, true)` å’Œ `(true, 1)` æ˜¯ä¸åŒçš„ç±»å‹ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```moonbit live
fn pack(a: Bool, b: Int, c: String, d: Double) -> (Bool, Int, String, Double) {
    (a, b, c, d)
}
fn init {
    let quad = pack(false, 100, "text", 3.14)
    let (bool_val, int_val, str, float_val) = quad
    println("\(bool_val) \(int_val) \(str) \(float_val)")
}
```

å¯ä»¥é€šè¿‡æ¨¡å¼åŒ¹é…æˆ–ç´¢å¼•æ¥è®¿é—®å…ƒç»„ï¼š

```moonbit live
fn f(t : (Int, Int)) -> Unit {
  let (x1, y1) = t  // é€šè¿‡æ¨¡å¼åŒ¹é…è®¿é—®
  // é€šè¿‡ç´¢å¼•è®¿é—®
  let x2 = t.0
  let y2 = t.1
  if (x1 == x2 && y1 == y2) {
    print("yes")
  } else {
    print("no")
  }
}

fn init {
  f((1, 2))
}
```

### æ•°ç»„

æ•°ç»„æ˜¯ç”±æ–¹æ‹¬å· `[]` æ„é€ çš„æœ‰é™å€¼åºåˆ—ï¼Œå…¶ä¸­å…ƒç´ ç”±é€—å· `,` åˆ†éš”ã€‚ä¾‹å¦‚ï¼š

```moonbit
let numbers = [1, 2, 3, 4]
```

å¯ä»¥ç”¨ `numbers[x]` æ¥å¼•ç”¨ç¬¬ `x` ä¸ªå…ƒç´ ã€‚ç´¢å¼•ä»é›¶å¼€å§‹ã€‚

```moonbit live
fn init {
  let numbers = [1, 2, 3, 4]
  let a = numbers[2]
  numbers[3] = 5
  let b = a + numbers[3]
  print(b)  // æ‰“å° 8
}
```

## å˜é‡ç»‘å®š

å˜é‡å¯ä»¥é€šè¿‡ `let mut` æˆ– `let` åˆ†åˆ«å£°æ˜ä¸ºå¯å˜æˆ–ä¸å¯å˜ã€‚
å¯å˜å˜é‡å¯ä»¥é‡æ–°èµ‹å€¼ï¼Œä¸å¯å˜å˜é‡åˆ™ä¸èƒ½ã€‚

```moonbit live
let zero = 0

fn init {
  let mut i = 10
  i = 20
  print(i + zero)
}
```

## æ•°æ®ç±»å‹

åˆ›å»ºæ–°æ•°æ®ç±»å‹çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼š`struct` å’Œ `enum`ã€‚

### ç»“æ„

åœ¨ MoonBit ä¸­ï¼Œç»“æ„ä¸å…ƒç»„ç±»ä¼¼ï¼Œä½†å®ƒä»¬çš„å­—æ®µç”±å­—æ®µåç´¢å¼•ã€‚
ç»“æ„ä½“å¯ä»¥ä½¿ç”¨ç»“æ„ä½“å­—é¢é‡æ„é€ ï¼Œç»“æ„ä½“å­—é¢é‡ç”±ä¸€ç»„å¸¦æœ‰æ ‡ç­¾çš„å€¼ç»„æˆï¼Œå¹¶ç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ã€‚
å¦‚æœç»“æ„ä½“å­—é¢é‡çš„å­—æ®µå®Œå…¨åŒ¹é…ç±»å‹å®šä¹‰ï¼Œåˆ™å…¶ç±»å‹å¯ä»¥è¢«è‡ªåŠ¨æ¨æ–­ã€‚
ä½¿ç”¨ç‚¹è¯­æ³• `s.f` å¯ä»¥è®¿é—®ç»“æ„ä½“å­—æ®µã€‚
å¦‚æœä¸€ä¸ªå­—æ®µä½¿ç”¨å…³é”®å­— `mut` æ ‡è®°ä¸ºå¯å˜ï¼Œé‚£ä¹ˆå¯ä»¥ç»™å®ƒèµ‹äºˆæ–°çš„å€¼ã€‚

```moonbit live
struct User {
  id: Int
  name: String
  mut email: String
}

fn init {
  let u = { id: 0, name: "John Doe", email: "john@doe.com" }
  u.email = "john@doe.name"
  println(u.id)
  println(u.name)
  println(u.email)
}
```

#### åˆ›å»ºç»“æ„ä½“çš„ç®€å†™å½¢å¼

å¦‚æœå·²ç»æœ‰å’Œç»“æ„ä½“çš„å­—æ®µåŒåçš„å˜é‡ï¼Œå¹¶ä¸”æƒ³ä½¿ç”¨è¿™äº›å˜é‡ä½œä¸ºç»“æ„ä½“åŒåå­—æ®µçš„å€¼ï¼Œ
é‚£ä¹ˆåˆ›å»ºç»“æ„ä½“æ—¶ï¼Œå¯ä»¥åªå†™å­—æ®µåï¼Œä¸éœ€è¦æŠŠåŒä¸€ä¸ªåå­—é‡å¤ä¸¤æ¬¡ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn init{
  let name = "john"
  let email = "john@doe.com"
  let u = { id: 0, name, email } // ç­‰ä»·äº { id: 0, name: name, email: email }
}
```

#### æ›´æ–°ç»“æ„ä½“çš„è¯­æ³•

å¦‚æœæƒ³è¦åŸºäºç°æœ‰çš„ç»“æ„ä½“æ¥åˆ›å»ºæ–°çš„ç»“æ„ä½“ï¼Œåªéœ€ä¿®æ”¹ç°æœ‰ç»“æ„ä½“çš„ä¸€éƒ¨åˆ†å­—æ®µï¼Œå…¶ä»–å­—æ®µçš„å€¼ä¿æŒä¸å˜ï¼Œ
å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼š

```moonbit live
struct User {
  id: Int
  name: String
  email: String
} derive(Debug)

fn init {
  let user = { id: 0, name: "John Doe", email: "john@doe.com" }
  let updated_user = { ..user, email: "john@doe.name" }
  debug(user)          // è¾“å‡º: { id: 0, name: "John Doe", email: "john@doe.com" }
  debug(updated_user)  // è¾“å‡º: { id: 0, name: "John Doe", email: "john@doe.name" }
}
```

### æšä¸¾

æšä¸¾ç±»å‹å¯¹åº”äºä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼ŒADTï¼‰ï¼Œ
ç†Ÿæ‚‰ C/C++ çš„äººå¯èƒ½æ›´ä¹ æƒ¯å«å®ƒå¸¦æ ‡ç­¾çš„è”åˆä½“ï¼ˆtagged unionï¼‰ã€‚

æšä¸¾ç”±ä¸€ç»„åˆ†æ”¯ï¼ˆæ„é€ å™¨ï¼‰ç»„æˆï¼Œæ¯ä¸ªåˆ†æ”¯éƒ½æœ‰ä¸€ä¸ªåå­—ï¼ˆå¿…é¡»ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼‰ï¼Œå¯ä»¥ç”¨è¿™ä¸ªåå­—æ¥æ„é€ å¯¹åº”åˆ†æ”¯çš„å€¼ï¼Œ
æˆ–è€…åœ¨æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨è¿™ä¸ªåå­—æ¥åˆ¤æ–­æŸä¸ªæšä¸¾å€¼å±äºå“ªä¸ªåˆ†æ”¯ï¼š

```moonbit live
// ä¸€ä¸ªè¡¨ç¤ºä¸¤ä¸ªå€¼ä¹‹é—´çš„æœ‰åºå…³ç³»çš„æšä¸¾ç±»å‹ï¼Œæœ‰ â€œå°äºâ€ã€â€œå¤§äºâ€ã€â€œç­‰äºâ€ ä¸‰ä¸ªåˆ†æ”¯
enum Relation {
  Smaller
  Greater
  Equal
}

// è®¡ç®—ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„é¡ºåºå…³ç³»
fn compare_int(x: Int, y: Int) -> Relation {
  if x < y {
    // åˆ›å»ºæšä¸¾æ—¶ï¼Œå¦‚æœçŸ¥é“æƒ³è¦ä»€ä¹ˆç±»å‹ï¼Œå¯ä»¥ç›´æ¥å†™åˆ†æ”¯/æ„é€ å™¨çš„åå­—æ¥åˆ›å»º
    Smaller
  } else if x > y {
    // ä½†å¦‚æœä¸çŸ¥é“ç±»å‹ï¼Œæ°¸è¿œå¯ä»¥é€šè¿‡ `ç±»å‹åå­—::æ„é€ å™¨` çš„è¯­æ³•æ¥æ— æ­§ä¹‰åœ°åˆ›å»ºæšä¸¾å€¼
    Relation::Greater
  } else {
    Equal
  }
}

// è¾“å‡ºä¸€ä¸ª `Relation` ç±»å‹çš„å€¼
fn print_relation(r: Relation) -> Unit {
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…åˆ¤æ–­ r å±äºå“ªä¸ªåˆ†æ”¯
  match r {
    // æ¨¡å¼åŒ¹é…æ—¶ï¼Œå¦‚æœçŸ¥é“ç±»å‹ï¼Œç›´æ¥ä½¿ç”¨æ„é€ å™¨åå­—å³å¯
    Smaller => println("smaller!")
    // ä½†ä¹Ÿå¯ä»¥ç”¨ `ç±»å‹åå­—::æ„é€ å™¨` çš„è¯­æ³•è¿›è¡Œæ¨¡å¼åŒ¹é…
    Relation::Greater => println("greater!")
    Equal => println("equal!")
  }
}

fn init {
  print_relation(compare_int(0, 1)) // è¾“å‡º smaller!
  print_relation(compare_int(1, 1)) // è¾“å‡º equal!
  print_relation(compare_int(2, 1)) // è¾“å‡º greater!
}
```

æšä¸¾çš„åˆ†æ”¯è¿˜å¯ä»¥æºå¸¦é¢å¤–çš„æ•°æ®ã€‚ä¸‹é¢æ˜¯ç”¨æšä¸¾å®šä¹‰æ•´æ•°åˆ—è¡¨ç±»å‹çš„ä¸€ä¸ªä¾‹å­ï¼š

```moonbit live
enum List {
  Nil
  // æ„é€ å™¨ `Cons` æºå¸¦äº†é¢å¤–çš„æ•°æ®ï¼šåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå’Œåˆ—è¡¨å‰©ä½™çš„éƒ¨åˆ†
  Cons (Int, List)
}

fn init {
  // ä½¿ç”¨ `Cons` åˆ›å»ºåˆ—è¡¨æ—¶ï¼Œéœ€è¦æä¾› `Cons` è¦æ±‚çš„é¢å¤–æ•°æ®ï¼šç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä½™çš„åˆ—è¡¨
  let l: List = Cons(1, Cons(2, Nil))
  println(is_singleton(l))
  print_list(l)
}

fn print_list(l: List) -> Unit {
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†å¸¦é¢å¤–æ•°æ®çš„æšä¸¾æ—¶ï¼Œé™¤äº†åˆ¤æ–­å€¼å±äºå“ªä¸ªåˆ†æ”¯ï¼Œ
  // è¿˜å¯ä»¥æŠŠå¯¹åº”åˆ†æ”¯æºå¸¦çš„æ•°æ®æå–å‡ºæ¥
  match l {
    Nil => print("nil")
    // è¿™é‡Œçš„ `x` å’Œ `xs` ä¸æ˜¯ç°æœ‰å˜é‡ï¼Œè€Œæ˜¯æ–°çš„å˜é‡ã€‚
    // å¦‚æœ `l` æ˜¯ä¸€ä¸ª `Cons`ï¼Œé‚£ä¹ˆ `Cons` ä¸­æºå¸¦çš„é¢å¤–æ•°æ®ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä½™éƒ¨åˆ†ï¼‰
    // ä¼šåˆ†åˆ«è¢«ç»‘å®šåˆ° `x` å’Œ `xs`
    Cons(x, xs) => {
      print(x)
      print(",")
      print_list(xs)
    }
  }
}

// é™¤äº†å˜é‡ï¼Œè¿˜å¯ä»¥å¯¹æ„é€ å™¨ä¸­æºå¸¦çš„æ•°æ®è¿›è¡Œè¿›ä¸€æ­¥çš„åŒ¹é…ã€‚
// ä¾‹å¦‚ï¼Œä¸‹é¢çš„å‡½æ•°åˆ¤æ–­ä¸€ä¸ªåˆ—è¡¨æ˜¯å¦åªæœ‰ä¸€ä¸ªå…ƒç´ 
fn is_singleton(l: List) -> Bool {
  match l {
    // è¿™ä¸ªåˆ†æ”¯åªä¼šåŒ¹é…å½¢å¦‚ `Cons(_, Nil)` çš„å€¼ï¼Œä¹Ÿå°±æ˜¯é•¿åº¦ä¸º 1 çš„åˆ—è¡¨
    Cons(_, Nil) => true
    // ç”¨ `_` æ¥åŒ¹é…å‰©ä¸‹çš„æ‰€æœ‰å¯èƒ½æ€§
    _ => false
  }
}
```

#### å¸¦æ ‡ç­¾çš„æ„é€ å™¨å‚æ•°

æšä¸¾æ„é€ å™¨å¯ä»¥æœ‰å¸¦æ ‡ç­¾çš„å‚æ•°ï¼š

```moonbit live
enum E {
  // `x` å’Œ `y` æ˜¯å¸¦æ ‡ç­¾çš„å‚æ•°
  C(~x : Int, ~y : Int)
}

// æ¨¡å¼åŒ¹é…æœ‰å¸¦æ ‡ç­¾å‚æ•°çš„æ„é€ å™¨
fn f(e : E) -> Unit {
  match e {
    // `æ ‡ç­¾=åŒ¹é…å‚æ•°çš„æ¨¡å¼`
    C(x=0, y=0) => println("0!")
    // `~x` æ˜¯ `x=x` çš„ç®€å†™
    // æœªè¢«åŒ¹é…çš„å¸¦æ ‡ç­¾å‚æ•°å¯ä»¥ç”¨ `..` æ¥å¿½ç•¥
    C(~x, ..) => println(x)
  }
}

// åˆ›å»ºæœ‰å¸¦æ ‡ç­¾å‚æ•°çš„æ„é€ å™¨
fn init {
  f(C(x=0, y=0)) // `æ ‡ç­¾=å‚æ•°çš„å€¼`
  let x = 0
  f(C(~x, y=1)) // `~x` æ˜¯ `x=x` çš„ç®€å†™
}
```

åœ¨æ¨¡å¼åŒ¹é…ä¸­ï¼Œè¿˜å¯ä»¥åƒè®¿é—®ç»“æ„ä½“çš„å­—æ®µä¸€æ ·ç›´è®¿é—®å–æ„é€ å™¨çš„å¸¦æ ‡ç­¾å‚æ•°ï¼š

```moonbit live
enum Object {
  Point(~x : Double, ~y : Double)
  Circle(~x : Double, ~y : Double, ~radius : Double)
}

fn distance_with(self : Object, other : Object) -> Double {
  match (self, other) {
    // å¦‚æœé€šè¿‡ `Point(..) as p` çš„æ–¹å¼å®šä¹‰ä¸€ä¸ªå˜é‡ `p`ï¼Œ
    // ç¼–è¯‘å™¨çŸ¥é“ `p` ä¸€å®šæ˜¯æ„é€ å™¨ `Point`ï¼Œ
    // æ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ `p.x`ã€`p.y` è®¿é—® `Point` çš„å¸¦æ ‡ç­¾å‚æ•°
    (Point(_) as p1, Point(_) as p2) => {
      let dx = p2.x - p1.x
      let dy = p2.y - p1.y
      (dx * dx + dy * dy).sqrt()
    }
    (Point(_), Circle(_)) | (Circle(_) | Point(_)) | (Circle(_), Circle(_)) => abort("not implemented")
  }
}

fn init {
  let p1 : Point = Point(x=0, y=0)
  let p2 : Point = Point(x=3, y=4)
  println(p1.distance_with(p2)) // 5.0
}
```

#### æ„é€ å™¨çš„å¯å˜å­—æ®µ

MoonBit æ”¯æŒç»™æ„é€ å™¨å£°æ˜å¯å˜çš„å­—æ®µã€‚è¿™å¯¹å®ç°å¯å˜æ•°æ®ç»“æ„éå¸¸æœ‰ç”¨ï¼š

```moonbit live
// ä¸€ä¸ªå¸¦çˆ¶èŠ‚ç‚¹æŒ‡é’ˆçš„å¯å˜äºŒå‰æœç´¢æ ‘çš„ç±»å‹
enum Tree[X] {
  Nil
  // only labelled arguments can be mutable
  Node(mut ~value : X, mut ~left : Tree[X], mut ~right : Tree[X], mut ~parent : Tree[X])
}

// ä¸€ä¸ªä½¿ç”¨å¯å˜çš„äºŒå‰æœç´¢æ ‘å®ç°çš„é›†åˆ
struct Set[X] {
  mut root : Tree[X]
}

fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {
  self.root = self.root.insert(x, parent=Nil)
}

// åƒä¸€æ£µå¯å˜çš„äºŒå‰æœç´¢æ ‘ä¸­æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ã€‚
// è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘æ–°çš„æ ¹èŠ‚ç‚¹
fn Tree::insert[X : Compare](self : Tree[X], x : X, ~parent : Tree[X]) -> Tree[X] {
  match self {
    Nil => Node(value=x, left=Nil, right=Nil, ~parent)
    Node(_) as node => {
      let order = x.compare(node.value)
      if order == 0 {
        // ä¿®æ”¹æ„é€ å™¨ä¸­çš„å­—æ®µ
        node.value = x
      } else if order < 0 {
        // è¿™é‡Œåœ¨ `node` å’Œ `node.left` ä¹‹é—´åˆ›å»ºäº†ä¸€ä¸ªç¯
        node.left = node.left.insert(x, parent=node)
      } else {
        node.right = node.right.insert(x, parent=node)
      }
      // è¿™æ£µäºŒå‰æ ‘æ˜¯éç©ºçš„ï¼Œæ‰€ä»¥æ ¹èŠ‚ç‚¹è¿˜æ˜¯åŸæ¥é‚£ä¸ª
      node
    }
  }
}
```

### æ–°ç±»å‹

MoonBit æ”¯æŒä¸€ç§ç‰¹æ®Šçš„æšä¸¾ç±»å‹ï¼Œç§°ä¸ºæ–°ç±»å‹ï¼ˆnewtypeï¼‰ï¼š

```moonbit
// `UserId` æ˜¯ä¸€ä¸ªå…¨æ–°çš„ç±»å‹ï¼Œè€Œä¸”ç”¨æˆ·å¯ä»¥ç»™ `UserId` å®šä¹‰æ–°çš„æ–¹æ³•ç­‰
// ä½†ä¸æ­¤åŒæ—¶ï¼Œ`UserId` çš„å†…éƒ¨è¡¨ç¤ºå’Œ `Int` æ˜¯å®Œå…¨ä¸€è‡´çš„
type UserId Int
type UserName String
```

æ–°ç±»å‹å’Œåªæœ‰ä¸€ä¸ªæ„é€ å™¨ï¼ˆä¸ç±»å‹åŒåï¼‰çš„æšä¸¾ç±»å‹éå¸¸ç›¸ä¼¼ã€‚
å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨æ„é€ å™¨æ¥åˆ›å»ºæ–°ç±»å‹çš„å€¼ã€ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥æå–æ–°ç±»å‹çš„å†…éƒ¨è¡¨ç¤ºï¼š

```moonbit
fn init {
  let id: UserId = UserId(1)
  let name: UserName = UserName("John Doe")
  let UserId(uid) = id        // `uid` çš„ç±»å‹æ˜¯ `Int`
  let UserName(uname) = name  // `uname` çš„ç±»å‹æ˜¯ `String`
  println(uid)
  println(uname)
}
```

é™¤äº†æ¨¡å¼åŒ¹é…ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `.0` æå–æ–°ç±»å‹çš„å†…éƒ¨è¡¨ç¤ºï¼š

```moonbit
fn init {
  let id: UserId = UserId(1)
  let uid: Int = id.0
  println(uid)
}
```

## æ¨¡å¼åŒ¹é…

æˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•å¯¹æšä¸¾è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼Œä½†æ¨¡å¼åŒ¹é…å¹¶ä¸ä»…é™äºæšä¸¾ã€‚
ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹å¸ƒå°”å€¼ã€æ•°å­—ã€å­—ç¬¦ã€å­—ç¬¦ä¸²ã€å…ƒç»„ã€æ•°ç»„å’Œç»“æ„ä½“å­—é¢é‡è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚
ç”±äºè¿™äº›ç±»å‹å’Œæšä¸¾ä¸åŒï¼Œå®ƒä»¬åªæœ‰ä¸€ç§æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ `let` ç»‘å®šæ¥å¯¹å®ƒä»¬è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ `match` ä¸­ç»‘å®šçš„å˜é‡çš„ä½œç”¨åŸŸä»…é™äºå¼•å…¥è¯¥å˜é‡çš„æƒ…å†µåˆ†æ”¯ï¼Œè€Œ `let`
ç»‘å®šä¼šå°†æ¯ä¸ªå˜é‡éƒ½å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ `_` ä½œä¸ºæˆ‘ä»¬ä¸å…³å¿ƒçš„å€¼çš„é€šé…ç¬¦ã€‚

```moonbit
let id = match u {
  { id: id, name: _, email: _ } => id
}
// ç­‰ä»·äº
let { id: id, name: _, email: _ } = u
```

æ¨¡å¼åŒ¹é…è¿˜æœ‰ä¸€äº›æœ‰ç”¨çš„æ„é€ ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `as` ä¸ºæŸä¸ªæ¨¡å¼æŒ‡å®šä¸€ä¸ªåç§°ï¼Œ
å¹¶ä¸”å¯ä»¥ä½¿ç”¨ `|` åŒæ—¶åŒ¹é…å¤šä¸ªæƒ…å†µã€‚

```moonbit
match expr {
  Lit(n) as a => ...
  Add(e1, e2) | Mul(e1, e2) => ...
  _ => ...
}
```

### é”®å€¼å¯¹æ¨¡å¼åŒ¹é…

MoonBit å…è®¸æ¨¡å¼åŒ¹é…å­—å…¸ç­‰å…·æœ‰é”®å€¼å¯¹ç»“æ„çš„æ•°æ®ç»“æ„ï¼š

```moonbit
match map {
  // åŒ¹é…é”® "b" å­˜åœ¨çš„æƒ…å†µ
  { "b": Some(_) } => ..
  // åŒ¹é… "b" ä¸å­˜åœ¨ä¸” "a" å­˜åœ¨çš„æƒ…å†µï¼Œ
  // åŒ¹é…æˆåŠŸæ—¶ï¼ŒæŠŠ "a" çš„å€¼ç»‘å®šåˆ° `x`
  { "b": None, "a": Some(x) } => ..
  // ç¼–è¯‘å™¨æŒ‡å‡ºä¸‹åˆ—æƒ…å†µæ²¡æœ‰è¢«åŒ¹é…åˆ°ï¼š{ "b": None, "a": None }
}
```

- å¦‚æœè¦ç”¨å­—å…¸æ¨¡å¼åŒ¹é…ç±»å‹ `T`ï¼Œå¿…é¡»ç»™ç±»å‹ `T` å®ç°æ–¹æ³• `op_get`ã€‚`op_get` çš„ç±»å‹å¿…é¡»æ˜¯ `(Self, K) -> Option[V]`ï¼Œå…¶ä¸­ `K` æ˜¯é”®çš„ç±»å‹ï¼Œ`V` æ˜¯å€¼çš„ç±»å‹
- ç›®å‰ï¼Œå­—å…¸æ¨¡å¼çš„é”®éƒ¨åˆ†å¿…é¡»æ˜¯ä¸€ä¸ªå¸¸é‡
- å­—å…¸æ¨¡å¼æ°¸è¿œæ˜¯å¼€æ”¾çš„ï¼šæœªè¢«åŒ¹é…åˆ°çš„é”®ä¼šè¢«å¿½ç•¥
- å­—å…¸æ¨¡å¼ä¼šè¢«ç¼–è¯‘æˆé«˜æ•ˆçš„ä»£ç ï¼šæ¯ä¸ªé”®è‡³å¤šè¢«æŸ¥è¯¢ä¸€æ¬¡

## é”™è¯¯å¤„ç†

å‡½æ•°çš„è¿”å›å€¼ç±»å‹ä¸­å¯ä»¥åŒ…å«é”™è¯¯ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºå‡½æ•°å¯èƒ½è¿”å›çš„é”™è¯¯ã€‚æ¯”å¦‚å¦‚ä¸‹å‡½æ•°å£°æ˜è¡¨ç¤ºå‡½æ•° `div` å¯èƒ½è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹çš„é”™è¯¯ï¼š

```moonbit
fn div(x: Int, y: Int) -> Int!String { 
  if y == 0 {
    raise "division by zero"
  }
  x / y
}
```

å…¶ä¸­ `raise` å…³é”®å­—ç”¨äºä¸­æ–­å‡½æ•°çš„æ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚å‡½æ•°çš„é”™è¯¯å¤„ç†æœ‰ä»¥ä¸‹ä¸‰ç§æ–¹å¼ï¼š

* ä½¿ç”¨ `!!` åç¼€æ¥åœ¨å‘ç”Ÿé”™è¯¯çš„æƒ…å†µä¸‹ç›´æ¥ panicï¼Œæ¯”å¦‚
```moonbit
fn div_unsafe(x: Int, y: Int) -> Int {
  div(x, y)!! // ç›´æ¥ panic
}
```

* ä½¿ç”¨ `!` åç¼€æ¥åœ¨å‘ç”Ÿé”™è¯¯çš„æƒ…å†µä¸‹å°†é”™è¯¯ç›´æ¥é‡æ–°æŠ›å‡ºï¼Œæ¯”å¦‚
```moonbit
fn div_reraise(x: Int, y: Int) -> Int!String {
  div(x, y)! // ç›´æ¥é‡æ–°æŠ›å‡ºé”™è¯¯
}
```

* ä½¿ç”¨ `try` å’Œ `catch` å¯¹é”™è¯¯è¿›è¡Œæ•è·å¹¶å¤„ç†ï¼Œæ¯”å¦‚
```moonbit
fn div_with_default(x: Int, y: Int, default: Int) -> Int {
  try {
    div(x, y)!
  } catch {
    s => { println(s); default }
  }
}
```
å…¶ä¸­ `try` ç”¨äºè°ƒç”¨å¯èƒ½ä¼šæŠ›å‡ºé”™è¯¯çš„å‡½æ•°ï¼Œ`catch` ç”¨äºå¯¹æ•è·çš„é”™è¯¯è¿›è¡Œæ¨¡å¼åŒ¹é…å¹¶å¤„ç†ï¼Œå¦‚æœæ²¡æœ‰æ•è·åˆ°é”™è¯¯åˆ™ä¸ä¼šæ‰§è¡Œ `catch` è¯­å¥å—ã€‚

åœ¨ MoonBit ä¸­ï¼Œé”™è¯¯ç±»å‹å’Œé”™è¯¯å¤„ç†å±äºäºŒç­‰å…¬æ°‘ï¼Œå› æ­¤é”™è¯¯ç±»å‹åªèƒ½å‡ºç°åœ¨å‡½æ•°çš„è¿”å›å€¼ä¸­ï¼Œè€Œä¸èƒ½ä½œä¸ºå˜é‡çš„ç±»å‹ã€‚ä½¿ç”¨åç¼€è¡¨è¾¾å¼ `!` æˆ– `!!` è¿›è¡Œçš„é”™è¯¯å¤„ç†ä¹Ÿåªèƒ½åœ¨å‡½æ•°è°ƒç”¨å¤„è¿›è¡Œï¼Œè€Œä¸èƒ½åœ¨å…¶ä»–è¡¨è¾¾å¼ä¸­ä½¿ç”¨ï¼Œåˆæ³•çš„ä½¿ç”¨å½¢å¼åŒ…æ‹¬ï¼š
```moonbit
f(x)!
x.f()!
(x |> f)!
(x + y)!
```

æ­¤å¤–ï¼Œå¦‚æœå‡½æ•°çš„è¿”å›å€¼ç±»å‹ä¸­åŒ…å«é”™è¯¯ç±»å‹ï¼Œé‚£ä¹ˆå¯¹è¯¥å‡½æ•°çš„è°ƒç”¨å¿…é¡»ä½¿ç”¨ `!` æˆ– `!!` è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

## æ³›å‹

æ‚¨å¯ä»¥åœ¨é¡¶å±‚çš„å‡½æ•°å’Œæ•°æ®ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹ã€‚ç±»å‹å‚æ•°å¯ä»¥ç”±æ–¹æ‹¬å·å¼•å…¥ã€‚
æˆ‘ä»¬å¯ä»¥é‡å†™å‰é¢æåˆ°çš„æ•°æ®ç±»å‹ `List`ï¼Œæ·»åŠ ç±»å‹å‚æ•° `T`ï¼Œä»¥è·å¾—ä¸€ä¸ªæ³›å‹ç‰ˆæœ¬çš„åˆ—è¡¨ã€‚
ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ³›å‹å‡½æ•° `map` å’Œ `reduce`ï¼Œç”¨äºå¯¹åˆ—è¡¨è¿›è¡Œæ“ä½œã€‚

```moonbit
enum List[T] {
  Nil
  Cons(T, List[T])
}

fn map[S, T](self: List[S], f: (S) -> T) -> List[T] {
  match self {
    Nil => Nil
    Cons(x, xs) => Cons(f(x), map(xs, f))
  }
}

fn reduce[S, T](self: List[S], op: (T, S) -> T, init: T) -> T {
  match self {
    Nil => init
    Cons(x, xs) => reduce(xs, op, op(init, x))
  }
}
```

## è®¿é—®æ§åˆ¶

é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰å‡½æ•°å®šä¹‰å’Œå˜é‡ç»‘å®šå¯¹å…¶ä»–åŒ…éƒ½æ˜¯ _ä¸å¯è§_ çš„ï¼›
æ²¡æœ‰ä¿®é¥°ç¬¦çš„ç±»å‹æ˜¯æŠ½è±¡æ•°æ®ç±»å‹ï¼Œå…¶åç§°è¢«å¯¼å‡ºï¼Œä½†å†…éƒ¨æ˜¯ä¸å¯è§çš„ã€‚
è¿™ç§è®¾è®¡é˜²æ­¢äº†æ„å¤–æš´éœ²å®ç°ç»†èŠ‚ã€‚
æ‚¨å¯ä»¥åœ¨ `type`/`fn`/`let` å‰ä½¿ç”¨ `pub` ä¿®é¥°ç¬¦ä½¿å…¶å®Œå…¨å¯è§ï¼Œæˆ–åœ¨ `type`
å‰ä½¿ç”¨ `priv` ä¿®é¥°ç¬¦ä½¿å…¶å¯¹å…¶ä»–åŒ…å®Œå…¨ä¸å¯è§ã€‚
æ‚¨è¿˜å¯ä»¥åœ¨å­—æ®µåå‰ä½¿ç”¨ `pub` æˆ– `priv` è·å¾—æ›´ç»†ç²’åº¦çš„è®¿é—®æ§åˆ¶ã€‚
ä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼š

- åœ¨æŠ½è±¡æˆ–ç§æœ‰ç»“æ„ä½“å†…ï¼Œæ‰€æœ‰å­—æ®µéƒ½ä¸èƒ½è¢«å®šä¹‰ä¸º `pub`ï¼Œå› ä¸ºè¿™æ ·æ²¡æœ‰æ„ä¹‰ã€‚
- æšä¸¾ç±»å‹çš„æ„é€ å™¨æ²¡æœ‰å•ç‹¬çš„å¯è§æ€§ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨å®ƒä»¬å‰é¢ä½¿ç”¨ `pub` æˆ– `priv`

```moonbit
struct R1 {       // é»˜è®¤ä¸ºæŠ½è±¡æ•°æ®ç±»å‹
  x: Int          // éšå¼çš„ç§æœ‰å­—æ®µ
  pub y: Int      // ERROR: åœ¨æŠ½è±¡ç±»å‹ä¸­æ‰¾åˆ°äº† `pub` å­—æ®µï¼
  priv z: Int     // WARNING: `priv` æ˜¯å¤šä½™çš„ï¼
}

pub struct R2 {       // æ˜¾å¼çš„å…¬å…±ç»“æ„
  x: Int              // éšå¼çš„å…¬å…±å­—æ®µ
  pub y: Int          // WARNING: `pub` æ˜¯å¤šä½™çš„ï¼
  priv z: Int         // æ˜¾å¼çš„ç§æœ‰å­—æ®µ
}

priv struct R3 {       // æ˜¾å¼çš„ç§æœ‰ç»“æ„
  x: Int               // éšå¼çš„ç§æœ‰å­—æ®µ
  pub y: Int           // ERROR: `pub` å­—æ®µå‡ºç°åœ¨äº†ç§æœ‰ç±»å‹ä¸­ï¼
  priv z: Int          // WARNING: `priv` æ˜¯å¤šä½™çš„ï¼
}

enum T1 {       // é»˜è®¤ä¸ºæŠ½è±¡æ•°æ®ç±»å‹
  A(Int)        // éšå¼çš„ç§æœ‰å˜ä½“
  pub B(Int)    // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)   // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}

pub enum T2 {       // æ˜¾å¼çš„å…¬å…±æšä¸¾
  A(Int)            // éšå¼çš„å…¬å…±å˜ä½“
  pub B(Int)        // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)       // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}

priv enum T3 {       // æ˜¾å¼çš„ç§æœ‰æšä¸¾
  A(Int)             // éšå¼çš„ç§æœ‰å˜ä½“
  pub B(Int)         // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)        // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}
```

MoonBit ä¸­å¦ä¸€ä¸ªæœ‰ç”¨çš„ç‰¹æ€§æ˜¯ `pub(readonly)` ç±»å‹ï¼Œå…¶å—åˆ°äº† OCaml [private types](https://v2.ocaml.org/manual/privatetypes.html)çš„å¯å‘ã€‚ç®€è€Œè¨€ä¹‹ï¼Œ`pub(readonly)` ç±»å‹çš„å€¼å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æˆ–ç‚¹è¯­æ³•ææ„ï¼Œä½†åœ¨å…¶ä»–åŒ…ä¸­ï¼Œä¸èƒ½è¢«æ„é€ æˆ–æ”¹å˜ã€‚æ³¨æ„åˆ°åœ¨ `pub(readonly)` ç±»å‹å®šä¹‰çš„åŒä¸€ä¸ªåŒ…ä¸­ï¼Œå®ƒæ²¡æœ‰ä»»ä½•é™åˆ¶ã€‚

```moonbit
// Package A
pub(readonly) struct RO {
  field: Int
}
fn init {
  let r = { field: 4 }       // OK
  let r = { ..r, field: 8 }  // OK
}

// Package B
fn print_RO(r : RO) -> Unit {
  print("{ field: ")
  print(r.field)  // OK
  print(" }")
}
fn init {
  let r : RO = { field: 4 }  // ERROR: æ— æ³•åˆ›å»ºå…¬å…±åªè¯»ç±»å‹ RO çš„å€¼ï¼
  let r = { ..r, field: 8 }  // ERROR: æ— æ³•ä¿®æ”¹ä¸€ä¸ªå…¬å…±åªè¯»å­—æ®µï¼
}
```

MoonBit ä¸­çš„è®¿é—®æ§åˆ¶éµå¾ªè¿™æ ·ä¸€ä¸ªåŸåˆ™ï¼š`pub` ç±»å‹ã€å‡½æ•°æˆ–å˜é‡ä¸èƒ½åŸºäºç§æœ‰ç±»å‹å®šä¹‰ã€‚
è¿™æ˜¯å› ä¸ºç§æœ‰ç±»å‹å¯èƒ½ä¸æ˜¯åœ¨ä½¿ç”¨ `pub` å®ä½“çš„æ‰€æœ‰åœ°æ–¹éƒ½å¯ä»¥è¢«è®¿é—®ã€‚
MoonBit å†…å»ºäº†ä¸€äº›æ£€æŸ¥ï¼Œä»¥é˜²æ­¢è¿åè¿™ä¸€åŸåˆ™çš„ç”¨ä¾‹ã€‚

```moonbit
pub struct s {
  x: T1  // OK
  y: T2  // OK
  z: T3  // ERROR: å…¬å…±å­—æ®µæ‹¥æœ‰ç§æœ‰ç±»å‹ `T3`ï¼
}

// ERROR: å…¬å…±å‡½æ•°æ‹¥æœ‰ç§æœ‰å½¢å‚ç±»å‹ `T3`ï¼
pub fn f1(_x: T3) -> T1 { T1::A(0) }
// ERROR: å…¬å…±å‡½æ•°æ‹¥æœ‰ç§æœ‰è¿”å›ç±»å‹ `T3`ï¼
pub fn f2(_x: T1) -> T3 { T3::A(0) }
// OK
pub fn f3(_x: T1) -> T1 { T1::A(0) }

pub let a: T3  // ERROR: å…¬å…±å˜é‡æ‹¥æœ‰ç§æœ‰ç±»å‹ `T3`ï¼
```

## æ–¹æ³•ç³»ç»Ÿ

MoonBit æ”¯æŒä¸ä¼ ç»Ÿé¢å‘å¯¹è±¡è¯­è¨€ä¸åŒçš„æ–¹æ³•ï¼ˆmethodï¼‰ã€‚
æŸä¸ªç±»å‹çš„æ–¹æ³•å°±æ˜¯ä¸è¯¥ç±»å‹å…³è”çš„æ™®é€šå‡½æ•°ã€‚
å¯ä»¥ä½¿ç”¨ `fn TypeName::method_name(...) -> ...` çš„è¯­æ³•æ¥ä¸ºç±»å‹ `TypeName` å£°æ˜æ–¹æ³•ï¼š

```moonbit
enum MyList[X] {
  Nil
  Cons(X, MyList[X])
}

fn MyList::map[X, Y](xs: MyList[X], f: (X) -> Y) -> MyList[Y] { ... }
fn MyList::concat[X](xs: MyList[MyList[X]]) -> MyList[X] { ... }
```

å¦‚æœä¸€ä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°åä¸º `self`ï¼Œé‚£ä¹ˆ MoonBit ä¼šè‡ªåŠ¨å°†è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸º `self` çš„ç±»å‹ä¸Šçš„æ–¹æ³•ï¼š

```moonbit
fn map[X, Y](self: MyList[X], f: (X) -> Y) -> List[Y] { ... }
// ç­‰ä»·äº
fn MyList::map[X, Y](xs: MyList[X], f: (X) -> Y) -> List[Y] { ... }
```

æ–¹æ³•å°±æ˜¯æŸä¸ªç±»å‹æ‰€æ‹¥æœ‰çš„æ™®é€šå‡½æ•°ã€‚æ‰€ä»¥ï¼Œåœ¨æ²¡æœ‰æ­§ä¹‰æ—¶ï¼Œå®ƒä»¬ä¹Ÿå¯ä»¥åƒæ™®é€šå‡½æ•°ä¸€æ ·è°ƒç”¨ï¼š

```moonbit
fn init {
  let xs: MyList[MyList[_]] = ...
  let ys = concat(xs)
}
```

ä½†å’Œæ™®é€šå‡½æ•°ä¸åŒï¼Œæ–¹æ³•æ”¯æŒé‡è½½ã€‚ä¸åŒçš„ç±»å‹å¯ä»¥æœ‰åŒåçš„æ–¹æ³•ã€‚
å¦‚æœå½“å‰ä½œç”¨åŸŸå†…æœ‰å¤šä¸ªåŒåæ–¹æ³•ï¼Œä¾ç„¶å¯ä»¥é€šè¿‡åŠ ä¸Š `TypeName::` çš„å‰ç¼€æ¥æ˜¾å¼åœ°è°ƒç”¨ä¸€ä¸ªæ–¹æ³•ï¼š

```moonbit live
struct T1 { x1: Int }
fn T1::default() -> { { x1: 0 } }

struct T2 { x2: Int }
fn T2::default() -> { { x2: 0 } }

fn init {
  // default() æœ‰æ­§ä¹‰ï¼
  let t1 = T1::default() // å¯è¡Œ
  let t2 = T2::default() // å¯è¡Œ
}
```

## è¿ç®—ç¬¦é‡è½½

MoonBit æ”¯æŒé€šè¿‡æ–¹æ³•é‡è½½å†…ç½®è¿ç®—ç¬¦ã€‚ä¸è¿ç®—ç¬¦ `<op>` ç›¸å¯¹åº”çš„æ–¹æ³•åæ˜¯ `op_<op>`ã€‚ä¾‹å¦‚ï¼š

```moonbit live
struct T {
  x:Int
} derive(Debug)

fn op_add(self: T, other: T) -> T {
  { x: self.x + other.x }
}

fn init {
  let a = { x:0, }
  let b = { x:2, }
  debug(a + b)
}
```

å¦ä¸€ä¸ªä¾‹å­ï¼ˆå…³äº`op_get`å’Œ`op_set`ï¼‰:

```moonbit live
struct Coord {
  mut x: Int
  mut y: Int
} derive(Debug)

fn op_get(self: Coord, key: String) -> Int {
  match key {
    "x" => self.x
    "y" => self.y
  }
}

fn op_set(self: Coord, key: String, val: Int) -> Unit {
    match key {
    "x" => self.x = val
    "y" => self.y = val
  }
}

fn init {
  let c = { x: 1, y: 2 }
  debug(c)
  debug(c["y"])
  c["x"] = 23
  debug(c)
  debug(c["x"])
}
```

ç›®å‰ï¼Œä»¥ä¸‹è¿ç®—ç¬¦å¯ä»¥è¢«é‡è½½ï¼š

| è¿ç®—ç¬¦åç§°            | æ–¹æ³•å       |
| --------------------- | ------------ |
| `+`                   | `op_add`     |
| `-`                   | `op_sub`     |
| `*`                   | `op_mul`     |
| `/`                   | `op_div`     |
| `%`                   | `op_mod`     |
| `=`                   | `op_eual`    |
| `-`ï¼ˆä¸€å…ƒè¿ç®—ç¬¦ï¼‰       | `op_neg`     |
| `_[_]`ï¼ˆè·å–é¡¹ï¼‰       | `op_get`     |
| `_[_] = _`ï¼ˆè®¾ç½®é¡¹ï¼‰   | `op_set`     |
| `_[_.._]`ï¼ˆè§†å›¾ï¼‰      | `op_as_view` | 

## ç®¡é“è¿ç®—ç¬¦

MoonBit æä¾›äº†ä¾¿åˆ©çš„ç®¡é“è¿ç®—ç¬¦ `|>`ï¼Œå¯ä»¥ç”¨äºé“¾å¼è°ƒç”¨æ™®é€šå‡½æ•°ï¼š

```moonbit
fn init {
  x |> f     // ç­‰ä»·äº f(x)
  x |> f(y)  // ç­‰ä»·äº f(x, y)

  // åˆ†å¸ƒåœ¨å¤šè¡Œçš„é“¾å¼è°ƒç”¨
  arg_val
  |> f1 // ç­‰ä»·äº f1(arg_val)
  |> f2(other_args) // ç­‰ä»·äº f2(f1(arg_val), other_args)
}
```

## è§†å›¾

ç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„â€œåˆ‡ç‰‡â€ï¼Œè§†å›¾èƒ½å¤Ÿå¼•ç”¨æ•°ç»„ç­‰æ•°æ®ç±»å‹ä¸­çš„ç‰‡æ®µã€‚å¯ä»¥ä½¿ç”¨`data[start..end]`çš„æ–¹å¼åˆ›å»ºä¸€ä¸ªå…³äºæ•°ç»„`data`çš„è§†å›¾ï¼Œè¿™ä¸ªè§†å›¾å¼•ç”¨äº†ä»ä¸‹æ ‡`start`å¼€å§‹åˆ°`end`ï¼ˆä¸åŒ…å«`end`ï¼‰çš„å…ƒç´ ã€‚`start`å’Œ`end`ä¹Ÿå¯ä»¥çœç•¥:

```moonbit
fn init {
  let xs = [0,1,2,3,4,5]
  let s1 : ArrayView[Int] = xs[2..]
  print_array_view(s1)            //output: 2345
  xs[..4]  |> print_array_view()  //output: 0123
  xs[2..5] |> print_array_view()  //output: 234
  xs[..]   |> print_array_view()  //output: 012345

  // åˆ›å»ºä¸€ä¸ªè§†å›¾çš„è§†å›¾
  xs[2..5][1..] |> print_array_view() //output: 34
}

fn print_array_view[T : Show](view : ArrayView[T]) -> Unit {
  for i=0; i<view.length(); i = i + 1 {
    print(view[i])
  }
  print("\n")
}
```

è¦ä¸ºè‡ªå®šä¹‰æ•°æ®ç±»å‹æ·»åŠ è§†å›¾æ”¯æŒï¼Œéœ€è¦ä¸ºå®ƒå®ç°`length`å’Œ`op_as_view`æ–¹æ³•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```moonbit
struct MyList[A] {
  elems : Array[A]
} 

struct MyListView[A] {
  ls : MyList[A]
  start : Int
  end : Int
}

pub fn length[A](self : MyList[A]) -> Int {
  self.elems.length()
}

pub fn op_as_view[A](self : MyList[A], ~start : Int, ~end : Int) -> MyListView[A] {
  println("op_as_view: [\(start),\(end))")
  if start < 0 || end > self.length() { abort("index out of bounds") }
  { ls: self, start, end }
}

fn init {
  let ls = { elems: [1,2,3,4,5] }
  ls[..] |> ignore()
  ls[1..] |> ignore()
  ls[..2] |> ignore()
  ls[1..2] |> ignore()
}
```

è¾“å‡ºï¼š

```
op_as_view: [0,5)
op_as_view: [1,5)
op_as_view: [0,2)
op_as_view: [1,2)
```

## æ¥å£ç³»ç»Ÿ

MoonBit å…·æœ‰ç”¨äºé‡è½½/ç‰¹è®¾å¤šæ€ï¼ˆad-hoc polymorphismï¼‰çš„ç»“æ„æ¥å£ç³»ç»Ÿã€‚
æ¥å£æè¿°äº†æ»¡è¶³è¯¥æ¥å£çš„ç±»å‹éœ€è¦æ”¯æŒå“ªäº›æ“ä½œã€‚æ¥å£çš„å£°æ˜æ–¹å¼å¦‚ä¸‹ï¼š

```moonbit
trait I {
  f(Self, ...) -> ...
}
```

åœ¨æ¥å£å£°æ˜ä¸­ï¼Œ`Self` æŒ‡ä»£å®ç°æ¥å£çš„é‚£ä¸ªç±»å‹ã€‚

ä¸€ä¸ªç±»å‹è¦å®ç°æŸä¸ªæ¥å£ï¼Œå°±è¦æ»¡è¶³è¯¥æ¥å£ä¸­æ‰€æœ‰çš„æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„æ¥å£æè¿°äº†ä¸€ä¸ªèƒ½å¤Ÿæ¯”è¾ƒå…ƒç´ æ˜¯å¦ç›¸ç­‰çš„ç±»å‹éœ€è¦æ»¡è¶³çš„æ–¹æ³•ï¼š

```moonbit
trait Eq {
  op_equal(Self, Self) -> Bool
}
```

æ¥å£æ— éœ€æ˜¾å¼å®ç°ï¼Œå…·æœ‰æ‰€éœ€æ–¹æ³•çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°æ¥å£ã€‚è€ƒè™‘ä»¥ä¸‹æ¥å£ï¼š

```moonbit
trait Show {
  to_string(Self) -> String
}
```

å†…ç½®ç±»å‹å¦‚ `Int` å’Œ `Double` ä¼šè‡ªåŠ¨å®ç°è¿™ä¸ªæ¥å£ã€‚

åœ¨å£°æ˜æ³›å‹å‡½æ•°æ—¶ï¼Œç±»å‹å‚æ•°å¯ä»¥ç”¨å®ƒä»¬åº”è¯¥å®ç°çš„æ¥å£ä½œä¸ºæ³¨è§£ã€‚
å¦‚æ­¤ä¾¿èƒ½å®šä¹‰åªå¯¹æŸäº›ç±»å‹å¯ç”¨çš„æ³›å‹å‡½æ•°ã€‚ä¾‹å¦‚ï¼š

```moonbit
trait Number {
  op_add(Self, Self) -> Self
  op_mul(Self, Self) -> Self
}

fn square[N: Number](x: N) -> N {
  x * x
}
```

å¦‚æœæ²¡æœ‰ `Number` çš„è¦æ±‚ï¼Œ`square` ä¸­çš„è¡¨è¾¾å¼ `x * x` ä¼šå¯¼è‡´å‡ºç°æ‰¾ä¸åˆ°æ–¹æ³•/è¿ç®—ç¬¦çš„é”™è¯¯ã€‚
ç°åœ¨ï¼Œå‡½æ•° `square` å¯ä»¥ä¸ä»»ä½•å®ç°äº† `Number` æ¥å£çš„ç±»å‹ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

```moonbit live
fn init {
  debug(square(2)) // 4
  debug(square(1.5)) // 2.25
  debug(square({ x: 2, y: 3 })) // (4, 9)
}

struct Point {
  x: Int
  y: Int
} derive(Debug)

fn op_add(self: Point, other: Point) -> Point {
  { x: self.x + other.x, y: self.y + other.y }
}

fn op_mul(self: Point, other: Point) -> Point {
  { x: self.x * other.x, y: self.y * other.y }
}
```

æ¥å£ä¸­çš„æ–¹æ³•å¯ä»¥ç”¨ `Trait::method` çš„è¯­æ³•æ¥ç›´æ¥è°ƒç”¨ã€‚MoonBit ä¼šæ¨å¯¼ `Self` çš„å…·ä½“ç±»å‹ï¼Œ
å¹¶æ£€æŸ¥ `Self` æ˜¯å¦å®ç°äº† `Trait`ï¼š

```moonbit live
fn init {
  println(Show::to_string(42))
  debug(Compare::compare(1.0, 2.5))
}
```

Moonbit æä¾›äº†ä»¥ä¸‹å®ç”¨çš„å†…å»ºæ¥å£ï¼š

```moonbit
trait Eq {
  op_equal(Self, Self) -> Bool
}

trait Compare {
  // `0` ä»£è¡¨ç›¸ç­‰, `-1` ä»£è¡¨å°äº, `1` ä»£è¡¨å¤§äº
  op_equal(Self, Self) -> Int
}

trait Hash {
  hash(Self) -> Int
}

trait Show {
  to_string(Self) -> String
}

trait Default {
  default() -> Self
}

trait Debug {
  // å°† [self] çš„è°ƒè¯•ä¿¡æ¯å†™å…¥åˆ°ä¸€ä¸ª buffer é‡Œ
  debug_write(Self, Buffer) -> Unit
}
```

## æ–¹æ³•çš„è®¿é—®æƒé™æ§åˆ¶ä¸æ‹“å±•æ–¹æ³•

ä¸ºäº†ä½¿ MoonBit çš„æ¥å£ç³»ç»Ÿå…·æœ‰ä¸€è‡´æ€§ï¼ˆcoherenceï¼Œå³ä»»ä½• `Type: Trait` çš„ç»„åˆéƒ½æœ‰å…¨å±€å”¯ä¸€çš„å®ç°ï¼‰ï¼Œ
é˜²æ­¢ç¬¬ä¸‰æ–¹åŒ…æ„å¤–åœ°ä¿®æ”¹ç°æœ‰ç¨‹åºçš„è¡Œä¸ºï¼Œ**åªæœ‰ç±»å‹æ‰€åœ¨çš„åŒ…èƒ½ä¸ºå®ƒå®šä¹‰æ–¹æ³•**ã€‚
æ‰€ä»¥ç”¨æˆ·æ— æ³•ä¸ºå†…å»ºç±»å‹æˆ–æ¥è‡ªç¬¬ä¸‰æ–¹åŒ…çš„ç±»å‹å®šä¹‰æ–¹æ³•ã€‚

ç„¶è€Œï¼Œæˆ‘ä»¬æœ‰æ—¶ä¹Ÿä¼šéœ€è¦æ‹“å±•ä¸€ä¸ªç°æœ‰ç±»å‹çš„åŠŸèƒ½ï¼Œå› æ­¤ï¼ŒMoonBit æä¾›äº†ä¸€ç§åä¸ºæ‹“å±•æ–¹æ³•çš„æœºåˆ¶ã€‚
æ‹“å±•æ–¹æ³•å¯ä»¥é€šè¿‡ `fn Trait::method_name(...) -> ...` çš„å½¢å¼å£°æ˜ï¼Œ
å®ƒä»¬é€šè¿‡å®ç°æ¥å£æ¥æ‹“å±•ç°æœ‰ç±»å‹çš„åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œå‡è®¾è¦ä¸ºå†…å»ºç±»å‹å®ç°ä¸€ä¸ªæ–°çš„æ¥å£
`ToMyBinaryProtocol`ï¼Œå°±å¯ä»¥ï¼ˆä¸”å¿…é¡»ï¼‰ä½¿ç”¨æ‹“å±•æ–¹æ³•ï¼š

```moonbit
trait ToMyBinaryProtocol {
  to_my_binary_protocol(Self, Buffer) -> Unit
}

fn ToMyBinaryProtocol::to_my_binary_protocol(x: Int, b: Buffer) -> Unit { ... }
fn ToMyBinaryProtocol::to_my_binary_protocol(x: Double, b: Buffer) -> Unit { ... }
fn ToMyBinaryProtocol::to_my_binary_protocol(x: String, b: Buffer) -> Unit { ... }
```

åœ¨æœç´¢æŸä¸ªæ¥å£çš„å®ç°æ—¶ï¼Œæ‹“å±•æ–¹æ³•æ¯”æ™®é€šæ–¹æ³•æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œ
å› æ­¤æ‹“å±•æ–¹æ³•è¿˜å¯ä»¥ç”¨æ¥è¦†ç›–æ‰è¡Œä¸ºä¸èƒ½æ»¡è¶³è¦æ±‚çš„ç°æœ‰æ–¹æ³•ã€‚
æ‹“å±•æ–¹æ³•åªèƒ½è¢«ç”¨äºå®ç°æŒ‡å®šçš„æ¥å£ï¼Œä¸èƒ½åƒæ™®é€šçš„æ–¹æ³•ä¸€æ ·è¢«ç›´æ¥è°ƒç”¨ã€‚
æ­¤å¤–ï¼Œ**åªæœ‰ç±»å‹æˆ–æ¥å£æ‰€åœ¨çš„åŒ…å¯ä»¥å®šä¹‰æ‹“å±•æ–¹æ³•**ã€‚
ä¾‹å¦‚ï¼Œåªæœ‰ `@pkg1` å’Œ `@pkg2` èƒ½ä¸ºç±»å‹ `@pkg2.Type` å®šä¹‰æ‹“å±•æ–¹æ³• `@pkg1.Trait::f`ã€‚
è¿™ä¸€é™åˆ¶ä½¿å¾— MoonBit çš„æ¥å£ç³»ç»Ÿåœ¨åŠ å…¥æ‹“å±•æ–¹æ³•è¿™ä¸€çµæ´»çš„æœºåˆ¶åï¼Œä»èƒ½ä¿æŒä¸€è‡´ã€‚

å¦‚æœéœ€è¦ç›´æ¥è°ƒç”¨ä¸€ä¸ªæ‹“å±•æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨ `Trait::method` è¯­æ³•ã€‚ä¾‹å¦‚ï¼š

```moonbit live
trait MyTrait {
  f(Self) -> Unit
}

fn MyTrait::f(self: Int) -> Unit {
  println("Got Int \(self)!")
}

fn init {
  MyTrait::f(42)
}
```

## è‡ªåŠ¨å®ç°å†…å»ºæ¥å£

Moonbit å¯ä»¥è‡ªåŠ¨ç”Ÿæˆä¸€äº›å†…å»ºæ¥å£çš„å®ç°:

```moonbit live
struct T {
  x: Int
  y: Int
} derive(Eq, Compare, Debug, Default)

fn init {
  let t1 = T::default()
  let t2 = { x: 1, y: 1 }
  debug(t1) // {x: 0, y: 0}
  debug(t2) // {x: 1, y: 1}
  debug(t1 == t2) // false
  debug(t1 < t2) // true
}
```

## æ¥å£å¯¹è±¡

MoonBit é€šè¿‡æ¥å£å¯¹è±¡çš„å½¢å¼æ¥æ”¯æŒè¿è¡Œæ—¶å¤šæ€ã€‚
å‡è®¾ `t` çš„ç±»å‹ä¸º `T`ï¼Œä¸”ç±»å‹ `T` å®ç°äº†æ¥å£ `I`,
é‚£ä¹ˆå¯ä»¥æŠŠ `T` å®ç° `I` çš„å„ä¸ªæ–¹æ³•å’Œ `t` è‡ªå·±æ‰“åŒ…åœ¨ä¸€èµ·ï¼Œ
åˆ›å»ºä¸€ä¸ª `I` çš„æ¥å£å¯¹è±¡ `t as I`ã€‚
æ¥å£å¯¹è±¡æ“¦é™¤äº†å€¼çš„å…·ä½“ç±»å‹ï¼Œæ‰€ä»¥ä»ä¸åŒçš„å…·ä½“ç±»å‹æ‰€åˆ›å»ºçš„æ¥å£å¯¹è±¡ï¼Œ
å¯ä»¥è¢«å°è£…åœ¨åŒä¸€ä¸ªæ•°æ®ç»“æ„é‡Œï¼Œç»Ÿä¸€è¿›è¡Œå¤„ç†ï¼š

```moonbit live
trait Animal {
  speak(Self)
}

type Duck String
fn Duck::make(name: String) -> Duck { Duck(name) }
fn speak(self: Duck) -> Unit {
  println(self.0 + ": quak!")
}

type Fox String
fn Fox::make(name: String) -> Fox { Fox(name) }
fn Fox::speak(_self: Fox) -> Unit {
  println("What does the fox say?")
}

fn init {
  let duck1 = Duck::make("duck1")
  let duck2 = Duck::make("duck2")
  let fox1 = Fox::make("fox1")
  let animals = [ duck1 as Animal, duck2 as Animal, fox1 as Animal ]
  let mut i = 0
  while i < animals.length() {
    animals[i].speak()
    i = i + 1
  }
}
```

ä¸æ˜¯æ‰€æœ‰æ¥å£éƒ½å¯ä»¥ç”¨äºåˆ›å»ºå¯¹è±¡ã€‚
â€œå¯¹è±¡å®‰å…¨â€ çš„æ¥å£çš„æ–¹æ³•å¿…é¡»æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š

- æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯ `Self`
- åœ¨æ–¹æ³•çš„ç­¾åé‡Œï¼Œ`Self` åªèƒ½å‡ºç°åœ¨ç¬¬ä¸€ä¸ªå‚æ•°

## é—®å·æ“ä½œç¬¦

MoonBit æä¾›ä¸€ä¸ªä¾¿æ·çš„ `?` æ“ä½œç¬¦ï¼Œç”¨äºé”™è¯¯å¤„ç†ã€‚
`?` æ˜¯ä¸€ä¸ªåç¼€è¿ç®—ç¬¦ã€‚å®ƒå¯ä»¥ä½œç”¨äºç±»å‹ä¸º `Option` æˆ– `Result` çš„è¡¨è¾¾å¼ã€‚
è¢«åº”ç”¨åœ¨è¡¨è¾¾å¼ `t : Option[T]` ä¸Šæ—¶ï¼Œ`t?` ç­‰ä»·äºï¼š

```moonbit
match t {
  None => { return None }
  Some(x) => x
}
```

è¢«åº”ç”¨åœ¨è¡¨è¾¾å¼ `t : Result[T, E]` ä¸Šæ—¶ï¼Œ`t?` ç­‰ä»·äºï¼š

```moonbit
match t {
  Err(err) => { return Err(err) }
  Ok(x) => x
}
```

é—®å·æ“ä½œç¬¦å¯ä»¥ç”¨äºä¼˜é›…åœ°ç»„åˆå¤šæ®µå¯èƒ½å¤±è´¥æˆ–äº§ç”Ÿé”™è¯¯çš„ç¨‹åºï¼š

```moonbit
fn may_fail() -> Option[Int] { ... }

fn f() -> Option[Int] {
  let x = may_fail()?
  let y = may_fail()?.lsr(1) + 1
  if y == 0 { return None }
  Some(x / y)
}

fn may_error() -> Result[Int, String] { ... }

fn g() -> Result[Int, String] {
  let x = may_error()?
  let y = may_error()? * 2
  if y == 0 { return Err("divide by zero") }
  Ok(x / y)
}
```

## æµ‹è¯•å—

MoonBit æä¾›äº† `test` ä»£ç å—ï¼Œç”¨äºç¼–å†™æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯”å¦‚
```moonbit
test "test_name" {
  @test.eq(1 + 1, 2)!
  @test.eq(2 + 2, 4)!
}
```
`test` ä»£ç å—å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¿”å› `Unit` ï¼Œä½†æ˜¯å¯èƒ½æŠ›å‡º `String` ç±»å‹é”™è¯¯çš„å‡½æ•°ï¼ˆå‡½æ•°ç­¾åä¸­è®°ä¸º `Unit!String` ï¼‰ã€‚å®ƒä¼šåœ¨æ‰§è¡Œ `moon test` çš„è¿‡ç¨‹ä¸­è¢«è°ƒç”¨ï¼Œå¹¶é€šè¿‡æ„å»ºç³»ç»Ÿè¾“å‡ºæµ‹è¯•æŠ¥å‘Šã€‚å…¶ä¸­ `@test.eq` æ˜¯ä¸€ä¸ªæ ‡å‡†åº“ä¸­çš„å‡½æ•°ï¼Œå¦‚æœæ–­è¨€å¤±è´¥ï¼Œä¼šæ‰“å°é”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢æµ‹è¯•ã€‚å­—ç¬¦ä¸² `"test_name"` ç”¨äºæ ‡è¯†æµ‹è¯•ç”¨ä¾‹ï¼Œæ˜¯å¯é€‰é¡¹ï¼Œå½“å…¶ä»¥ `"panic"` å¼€å¤´æ—¶ï¼Œè¡¨ç¤ºè¯¥æµ‹è¯•çš„æœŸæœ›è¡Œä¸ºæ˜¯è§¦å‘ panicï¼Œåªæœ‰åœ¨ panic è¢«è§¦å‘çš„æƒ…å†µä¸‹æ‰èƒ½é€šè¿‡æµ‹è¯•ï¼Œæ¯”å¦‚ï¼š

```moonbit
test "panic_test" {
  let _ : Int = Option::None.unwrap()
}
```

## æ–‡æ¡£æ³¨é‡Š

æ–‡æ¡£æ³¨é‡Šæ˜¯ä»¥ `///` å¼€å¤´çš„æ³¨é‡Šï¼Œå‡ºç°åœ¨é¡¶å±‚ç»“æ„ï¼ˆå¦‚ `fn`ã€`let`ã€`enum`ã€`struct`ã€`type`ï¼‰çš„æ¯ä¸€è¡Œå‰é¢ã€‚æ–‡æ¡£æ³¨é‡Šå†…åŒ…å« Markdown æ–‡æœ¬å’Œä»»æ„ä¸ªæ³¨è§£ã€‚

```moonbit
/// Return a new array with reversed elements.
/// 
/// # Example
/// 
/// ```
/// reverse([1,2,3,4]) |> println()
/// ```
fn reverse[T](xs : Array[T]) -> Array[T] {
  ...
}
```

### æ³¨è§£

æ³¨è§£æ˜¯æ–‡æ¡£æ³¨é‡Šä¸­ `@word ...` å½¢å¼çš„ç‰¹æ®Šæ³¨é‡Šã€‚*word* è¡¨ç¤ºæ³¨è§£çš„ç±»å‹ï¼Œåé¢å¯ä»¥è·Ÿéšå¤šä¸ª *word* æˆ–å­—ç¬¦ä¸²å­—é¢é‡ï¼Œæ¯æ¡æ³¨è§£ç‹¬å ä¸€è¡Œã€‚åœ¨MoonBitä¸­æ³¨è§£é€šå¸¸ä¸ä¼šå½±å“ç¨‹åºçš„å«ä¹‰ã€‚æ— æ³•è¯†åˆ«çš„æ³¨è§£å°†ä¼šè§¦å‘è­¦å‘Šã€‚

- `@alert`æ³¨è§£

  å½“å¼•ç”¨äº†è¢«æ ‡è®°äº†`@alert`çš„å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè§¦å‘ç›¸åº”çš„è­¦å‘Šæˆ–è€…é”™è¯¯ã€‚è¿™ç§æœºåˆ¶æä¾›äº†ä¸€ç§é€šç”¨çš„æ–¹å¼ï¼Œå°†å‡½æ•°æ ‡è®°ä¸º `deprecated` æˆ– `unsafe`ã€‚

  å®ƒçš„å½¢å¼ä¸º `@alert category "alert message..."`ã€‚

  `category`è¡¨ç¤º`@alert`çš„ç±»åˆ«ï¼Œå®ƒå¯ä»¥æ˜¯ä»»æ„æ ‡è¯†ç¬¦ã€‚å¯ä»¥é€šè¿‡é…ç½®æ¥å†³å®šå“ªäº›`alert`æ˜¯å¯ç”¨çš„æˆ–è€…æŠ¥å‘Šä¸ºé”™è¯¯ã€‚

  ```moonbit
  /// ...
  /// @alert deprecated "Use foo2 instead"
  pub fn foo() -> Unit { ... }

  /// ...
  /// @alert unsafe "Div will cause an error when y is zero"
  pub fn div(x: Int, y: Int) -> Int { ... } 

  fn main {
    foo() // warning: Use foo2 instead
    div(x, y) |> ignore // warning: Div will cause an error when y is zero
  }
  ```

## MoonBit çš„æ„å»ºç³»ç»Ÿ

æ„å»ºç³»ç»Ÿçš„ä»‹ç»å‚è§ [MoonBit çš„æ„å»ºç³»ç»Ÿæ•™ç¨‹](./build-system-tutorial.md)ã€‚
