// Generated by `wit-bindgen` 0.48.1. DO NOT EDIT!

///|
/// This type corresponds to HTTP standard Methods.
pub(all) enum Method {
  Get
  Head
  Post
  Put
  Delete
  Connect
  Options
  Trace
  Patch
  Other(String)
} derive(Show, Eq)

///|
/// This type corresponds to HTTP standard Related Schemes.
pub(all) enum Scheme {
  Http
  Https
  Other(String)
} derive(Show, Eq)

///|
/// Defines the case payload type for `DNS-error` above:
pub(all) struct DnsErrorPayload {
  rcode : String?
  info_code : UInt?
} derive(Show, Eq)

///|
/// Defines the case payload type for `TLS-alert-received` above:
pub(all) struct TlsAlertReceivedPayload {
  alert_id : Byte?
  alert_message : String?
} derive(Show, Eq)

///|
/// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
pub(all) struct FieldSizePayload {
  field_name : String?
  field_size : UInt?
} derive(Show, Eq)

///|
/// These cases are inspired by the IANA HTTP Proxy Error Types:
///   https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
pub(all) suberror ErrorCode {
  DnsTimeout
  DnsError(DnsErrorPayload)
  DestinationNotFound
  DestinationUnavailable
  DestinationIpProhibited
  DestinationIpUnroutable
  ConnectionRefused
  ConnectionTerminated
  ConnectionTimeout
  ConnectionReadTimeout
  ConnectionWriteTimeout
  ConnectionLimitReached
  TlsProtocolError
  TlsCertificateError
  TlsAlertReceived(TlsAlertReceivedPayload)
  HttpRequestDenied
  HttpRequestLengthRequired
  HttpRequestBodySize(UInt64?)
  HttpRequestMethodInvalid
  HttpRequestUriInvalid
  HttpRequestUriTooLong
  HttpRequestHeaderSectionSize(UInt?)
  HttpRequestHeaderSize(FieldSizePayload?)
  HttpRequestTrailerSectionSize(UInt?)
  HttpRequestTrailerSize(FieldSizePayload)
  HttpResponseIncomplete
  HttpResponseHeaderSectionSize(UInt?)
  HttpResponseHeaderSize(FieldSizePayload)
  HttpResponseBodySize(UInt64?)
  HttpResponseTrailerSectionSize(UInt?)
  HttpResponseTrailerSize(FieldSizePayload)
  HttpResponseTransferCoding(String?)
  HttpResponseContentCoding(String?)
  HttpResponseTimeout
  HttpUpgradeFailed
  HttpProtocolError
  LoopDetected
  ConfigurationError
  InternalError(String?)
} derive(Show, Eq)

///|
/// This type enumerates the different kinds of errors that may occur when
/// setting or appending to a `fields` resource.
pub(all) suberror HeaderError {
  InvalidSyntax
  Forbidden
  Immutable
} derive(Show, Eq)

///|
/// This following block defines the `fields` resource which corresponds to
/// HTTP standard Fields. Fields are a common representation used for both
/// Headers and Trailers.
///
/// A `fields` may be mutable or immutable. A `fields` created using the
/// constructor, `from-list`, or `clone` will be mutable, but a `fields`
/// resource given by other means (including, but not limited to,
/// `incoming-request.headers`, `outgoing-request.headers`) might be be
/// immutable. In an immutable fields, the `set`, `append`, and `delete`
/// operations will fail with `header-error.immutable`.
pub(all) struct Fields(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn Fields::drop(self : Fields) -> Unit {
  let Fields(resource) = self
  wasmImportResourceDropFields(resource)
}

///|
/// Represents an incoming HTTP Request.
pub(all) struct IncomingRequest(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn IncomingRequest::drop(self : IncomingRequest) -> Unit {
  let IncomingRequest(resource) = self
  wasmImportResourceDropIncomingRequest(resource)
}

///|
/// Represents an outgoing HTTP Request.
pub(all) struct OutgoingRequest(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn OutgoingRequest::drop(self : OutgoingRequest) -> Unit {
  let OutgoingRequest(resource) = self
  wasmImportResourceDropOutgoingRequest(resource)
}

///|
/// Parameters for making an HTTP Request. Each of these parameters is
/// currently an optional timeout applicable to the transport layer of the
/// HTTP protocol.
///
/// These timeouts are separate from any the user may use to bound a
/// blocking call to `wasi:io/poll.poll`.
pub(all) struct RequestOptions(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn RequestOptions::drop(self : RequestOptions) -> Unit {
  let RequestOptions(resource) = self
  wasmImportResourceDropRequestOptions(resource)
}

///|
/// Represents the ability to send an HTTP Response.
///
/// This resource is used by the `wasi:http/incoming-handler` interface to
/// allow a Response to be sent corresponding to the Request provided as the
/// other argument to `incoming-handler.handle`.
pub(all) struct ResponseOutparam(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn ResponseOutparam::drop(self : ResponseOutparam) -> Unit {
  let ResponseOutparam(resource) = self
  wasmImportResourceDropResponseOutparam(resource)
}

///|
/// Represents an incoming HTTP Response.
pub(all) struct IncomingResponse(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn IncomingResponse::drop(self : IncomingResponse) -> Unit {
  let IncomingResponse(resource) = self
  wasmImportResourceDropIncomingResponse(resource)
}

///|
/// Represents an incoming HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, indicating that the full contents of the
/// body have been received. This resource represents the contents as
/// an `input-stream` and the delivery of trailers as a `future-trailers`,
/// and ensures that the user of this interface may only be consuming either
/// the body contents or waiting on trailers at any given time.
pub(all) struct IncomingBody(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn IncomingBody::drop(self : IncomingBody) -> Unit {
  let IncomingBody(resource) = self
  wasmImportResourceDropIncomingBody(resource)
}

///|
/// Represents a future which may eventually return trailers, or an error.
///
/// In the case that the incoming HTTP Request or Response did not have any
/// trailers, this future will resolve to the empty set of trailers once the
/// complete Request or Response body has been received.
pub(all) struct FutureTrailers(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn FutureTrailers::drop(self : FutureTrailers) -> Unit {
  let FutureTrailers(resource) = self
  wasmImportResourceDropFutureTrailers(resource)
}

///|
/// Represents an outgoing HTTP Response.
pub(all) struct OutgoingResponse(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn OutgoingResponse::drop(self : OutgoingResponse) -> Unit {
  let OutgoingResponse(resource) = self
  wasmImportResourceDropOutgoingResponse(resource)
}

///|
/// Represents an outgoing HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, inducating the full contents of the body
/// have been sent. This resource represents the contents as an
/// `output-stream` child resource, and the completion of the body (with
/// optional trailers) with a static function that consumes the
/// `outgoing-body` resource, and ensures that the user of this interface
/// may not write to the body contents after the body has been finished.
///
/// If the user code drops this resource, as opposed to calling the static
/// method `finish`, the implementation should treat the body as incomplete,
/// and that an error has occurred. The implementation should propagate this
/// error to the HTTP protocol by whatever means it has available,
/// including: corrupting the body on the wire, aborting the associated
/// Request, or sending a late status code for the Response.
pub(all) struct OutgoingBody(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn OutgoingBody::drop(self : OutgoingBody) -> Unit {
  let OutgoingBody(resource) = self
  wasmImportResourceDropOutgoingBody(resource)
}

///|
/// Represents a future which may eventually return an incoming HTTP
/// Response, or an error.
///
/// This resource is returned by the `wasi:http/outgoing-handler` interface to
/// provide the HTTP Response corresponding to the sent Request.
pub(all) struct FutureIncomingResponse(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn FutureIncomingResponse::drop(self : FutureIncomingResponse) -> Unit {
  let FutureIncomingResponse(resource) = self
  wasmImportResourceDropFutureIncomingResponse(resource)
}

///|
/// Attempts to extract a http-related `error` from the wasi:io `error`
/// provided.
///
/// Stream operations which return
/// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
/// type `wasi:io/error/error` with more information about the operation
/// that failed. This payload can be passed through to this function to see
/// if there's http-related information about the error to return.
///
/// Note that this function is fallible because not all io-errors are
/// http-related errors.
pub fn http_error_code(err : @error.Error_) -> ErrorCode? {
  let @error.Error_(handle) = err
  let return_area = mbt_ffi_malloc(40)
  wasmImportHttpErrorCode(handle, return_area)
  let lifted30 : ErrorCode? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted29 = match mbt_ffi_load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted0 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted0,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted1 : Byte? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(mbt_ffi_load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted3 : String? = match mbt_ffi_load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              let result2 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 24),
                mbt_ffi_load32(return_area + 28),
              )
              Option::Some(result2)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted1,
            alert_message: lifted3,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted4 : UInt64? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted4)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted5 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted5)
        }
        22 => {
          let lifted9 : FieldSizePayload? = match
            mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted7 : String? = match mbt_ffi_load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  let result6 = mbt_ffi_ptr2str(
                    mbt_ffi_load32(return_area + 24),
                    mbt_ffi_load32(return_area + 28),
                  )
                  Option::Some(result6)
                }
                _ => panic()
              }
              let lifted8 : UInt? = match mbt_ffi_load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted7,
                field_size: lifted8,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted9)
        }
        23 => {
          let lifted10 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted10)
        }
        24 => {
          let lifted12 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result11 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result11)
            }
            _ => panic()
          }
          let lifted13 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted12,
            field_size: lifted13,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted14 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted14)
        }
        27 => {
          let lifted16 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result15 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result15)
            }
            _ => panic()
          }
          let lifted17 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted16,
            field_size: lifted17,
          })
        }
        28 => {
          let lifted18 : UInt64? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted18)
        }
        29 => {
          let lifted19 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted19)
        }
        30 => {
          let lifted21 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result20 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result20)
            }
            _ => panic()
          }
          let lifted22 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted21,
            field_size: lifted22,
          })
        }
        31 => {
          let lifted24 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result23 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result23)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted24)
        }
        32 => {
          let lifted26 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result25 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result25)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted26)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted28 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result27 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result27)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted28)
        }
        _ => panic()
      }
      Option::Some(lifted29)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted30
}

///|
/// Construct an empty HTTP Fields.
///
/// The resulting `fields` is mutable.
pub fn Fields::fields() -> Fields {
  let result : Int = wasmImportConstructorFields()
  return Fields::Fields(result)
}

///|
/// Construct an HTTP Fields.
///
/// The resulting `fields` is mutable.
///
/// The list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
///
/// The tuple is a pair of the field key, represented as a string, and
/// Value, represented as a list of bytes.
///
/// An error result will be returned if any `field-key` or `field-value` is
/// syntactically invalid, or if a field is forbidden.
pub fn Fields::from_list(
  entries : Array[(String, FixedArray[Byte])],
) -> Result[Fields, HeaderError] {
  let cleanup_list : Array[Int] = []
  let address = mbt_ffi_malloc(entries.length() * 16)
  for index = 0; index < entries.length(); index = index + 1 {
    let iter_elem : (String, FixedArray[Byte]) = entries[index]
    let iter_base = address + index * 16
    let ptr = mbt_ffi_str2ptr(iter_elem.0)
    mbt_ffi_store32(iter_base + 4, iter_elem.0.length())
    mbt_ffi_store32(iter_base + 0, ptr)
    let ptr0 = mbt_ffi_bytes2ptr(iter_elem.1)
    mbt_ffi_store32(iter_base + 12, iter_elem.1.length())
    mbt_ffi_store32(iter_base + 8, ptr0)
    mbt_ffi_free(ptr)
    mbt_ffi_free(ptr0)
  }
  let return_area = mbt_ffi_malloc(8)
  wasmImportStaticFieldsFromList(address, entries.length(), return_area)
  let lifted1 = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(Fields::Fields(mbt_ffi_load32(return_area + 4)))
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(address)
  mbt_ffi_free(return_area)
  cleanup_list.each(mbt_ffi_free)
  return lifted1
}

///|
/// Get all of the values corresponding to a key. If the key is not present
/// in this `fields` or is syntactically invalid, an empty list is returned.
/// However, if the key is present but empty, this is represented by a list
/// with one or more empty field-values present.
pub fn Fields::get(self : Fields, name : String) -> Array[FixedArray[Byte]] {
  let Fields(handle) = self
  let ptr = mbt_ffi_str2ptr(name)
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodFieldsGet(handle, ptr, name.length(), return_area)
  let array : Array[FixedArray[Byte]] = []
  for index = 0; index < mbt_ffi_load32(return_area + 4); index = index + 1 {
    let iter_base = mbt_ffi_load32(return_area + 0) + index * 8
    let result = mbt_ffi_ptr2bytes(
      mbt_ffi_load32(iter_base + 0),
      mbt_ffi_load32(iter_base + 4),
    )
    array.push(result)
  }
  mbt_ffi_free(mbt_ffi_load32(return_area + 0))
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return array
}

///|
/// Returns `true` when the key is present in this `fields`. If the key is
/// syntactically invalid, `false` is returned.
pub fn Fields::has(self : Fields, name : String) -> Bool {
  let Fields(handle) = self
  let ptr = mbt_ffi_str2ptr(name)
  let result : Int = wasmImportMethodFieldsHas(handle, ptr, name.length())
  mbt_ffi_free(ptr)
  return result != 0
}

///|
/// Set all of the values for a key. Clears any existing values for that
/// key, if they have been set.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or any of
/// the `field-value`s are syntactically invalid.
pub fn Fields::set(
  self : Fields,
  name : String,
  value : Array[FixedArray[Byte]],
) -> Result[Unit, HeaderError] {
  let cleanup_list : Array[Int] = []
  let Fields(handle) = self
  let ptr = mbt_ffi_str2ptr(name)
  let address = mbt_ffi_malloc(value.length() * 8)
  for index = 0; index < value.length(); index = index + 1 {
    let iter_elem : FixedArray[Byte] = value[index]
    let iter_base = address + index * 8
    let ptr0 = mbt_ffi_bytes2ptr(iter_elem)
    mbt_ffi_store32(iter_base + 4, iter_elem.length())
    mbt_ffi_store32(iter_base + 0, ptr0)
    mbt_ffi_free(ptr0)
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodFieldsSet(
    handle,
    ptr,
    name.length(),
    address,
    value.length(),
    return_area,
  )
  let lifted1 = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(address)
  mbt_ffi_free(return_area)
  cleanup_list.each(mbt_ffi_free)
  return lifted1
}

///|
/// Delete all values for a key. Does nothing if no values for the key
/// exist.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` is
/// syntactically invalid.
pub fn Fields::delete(
  self : Fields,
  name : String,
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let ptr = mbt_ffi_str2ptr(name)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodFieldsDelete(handle, ptr, name.length(), return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted0
}

///|
/// Append a value for a key. Does not change or delete any existing
/// values for that key.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or
/// `field-value` are syntactically invalid.
pub fn Fields::append(
  self : Fields,
  name : String,
  value : FixedArray[Byte],
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let ptr = mbt_ffi_str2ptr(name)
  let ptr0 = mbt_ffi_bytes2ptr(value)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodFieldsAppend(
    handle,
    ptr,
    name.length(),
    ptr0,
    value.length(),
    return_area,
  )
  let lifted1 = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(ptr0)
  mbt_ffi_free(return_area)
  return lifted1
}

///|
/// Retrieve the full set of keys and values in the Fields. Like the
/// constructor, the list represents each key-value pair.
///
/// The outer list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
pub fn Fields::entries(self : Fields) -> Array[(String, FixedArray[Byte])] {
  let Fields(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodFieldsEntries(handle, return_area)
  let array : Array[(String, FixedArray[Byte])] = []
  for index = 0; index < mbt_ffi_load32(return_area + 4); index = index + 1 {
    let iter_base = mbt_ffi_load32(return_area + 0) + index * 16
    let result = mbt_ffi_ptr2str(
      mbt_ffi_load32(iter_base + 0),
      mbt_ffi_load32(iter_base + 4),
    )
    let result0 = mbt_ffi_ptr2bytes(
      mbt_ffi_load32(iter_base + 8),
      mbt_ffi_load32(iter_base + 12),
    )
    array.push((result, result0))
  }
  mbt_ffi_free(mbt_ffi_load32(return_area + 0))
  mbt_ffi_free(return_area)
  return array
}

///|
/// Make a deep copy of the Fields. Equivalent in behavior to calling the
/// `fields` constructor on the return value of `entries`. The resulting
/// `fields` is mutable.
pub fn Fields::clone(self : Fields) -> Fields {
  let Fields(handle) = self
  let result : Int = wasmImportMethodFieldsClone(handle)
  return Fields::Fields(result)
}

///|
/// Returns the method of the incoming request.
pub fn IncomingRequest::method_(self : IncomingRequest) -> Method {
  let IncomingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodIncomingRequestMethod(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Method::Other(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Returns the path with query parameters from the request, as a string.
pub fn IncomingRequest::path_with_query(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodIncomingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Option::Some(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Returns the protocol scheme from the request.
pub fn IncomingRequest::scheme(self : IncomingRequest) -> Scheme? {
  let IncomingRequest(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodIncomingRequestScheme(handle, return_area)
  let lifted0 : Scheme? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          let result = mbt_ffi_ptr2str(
            mbt_ffi_load32(return_area + 8),
            mbt_ffi_load32(return_area + 12),
          )
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
/// Returns the authority of the Request's target URI, if present.
pub fn IncomingRequest::authority(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodIncomingRequestAuthority(handle, return_area)
  let lifted : String? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Option::Some(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Get the `headers` associated with the request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// The `headers` returned are a child resource: it must be dropped before
/// the parent `incoming-request` is dropped. Dropping this
/// `incoming-request` before all children are dropped will trap.
pub fn IncomingRequest::headers(self : IncomingRequest) -> Fields {
  let IncomingRequest(handle) = self
  let result : Int = wasmImportMethodIncomingRequestHeaders(handle)
  return Fields::Fields(result)
}

///|
/// Gives the `incoming-body` associated with this request. Will only
/// return success at most once, and subsequent calls will return error.
pub fn IncomingRequest::consume(
  self : IncomingRequest,
) -> Result[IncomingBody, Unit] {
  let IncomingRequest(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodIncomingRequestConsume(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(mbt_ffi_load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Construct a new `outgoing-request` with a default `method` of `GET`, and
/// `none` values for `path-with-query`, `scheme`, and `authority`.
///
/// * `headers` is the HTTP Headers for the Request.
///
/// It is possible to construct, or manipulate with the accessor functions
/// below, an `outgoing-request` with an invalid combination of `scheme`
/// and `authority`, or `headers` which are not permitted to be sent.
/// It is the obligation of the `outgoing-handler.handle` implementation
/// to reject invalid constructions of `outgoing-request`.
pub fn OutgoingRequest::outgoing_request(headers : Fields) -> OutgoingRequest {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingRequest(handle)
  return OutgoingRequest::OutgoingRequest(result)
}

///|
/// Returns the resource corresponding to the outgoing Body for this
/// Request.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-request` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingRequest::body(
  self : OutgoingRequest,
) -> Result[OutgoingBody, Unit] {
  let OutgoingRequest(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodOutgoingRequestBody(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(mbt_ffi_load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Get the Method for the Request.
pub fn OutgoingRequest::method_(self : OutgoingRequest) -> Method {
  let OutgoingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodOutgoingRequestMethod(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Method::Other(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the Method for the Request. Fails if the string present in a
/// `method.other` argument is not a syntactically valid method.
pub fn OutgoingRequest::set_method(
  self : OutgoingRequest,
  method_ : Method,
) -> Result[Unit, Unit] {
  let cleanup_list : Array[Int] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered9, lowered10) = match method_ {
    Get => (0, 0, 0)
    Head => (1, 0, 0)
    Post => (2, 0, 0)
    Put => (3, 0, 0)
    Delete => (4, 0, 0)
    Connect => (5, 0, 0)
    Options => (6, 0, 0)
    Trace => (7, 0, 0)
    Patch => (8, 0, 0)
    Other(payload8) => {
      let ptr = mbt_ffi_str2ptr(payload8)
      mbt_ffi_free(ptr)
      (9, ptr, payload8.length())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetMethod(
    handle, lowered, lowered9, lowered10,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanup_list.each(mbt_ffi_free)
  return lifted
}

///|
/// Get the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query.
pub fn OutgoingRequest::path_with_query(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodOutgoingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Option::Some(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query. Fails is the
/// string given is not a syntactically valid path and query uri component.
pub fn OutgoingRequest::set_path_with_query(
  self : OutgoingRequest,
  path_with_query : String?,
) -> Result[Unit, Unit] {
  let cleanup_list : Array[Int] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered1, lowered2) = match path_with_query {
    None => (0, 0, 0)
    Some(payload0) => {
      let ptr = mbt_ffi_str2ptr(payload0)
      mbt_ffi_free(ptr)
      (1, ptr, payload0.length())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetPathWithQuery(
    handle, lowered, lowered1, lowered2,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanup_list.each(mbt_ffi_free)
  return lifted
}

///|
/// Get the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme.
pub fn OutgoingRequest::scheme(self : OutgoingRequest) -> Scheme? {
  let OutgoingRequest(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodOutgoingRequestScheme(handle, return_area)
  let lifted0 : Scheme? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          let result = mbt_ffi_ptr2str(
            mbt_ffi_load32(return_area + 8),
            mbt_ffi_load32(return_area + 12),
          )
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
/// Set the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme. Fails if the
/// string given is not a syntactically valid uri scheme.
pub fn OutgoingRequest::set_scheme(
  self : OutgoingRequest,
  scheme : Scheme?,
) -> Result[Unit, Unit] {
  let cleanup_list : Array[Int] = []
  let OutgoingRequest(handle) = self
  let (lowered6, lowered7, lowered8, lowered9) = match scheme {
    None => (0, 0, 0, 0)
    Some(payload0) => {
      let (lowered, lowered4, lowered5) = match payload0 {
        Http => (0, 0, 0)
        Https => (1, 0, 0)
        Other(payload3) => {
          let ptr = mbt_ffi_str2ptr(payload3)
          mbt_ffi_free(ptr)
          (2, ptr, payload3.length())
        }
      }
      (1, lowered, lowered4, lowered5)
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetScheme(
    handle, lowered6, lowered7, lowered8, lowered9,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanup_list.each(mbt_ffi_free)
  return lifted
}

///|
/// Get the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority.
pub fn OutgoingRequest::authority(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodOutgoingRequestAuthority(handle, return_area)
  let lifted : String? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Option::Some(result)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority. Fails if the string given is
/// not a syntactically valid URI authority.
pub fn OutgoingRequest::set_authority(
  self : OutgoingRequest,
  authority : String?,
) -> Result[Unit, Unit] {
  let cleanup_list : Array[Int] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered1, lowered2) = match authority {
    None => (0, 0, 0)
    Some(payload0) => {
      let ptr = mbt_ffi_str2ptr(payload0)
      mbt_ffi_free(ptr)
      (1, ptr, payload0.length())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetAuthority(
    handle, lowered, lowered1, lowered2,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanup_list.each(mbt_ffi_free)
  return lifted
}

///|
/// Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingRequest::headers(self : OutgoingRequest) -> Fields {
  let OutgoingRequest(handle) = self
  let result : Int = wasmImportMethodOutgoingRequestHeaders(handle)
  return Fields::Fields(result)
}

///|
/// Construct a default `request-options` value.
pub fn RequestOptions::request_options() -> RequestOptions {
  let result : Int = wasmImportConstructorRequestOptions()
  return RequestOptions::RequestOptions(result)
}

///|
/// The timeout for the initial connect to the HTTP Server.
pub fn RequestOptions::connect_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodRequestOptionsConnectTimeout(handle, return_area)
  let lifted : UInt64? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the timeout for the initial connect to the HTTP Server. An error
/// return value indicates that this timeout is not supported.
pub fn RequestOptions::set_connect_timeout(
  self : RequestOptions,
  duration : UInt64?,
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered1) = match duration {
    None => (0, 0L)
    Some(payload0) => (1, payload0.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetConnectTimeout(
    handle, lowered, lowered1,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///|
/// The timeout for receiving the first byte of the Response body.
pub fn RequestOptions::first_byte_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodRequestOptionsFirstByteTimeout(handle, return_area)
  let lifted : UInt64? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the timeout for receiving the first byte of the Response body. An
/// error return value indicates that this timeout is not supported.
pub fn RequestOptions::set_first_byte_timeout(
  self : RequestOptions,
  duration : UInt64?,
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered1) = match duration {
    None => (0, 0L)
    Some(payload0) => (1, payload0.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetFirstByteTimeout(
    handle, lowered, lowered1,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///|
/// The timeout for receiving subsequent chunks of bytes in the Response
/// body stream.
pub fn RequestOptions::between_bytes_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodRequestOptionsBetweenBytesTimeout(handle, return_area)
  let lifted : UInt64? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Set the timeout for receiving subsequent chunks of bytes in the Response
/// body stream. An error return value indicates that this timeout is not
/// supported.
pub fn RequestOptions::set_between_bytes_timeout(
  self : RequestOptions,
  duration : UInt64?,
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered1) = match duration {
    None => (0, 0L)
    Some(payload0) => (1, payload0.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetBetweenBytesTimeout(
    handle, lowered, lowered1,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///|
/// Set the value of the `response-outparam` to either send a response,
/// or indicate an error.
///
/// This method consumes the `response-outparam` to ensure that it is
/// called at most once. If it is never called, the implementation
/// will respond with an error.
///
/// The user may provide an `error` to `response` to allow the
/// implementation determine how to respond with an HTTP error response.
pub fn ResponseOutparam::set(
  param : ResponseOutparam,
  response : Result[OutgoingResponse, ErrorCode],
) -> Unit {
  let cleanup_list : Array[Int] = []
  let ResponseOutparam(handle) = param
  let (
    lowered156,
    lowered157,
    lowered158,
    lowered159,
    lowered160,
    lowered161,
    lowered162,
    lowered163,
  ) = match response {
    Ok(payload) => {
      let OutgoingResponse(handle0) = payload
      (0, handle0, 0, 0L, 0, 0, 0, 0)
    }
    Err(payload1) => {
      let (
        lowered149,
        lowered150,
        lowered151,
        lowered152,
        lowered153,
        lowered154,
        lowered155,
      ) = match payload1 {
        DnsTimeout => (0, 0, 0L, 0, 0, 0, 0)
        DnsError(payload3) => {
          let (lowered, lowered6, lowered7) = match payload3.rcode {
            None => (0, 0, 0)
            Some(payload5) => {
              let ptr = mbt_ffi_str2ptr(payload5)
              mbt_ffi_free(ptr)
              (1, ptr, payload5.length())
            }
          }
          let (lowered10, lowered11) = match payload3.info_code {
            None => (0, 0)
            Some(payload9) => (1, payload9.reinterpret_as_int())
          }
          (
            1,
            lowered,
            Int::to_int64(lowered6),
            lowered7,
            lowered10,
            lowered11,
            0,
          )
        }
        DestinationNotFound => (2, 0, 0L, 0, 0, 0, 0)
        DestinationUnavailable => (3, 0, 0L, 0, 0, 0, 0)
        DestinationIpProhibited => (4, 0, 0L, 0, 0, 0, 0)
        DestinationIpUnroutable => (5, 0, 0L, 0, 0, 0, 0)
        ConnectionRefused => (6, 0, 0L, 0, 0, 0, 0)
        ConnectionTerminated => (7, 0, 0L, 0, 0, 0, 0)
        ConnectionTimeout => (8, 0, 0L, 0, 0, 0, 0)
        ConnectionReadTimeout => (9, 0, 0L, 0, 0, 0, 0)
        ConnectionWriteTimeout => (10, 0, 0L, 0, 0, 0, 0)
        ConnectionLimitReached => (11, 0, 0L, 0, 0, 0, 0)
        TlsProtocolError => (12, 0, 0L, 0, 0, 0, 0)
        TlsCertificateError => (13, 0, 0L, 0, 0, 0, 0)
        TlsAlertReceived(payload24) => {
          let (lowered27, lowered28) = match payload24.alert_id {
            None => (0, 0)
            Some(payload26) => (1, payload26.to_int())
          }
          let (lowered32, lowered33, lowered34) = match
            payload24.alert_message {
            None => (0, 0, 0)
            Some(payload30) => {
              let ptr31 = mbt_ffi_str2ptr(payload30)
              mbt_ffi_free(ptr31)
              (1, ptr31, payload30.length())
            }
          }
          (
            14,
            lowered27,
            Int::to_int64(lowered28),
            lowered32,
            lowered33,
            lowered34,
            0,
          )
        }
        HttpRequestDenied => (15, 0, 0L, 0, 0, 0, 0)
        HttpRequestLengthRequired => (16, 0, 0L, 0, 0, 0, 0)
        HttpRequestBodySize(payload37) => {
          let (lowered40, lowered41) = match payload37 {
            None => (0, 0L)
            Some(payload39) => (1, payload39.reinterpret_as_int64())
          }
          (17, lowered40, lowered41, 0, 0, 0, 0)
        }
        HttpRequestMethodInvalid => (18, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriInvalid => (19, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriTooLong => (20, 0, 0L, 0, 0, 0, 0)
        HttpRequestHeaderSectionSize(payload45) => {
          let (lowered48, lowered49) = match payload45 {
            None => (0, 0)
            Some(payload47) => (1, payload47.reinterpret_as_int())
          }
          (21, lowered48, Int::to_int64(lowered49), 0, 0, 0, 0)
        }
        HttpRequestHeaderSize(payload50) => {
          let (lowered63, lowered64, lowered65, lowered66, lowered67, lowered68) = match
            payload50 {
            None => (0, 0, 0, 0, 0, 0)
            Some(payload52) => {
              let (lowered56, lowered57, lowered58) = match
                payload52.field_name {
                None => (0, 0, 0)
                Some(payload54) => {
                  let ptr55 = mbt_ffi_str2ptr(payload54)
                  mbt_ffi_free(ptr55)
                  (1, ptr55, payload54.length())
                }
              }
              let (lowered61, lowered62) = match payload52.field_size {
                None => (0, 0)
                Some(payload60) => (1, payload60.reinterpret_as_int())
              }
              (1, lowered56, lowered57, lowered58, lowered61, lowered62)
            }
          }
          (
            22,
            lowered63,
            Int::to_int64(lowered64),
            lowered65,
            lowered66,
            lowered67,
            lowered68,
          )
        }
        HttpRequestTrailerSectionSize(payload69) => {
          let (lowered72, lowered73) = match payload69 {
            None => (0, 0)
            Some(payload71) => (1, payload71.reinterpret_as_int())
          }
          (23, lowered72, Int::to_int64(lowered73), 0, 0, 0, 0)
        }
        HttpRequestTrailerSize(payload74) => {
          let (lowered78, lowered79, lowered80) = match payload74.field_name {
            None => (0, 0, 0)
            Some(payload76) => {
              let ptr77 = mbt_ffi_str2ptr(payload76)
              mbt_ffi_free(ptr77)
              (1, ptr77, payload76.length())
            }
          }
          let (lowered83, lowered84) = match payload74.field_size {
            None => (0, 0)
            Some(payload82) => (1, payload82.reinterpret_as_int())
          }
          (
            24,
            lowered78,
            Int::to_int64(lowered79),
            lowered80,
            lowered83,
            lowered84,
            0,
          )
        }
        HttpResponseIncomplete => (25, 0, 0L, 0, 0, 0, 0)
        HttpResponseHeaderSectionSize(payload86) => {
          let (lowered89, lowered90) = match payload86 {
            None => (0, 0)
            Some(payload88) => (1, payload88.reinterpret_as_int())
          }
          (26, lowered89, Int::to_int64(lowered90), 0, 0, 0, 0)
        }
        HttpResponseHeaderSize(payload91) => {
          let (lowered95, lowered96, lowered97) = match payload91.field_name {
            None => (0, 0, 0)
            Some(payload93) => {
              let ptr94 = mbt_ffi_str2ptr(payload93)
              mbt_ffi_free(ptr94)
              (1, ptr94, payload93.length())
            }
          }
          let (lowered100, lowered101) = match payload91.field_size {
            None => (0, 0)
            Some(payload99) => (1, payload99.reinterpret_as_int())
          }
          (
            27,
            lowered95,
            Int::to_int64(lowered96),
            lowered97,
            lowered100,
            lowered101,
            0,
          )
        }
        HttpResponseBodySize(payload102) => {
          let (lowered105, lowered106) = match payload102 {
            None => (0, 0L)
            Some(payload104) => (1, payload104.reinterpret_as_int64())
          }
          (28, lowered105, lowered106, 0, 0, 0, 0)
        }
        HttpResponseTrailerSectionSize(payload107) => {
          let (lowered110, lowered111) = match payload107 {
            None => (0, 0)
            Some(payload109) => (1, payload109.reinterpret_as_int())
          }
          (29, lowered110, Int::to_int64(lowered111), 0, 0, 0, 0)
        }
        HttpResponseTrailerSize(payload112) => {
          let (lowered116, lowered117, lowered118) = match
            payload112.field_name {
            None => (0, 0, 0)
            Some(payload114) => {
              let ptr115 = mbt_ffi_str2ptr(payload114)
              mbt_ffi_free(ptr115)
              (1, ptr115, payload114.length())
            }
          }
          let (lowered121, lowered122) = match payload112.field_size {
            None => (0, 0)
            Some(payload120) => (1, payload120.reinterpret_as_int())
          }
          (
            30,
            lowered116,
            Int::to_int64(lowered117),
            lowered118,
            lowered121,
            lowered122,
            0,
          )
        }
        HttpResponseTransferCoding(payload123) => {
          let (lowered127, lowered128, lowered129) = match payload123 {
            None => (0, 0, 0)
            Some(payload125) => {
              let ptr126 = mbt_ffi_str2ptr(payload125)
              mbt_ffi_free(ptr126)
              (1, ptr126, payload125.length())
            }
          }
          (31, lowered127, Int::to_int64(lowered128), lowered129, 0, 0, 0)
        }
        HttpResponseContentCoding(payload130) => {
          let (lowered134, lowered135, lowered136) = match payload130 {
            None => (0, 0, 0)
            Some(payload132) => {
              let ptr133 = mbt_ffi_str2ptr(payload132)
              mbt_ffi_free(ptr133)
              (1, ptr133, payload132.length())
            }
          }
          (32, lowered134, Int::to_int64(lowered135), lowered136, 0, 0, 0)
        }
        HttpResponseTimeout => (33, 0, 0L, 0, 0, 0, 0)
        HttpUpgradeFailed => (34, 0, 0L, 0, 0, 0, 0)
        HttpProtocolError => (35, 0, 0L, 0, 0, 0, 0)
        LoopDetected => (36, 0, 0L, 0, 0, 0, 0)
        ConfigurationError => (37, 0, 0L, 0, 0, 0, 0)
        InternalError(payload142) => {
          let (lowered146, lowered147, lowered148) = match payload142 {
            None => (0, 0, 0)
            Some(payload144) => {
              let ptr145 = mbt_ffi_str2ptr(payload144)
              mbt_ffi_free(ptr145)
              (1, ptr145, payload144.length())
            }
          }
          (38, lowered146, Int::to_int64(lowered147), lowered148, 0, 0, 0)
        }
      }
      (
        1, lowered149, lowered150, lowered151, lowered152, lowered153, lowered154,
        lowered155,
      )
    }
  }
  wasmImportStaticResponseOutparamSet(
    handle, lowered156, lowered157, lowered158, lowered159, lowered160, lowered161,
    lowered162, lowered163,
  )
  cleanup_list.each(mbt_ffi_free)
}

///|
/// Returns the status code from the incoming response.
pub fn IncomingResponse::status(self : IncomingResponse) -> UInt {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseStatus(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///|
/// Returns the headers from the incoming response.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `incoming-response` is dropped.
pub fn IncomingResponse::headers(self : IncomingResponse) -> Fields {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseHeaders(handle)
  return Fields::Fields(result)
}

///|
/// Returns the incoming body. May be called at most once. Returns error
/// if called additional times.
pub fn IncomingResponse::consume(
  self : IncomingResponse,
) -> Result[IncomingBody, Unit] {
  let IncomingResponse(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodIncomingResponseConsume(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(mbt_ffi_load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Returns the contents of the body, as a stream of bytes.
///
/// Returns success on first call: the stream representing the contents
/// can be retrieved at most once. Subsequent calls will return error.
///
/// The returned `input-stream` resource is a child: it must be dropped
/// before the parent `incoming-body` is dropped, or consumed by
/// `incoming-body.finish`.
///
/// This invariant ensures that the implementation can determine whether
/// the user is consuming the contents of the body, waiting on the
/// `future-trailers` to be ready, or neither. This allows for network
/// backpressure is to be applied when the user is consuming the body,
/// and for that backpressure to not inhibit delivery of the trailers if
/// the user does not read the entire body.
pub fn IncomingBody::stream(
  self : IncomingBody,
) -> Result[@streams.InputStream, Unit] {
  let IncomingBody(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodIncomingBodyStream(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.InputStream::InputStream(mbt_ffi_load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Takes ownership of `incoming-body`, and returns a `future-trailers`.
/// This function will trap if the `input-stream` child is still alive.
pub fn IncomingBody::finish(this : IncomingBody) -> FutureTrailers {
  let IncomingBody(handle) = this
  let result : Int = wasmImportStaticIncomingBodyFinish(handle)
  return FutureTrailers::FutureTrailers(result)
}

///|
/// Returns a pollable which becomes ready when either the trailers have
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureTrailers::subscribe(self : FutureTrailers) -> @poll.Pollable {
  let FutureTrailers(handle) = self
  let result : Int = wasmImportMethodFutureTrailersSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///|
/// Returns the contents of the trailers, or an error which occurred,
/// once the future is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the trailers or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the HTTP Request or Response
/// body, as well as any trailers, were received successfully, or that an
/// error occurred receiving them. The optional `trailers` indicates whether
/// or not trailers were present in the body.
///
/// When some `trailers` are returned by this method, the `trailers`
/// resource is immutable, and a child. Use of the `set`, `append`, or
/// `delete` methods will return an error, and the resource must be
/// dropped before the parent `future-trailers` is dropped.
pub fn FutureTrailers::get(
  self : FutureTrailers,
) -> Result[Result[Fields?, ErrorCode], Unit]? {
  let FutureTrailers(handle) = self
  let return_area = mbt_ffi_malloc(56)
  wasmImportMethodFutureTrailersGet(handle, return_area)
  let lifted33 : Result[Result[Fields?, ErrorCode], Unit]? = match
    mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted32 = match mbt_ffi_load8_u(return_area + 8) {
        0 => {
          let lifted31 = match mbt_ffi_load8_u(return_area + 16) {
            0 => {
              let lifted : Fields? = match mbt_ffi_load8_u(return_area + 24) {
                0 => Option::None
                1 =>
                  Option::Some(Fields::Fields(mbt_ffi_load32(return_area + 28)))
                _ => panic()
              }
              Result::Ok(lifted)
            }
            1 => {
              let lifted30 = match mbt_ffi_load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted0 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted1 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted0,
                    info_code: lifted1,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted2 : Byte? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(mbt_ffi_load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted4 : String? = match
                    mbt_ffi_load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      let result3 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 40),
                        mbt_ffi_load32(return_area + 44),
                      )
                      Option::Some(result3)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted2,
                    alert_message: lifted4,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted5 : UInt64? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted5)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted6 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted6)
                }
                22 => {
                  let lifted10 : FieldSizePayload? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted8 : String? = match
                        mbt_ffi_load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          let result7 = mbt_ffi_ptr2str(
                            mbt_ffi_load32(return_area + 40),
                            mbt_ffi_load32(return_area + 44),
                          )
                          Option::Some(result7)
                        }
                        _ => panic()
                      }
                      let lifted9 : UInt? = match
                        mbt_ffi_load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            mbt_ffi_load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted8,
                        field_size: lifted9,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted10)
                }
                23 => {
                  let lifted11 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted11)
                }
                24 => {
                  let lifted13 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result12 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result12)
                    }
                    _ => panic()
                  }
                  let lifted14 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted13,
                    field_size: lifted14,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted15 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted15)
                }
                27 => {
                  let lifted17 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result16 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result16)
                    }
                    _ => panic()
                  }
                  let lifted18 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted17,
                    field_size: lifted18,
                  })
                }
                28 => {
                  let lifted19 : UInt64? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted19)
                }
                29 => {
                  let lifted20 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted20)
                }
                30 => {
                  let lifted22 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result21 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result21)
                    }
                    _ => panic()
                  }
                  let lifted23 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted22,
                    field_size: lifted23,
                  })
                }
                31 => {
                  let lifted25 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result24 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result24)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted25)
                }
                32 => {
                  let lifted27 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result26 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result26)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted27)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted29 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result28 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result28)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted29)
                }
                _ => panic()
              }
              Result::Err(lifted30)
            }
            _ => panic()
          }
          Result::Ok(lifted31)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted32)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted33
}

///|
/// Construct an `outgoing-response`, with a default `status-code` of `200`.
/// If a different `status-code` is needed, it must be set via the
/// `set-status-code` method.
///
/// * `headers` is the HTTP Headers for the Response.
pub fn OutgoingResponse::outgoing_response(
  headers : Fields,
) -> OutgoingResponse {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingResponse(handle)
  return OutgoingResponse::OutgoingResponse(result)
}

///|
/// Get the HTTP Status Code for the Response.
pub fn OutgoingResponse::status_code(self : OutgoingResponse) -> UInt {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseStatusCode(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///|
/// Set the HTTP Status Code for the Response. Fails if the status-code
/// given is not a valid http status code.
pub fn OutgoingResponse::set_status_code(
  self : OutgoingResponse,
  status_code : UInt,
) -> Result[Unit, Unit] {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseSetStatusCode(
    handle,
    status_code.reinterpret_as_int(),
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///|
/// Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingResponse::headers(self : OutgoingResponse) -> Fields {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseHeaders(handle)
  return Fields::Fields(result)
}

///|
/// Returns the resource corresponding to the outgoing Body for this Response.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-response` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingResponse::body(
  self : OutgoingResponse,
) -> Result[OutgoingBody, Unit] {
  let OutgoingResponse(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodOutgoingResponseBody(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(mbt_ffi_load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Returns a stream for writing the body contents.
///
/// The returned `output-stream` is a child resource: it must be dropped
/// before the parent `outgoing-body` resource is dropped (or finished),
/// otherwise the `outgoing-body` drop or `finish` will trap.
///
/// Returns success on the first call: the `output-stream` resource for
/// this `outgoing-body` may be retrieved at most once. Subsequent calls
/// will return error.
pub fn OutgoingBody::write(
  self : OutgoingBody,
) -> Result[@streams.OutputStream, Unit] {
  let OutgoingBody(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodOutgoingBodyWrite(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(mbt_ffi_load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
/// Finalize an outgoing body, optionally providing trailers. This must be
/// called to signal that the response is complete. If the `outgoing-body`
/// is dropped without calling `outgoing-body.finalize`, the implementation
/// should treat the body as corrupted.
///
/// Fails if the body's `outgoing-request` or `outgoing-response` was
/// constructed with a Content-Length header, and the contents written
/// to the body (via `write`) does not match the value given in the
/// Content-Length.
pub fn OutgoingBody::finish(
  this : OutgoingBody,
  trailers : Fields?,
) -> Result[Unit, ErrorCode] {
  let OutgoingBody(handle) = this
  let (lowered, lowered2) = match trailers {
    None => (0, 0)
    Some(payload0) => {
      let Fields(handle1) = payload0
      (1, handle1)
    }
  }
  let return_area = mbt_ffi_malloc(40)
  wasmImportStaticOutgoingBodyFinish(handle, lowered, lowered2, return_area)
  let lifted33 = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted32 = match mbt_ffi_load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted3 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted3,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted4 : Byte? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(mbt_ffi_load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted6 : String? = match mbt_ffi_load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              let result5 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 24),
                mbt_ffi_load32(return_area + 28),
              )
              Option::Some(result5)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted4,
            alert_message: lifted6,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted7 : UInt64? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted7)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted8 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted8)
        }
        22 => {
          let lifted12 : FieldSizePayload? = match
            mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted10 : String? = match mbt_ffi_load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  let result9 = mbt_ffi_ptr2str(
                    mbt_ffi_load32(return_area + 24),
                    mbt_ffi_load32(return_area + 28),
                  )
                  Option::Some(result9)
                }
                _ => panic()
              }
              let lifted11 : UInt? = match mbt_ffi_load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted10,
                field_size: lifted11,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted12)
        }
        23 => {
          let lifted13 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted13)
        }
        24 => {
          let lifted15 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result14 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result14)
            }
            _ => panic()
          }
          let lifted16 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted15,
            field_size: lifted16,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted17 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted17)
        }
        27 => {
          let lifted19 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result18 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result18)
            }
            _ => panic()
          }
          let lifted20 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted19,
            field_size: lifted20,
          })
        }
        28 => {
          let lifted21 : UInt64? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted21)
        }
        29 => {
          let lifted22 : UInt? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 20).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted22)
        }
        30 => {
          let lifted24 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result23 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result23)
            }
            _ => panic()
          }
          let lifted25 : UInt? = match mbt_ffi_load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted24,
            field_size: lifted25,
          })
        }
        31 => {
          let lifted27 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result26 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result26)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted27)
        }
        32 => {
          let lifted29 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result28 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result28)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted29)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted31 : String? = match mbt_ffi_load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let result30 = mbt_ffi_ptr2str(
                mbt_ffi_load32(return_area + 20),
                mbt_ffi_load32(return_area + 24),
              )
              Option::Some(result30)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted31)
        }
        _ => panic()
      }
      Result::Err(lifted32)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted33
}

///|
/// Returns a pollable which becomes ready when either the Response has
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureIncomingResponse::subscribe(
  self : FutureIncomingResponse,
) -> @poll.Pollable {
  let FutureIncomingResponse(handle) = self
  let result : Int = wasmImportMethodFutureIncomingResponseSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///|
/// Returns the incoming HTTP Response, or an error, once one is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the response or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the incoming HTTP Response
/// status and headers have received successfully, or that an error
/// occurred. Errors may also occur while consuming the response body,
/// but those will be reported by the `incoming-body` and its
/// `output-stream` child.
pub fn FutureIncomingResponse::get(
  self : FutureIncomingResponse,
) -> Result[Result[IncomingResponse, ErrorCode], Unit]? {
  let FutureIncomingResponse(handle) = self
  let return_area = mbt_ffi_malloc(56)
  wasmImportMethodFutureIncomingResponseGet(handle, return_area)
  let lifted32 : Result[Result[IncomingResponse, ErrorCode], Unit]? = match
    mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted31 = match mbt_ffi_load8_u(return_area + 8) {
        0 => {
          let lifted30 = match mbt_ffi_load8_u(return_area + 16) {
            0 =>
              Result::Ok(
                IncomingResponse::IncomingResponse(
                  mbt_ffi_load32(return_area + 24),
                ),
              )
            1 => {
              let lifted29 = match mbt_ffi_load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted0 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted,
                    info_code: lifted0,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted1 : Byte? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(mbt_ffi_load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted3 : String? = match
                    mbt_ffi_load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      let result2 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 40),
                        mbt_ffi_load32(return_area + 44),
                      )
                      Option::Some(result2)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted1,
                    alert_message: lifted3,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted4 : UInt64? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted4)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted5 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted5)
                }
                22 => {
                  let lifted9 : FieldSizePayload? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted7 : String? = match
                        mbt_ffi_load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          let result6 = mbt_ffi_ptr2str(
                            mbt_ffi_load32(return_area + 40),
                            mbt_ffi_load32(return_area + 44),
                          )
                          Option::Some(result6)
                        }
                        _ => panic()
                      }
                      let lifted8 : UInt? = match
                        mbt_ffi_load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            mbt_ffi_load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted7,
                        field_size: lifted8,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted9)
                }
                23 => {
                  let lifted10 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted10)
                }
                24 => {
                  let lifted12 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result11 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result11)
                    }
                    _ => panic()
                  }
                  let lifted13 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted12,
                    field_size: lifted13,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted14 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted14)
                }
                27 => {
                  let lifted16 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result15 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result15)
                    }
                    _ => panic()
                  }
                  let lifted17 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted16,
                    field_size: lifted17,
                  })
                }
                28 => {
                  let lifted18 : UInt64? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted18)
                }
                29 => {
                  let lifted19 : UInt? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted19)
                }
                30 => {
                  let lifted21 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result20 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result20)
                    }
                    _ => panic()
                  }
                  let lifted22 : UInt? = match
                    mbt_ffi_load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted21,
                    field_size: lifted22,
                  })
                }
                31 => {
                  let lifted24 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result23 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result23)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted24)
                }
                32 => {
                  let lifted26 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result25 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result25)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted26)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted28 : String? = match
                    mbt_ffi_load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let result27 = mbt_ffi_ptr2str(
                        mbt_ffi_load32(return_area + 36),
                        mbt_ffi_load32(return_area + 40),
                      )
                      Option::Some(result27)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted28)
                }
                _ => panic()
              }
              Result::Err(lifted29)
            }
            _ => panic()
          }
          Result::Ok(lifted30)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted31)
    }
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted32
}
