// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| This type corresponds to HTTP standard Methods.
pub(all) enum Method {
  Get
  Head
  Post
  Put
  Delete
  Connect
  Options
  Trace
  Patch
  Other(String)
} derive(Show, Eq)

///| This type corresponds to HTTP standard Related Schemes.
pub(all) enum Scheme {
  Http
  Https
  Other(String)
} derive(Show, Eq)

///| Defines the case payload type for `DNS-error` above:
pub(all) struct DnsErrorPayload {
  rcode : String?
  info_code : UInt?
} derive(Show, Eq)

///| Defines the case payload type for `TLS-alert-received` above:
pub(all) struct TlsAlertReceivedPayload {
  alert_id : Byte?
  alert_message : String?
} derive(Show, Eq)

///| Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
pub(all) struct FieldSizePayload {
  field_name : String?
  field_size : UInt?
} derive(Show, Eq)

///| These cases are inspired by the IANA HTTP Proxy Error Types:
/// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
pub(all) type! ErrorCode {
  DnsTimeout
  DnsError(DnsErrorPayload)
  DestinationNotFound
  DestinationUnavailable
  DestinationIpProhibited
  DestinationIpUnroutable
  ConnectionRefused
  ConnectionTerminated
  ConnectionTimeout
  ConnectionReadTimeout
  ConnectionWriteTimeout
  ConnectionLimitReached
  TlsProtocolError
  TlsCertificateError
  TlsAlertReceived(TlsAlertReceivedPayload)
  HttpRequestDenied
  HttpRequestLengthRequired
  HttpRequestBodySize(UInt64?)
  HttpRequestMethodInvalid
  HttpRequestUriInvalid
  HttpRequestUriTooLong
  HttpRequestHeaderSectionSize(UInt?)
  HttpRequestHeaderSize(FieldSizePayload?)
  HttpRequestTrailerSectionSize(UInt?)
  HttpRequestTrailerSize(FieldSizePayload)
  HttpResponseIncomplete
  HttpResponseHeaderSectionSize(UInt?)
  HttpResponseHeaderSize(FieldSizePayload)
  HttpResponseBodySize(UInt64?)
  HttpResponseTrailerSectionSize(UInt?)
  HttpResponseTrailerSize(FieldSizePayload)
  HttpResponseTransferCoding(String?)
  HttpResponseContentCoding(String?)
  HttpResponseTimeout
  HttpUpgradeFailed
  HttpProtocolError
  LoopDetected
  ConfigurationError
  InternalError(String?)
} derive(Show, Eq)

///| This type enumerates the different kinds of errors that may occur when
/// setting or appending to a `fields` resource.
pub(all) type! HeaderError {
  InvalidSyntax
  Forbidden
  Immutable
} derive(Show, Eq)

///| This following block defines the `fields` resource which corresponds to
/// HTTP standard Fields. Fields are a common representation used for both
/// Headers and Trailers.
///
/// A `fields` may be mutable or immutable. A `fields` created using the
/// constructor, `from-list`, or `clone` will be mutable, but a `fields`
/// resource given by other means (including, but not limited to,
/// `incoming-request.headers`, `outgoing-request.headers`) might be be
/// immutable. In an immutable fields, the `set`, `append`, and `delete`
/// operations will fail with `header-error.immutable`.
pub(all) type Fields Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Fields::drop(self : Fields) -> Unit {
  let Fields(resource) = self
  wasmImportResourceDropFields(resource)
}

///| Represents an incoming HTTP Request.
pub(all) type IncomingRequest Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingRequest::drop(self : IncomingRequest) -> Unit {
  let IncomingRequest(resource) = self
  wasmImportResourceDropIncomingRequest(resource)
}

///| Represents an outgoing HTTP Request.
pub(all) type OutgoingRequest Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingRequest::drop(self : OutgoingRequest) -> Unit {
  let OutgoingRequest(resource) = self
  wasmImportResourceDropOutgoingRequest(resource)
}

///| Parameters for making an HTTP Request. Each of these parameters is
/// currently an optional timeout applicable to the transport layer of the
/// HTTP protocol.
///
/// These timeouts are separate from any the user may use to bound a
/// blocking call to `wasi:io/poll.poll`.
pub(all) type RequestOptions Int derive(Show, Eq)

///| Drops a resource handle.
pub fn RequestOptions::drop(self : RequestOptions) -> Unit {
  let RequestOptions(resource) = self
  wasmImportResourceDropRequestOptions(resource)
}

///| Represents the ability to send an HTTP Response.
///
/// This resource is used by the `wasi:http/incoming-handler` interface to
/// allow a Response to be sent corresponding to the Request provided as the
/// other argument to `incoming-handler.handle`.
pub(all) type ResponseOutparam Int derive(Show, Eq)

///| Drops a resource handle.
pub fn ResponseOutparam::drop(self : ResponseOutparam) -> Unit {
  let ResponseOutparam(resource) = self
  wasmImportResourceDropResponseOutparam(resource)
}

///| Represents an incoming HTTP Response.
pub(all) type IncomingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingResponse::drop(self : IncomingResponse) -> Unit {
  let IncomingResponse(resource) = self
  wasmImportResourceDropIncomingResponse(resource)
}

///| Represents an incoming HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, indicating that the full contents of the
/// body have been received. This resource represents the contents as
/// an `input-stream` and the delivery of trailers as a `future-trailers`,
/// and ensures that the user of this interface may only be consuming either
/// the body contents or waiting on trailers at any given time.
pub(all) type IncomingBody Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingBody::drop(self : IncomingBody) -> Unit {
  let IncomingBody(resource) = self
  wasmImportResourceDropIncomingBody(resource)
}

///| Represents a future which may eventually return trailers, or an error.
///
/// In the case that the incoming HTTP Request or Response did not have any
/// trailers, this future will resolve to the empty set of trailers once the
/// complete Request or Response body has been received.
pub(all) type FutureTrailers Int derive(Show, Eq)

///| Drops a resource handle.
pub fn FutureTrailers::drop(self : FutureTrailers) -> Unit {
  let FutureTrailers(resource) = self
  wasmImportResourceDropFutureTrailers(resource)
}

///| Represents an outgoing HTTP Response.
pub(all) type OutgoingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingResponse::drop(self : OutgoingResponse) -> Unit {
  let OutgoingResponse(resource) = self
  wasmImportResourceDropOutgoingResponse(resource)
}

///| Represents an outgoing HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, inducating the full contents of the body
/// have been sent. This resource represents the contents as an
/// `output-stream` child resource, and the completion of the body (with
/// optional trailers) with a static function that consumes the
/// `outgoing-body` resource, and ensures that the user of this interface
/// may not write to the body contents after the body has been finished.
///
/// If the user code drops this resource, as opposed to calling the static
/// method `finish`, the implementation should treat the body as incomplete,
/// and that an error has occurred. The implementation should propagate this
/// error to the HTTP protocol by whatever means it has available,
/// including: corrupting the body on the wire, aborting the associated
/// Request, or sending a late status code for the Response.
pub(all) type OutgoingBody Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingBody::drop(self : OutgoingBody) -> Unit {
  let OutgoingBody(resource) = self
  wasmImportResourceDropOutgoingBody(resource)
}

///| Represents a future which may eventually return an incoming HTTP
/// Response, or an error.
///
/// This resource is returned by the `wasi:http/outgoing-handler` interface to
/// provide the HTTP Response corresponding to the sent Request.
pub(all) type FutureIncomingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn FutureIncomingResponse::drop(self : FutureIncomingResponse) -> Unit {
  let FutureIncomingResponse(resource) = self
  wasmImportResourceDropFutureIncomingResponse(resource)
}

///| Attempts to extract a http-related `error` from the wasi:io `error`
/// provided.
///
/// Stream operations which return
/// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
/// type `wasi:io/error/error` with more information about the operation
/// that failed. This payload can be passed through to this function to see
/// if there's http-related information about the error to return.
///
/// Note that this function is fallible because not all io-errors are
/// http-related errors.
pub fn http_error_code(err : @error.Error_) -> ErrorCode? {
  let @error.Error_(handle) = err
  let return_area = @ffi.malloc(40)
  wasmImportHttpErrorCode(handle, return_area)
  let lifted198 : ErrorCode? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted197 = match @ffi.load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted14 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted14,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted45 : Byte? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(@ffi.load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted51 : String? = match @ffi.load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 28))
              let result50 = @ffi.ptr2str(@ffi.load32(return_area + 24))
              Option::Some(result50)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted45,
            alert_message: lifted51,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted62 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted62)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted75 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted75)
        }
        22 => {
          let lifted93 : FieldSizePayload? = match
            @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted87 : String? = match @ffi.load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  ignore(@ffi.load32(return_area + 28))
                  let result86 = @ffi.ptr2str(@ffi.load32(return_area + 24))
                  Option::Some(result86)
                }
                _ => panic()
              }
              let lifted92 : UInt? = match @ffi.load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    @ffi.load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted87,
                field_size: lifted92,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted93)
        }
        23 => {
          let lifted100 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted100)
        }
        24 => {
          let lifted108 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result107 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result107)
            }
            _ => panic()
          }
          let lifted113 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted108,
            field_size: lifted113,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted122 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted122)
        }
        27 => {
          let lifted130 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result129 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result129)
            }
            _ => panic()
          }
          let lifted135 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted130,
            field_size: lifted135,
          })
        }
        28 => {
          let lifted142 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted142)
        }
        29 => {
          let lifted149 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted149)
        }
        30 => {
          let lifted157 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result156 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result156)
            }
            _ => panic()
          }
          let lifted162 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted157,
            field_size: lifted162,
          })
        }
        31 => {
          let lifted170 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result169 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result169)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted170)
        }
        32 => {
          let lifted178 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result177 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result177)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted178)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted196 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result195 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result195)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted196)
        }
        _ => panic()
      }
      Option::Some(lifted197)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted198
}

///| Construct an empty HTTP Fields.
///
/// The resulting `fields` is mutable.
pub fn Fields::fields() -> Fields {
  let result : Int = wasmImportConstructorFields()
  return Fields::Fields(result)
}

///| Construct an HTTP Fields.
///
/// The resulting `fields` is mutable.
///
/// The list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
///
/// The tuple is a pair of the field key, represented as a string, and
/// Value, represented as a list of bytes.
///
/// An error result will be returned if any `field-key` or `field-value` is
/// syntactically invalid, or if a field is forbidden.
pub fn Fields::from_list(
  entries : Array[(String, FixedArray[Byte])]
) -> Result[Fields, HeaderError] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let address = @ffi.malloc(entries.length() * 16)
  for index = 0; index < entries.length(); index = index + 1 {
    let element : (String, FixedArray[Byte]) = entries[index]
    let base = address + index * 16
    @ffi.store32(base + 4, element.0.iter().count())
    @ffi.store32(base + 0, @ffi.str2ptr(element.0))
    @ffi.store32(base + 12, element.1.length())
    @ffi.store32(base + 8, @ffi.bytes2ptr(element.1))
    ignoreList.push(element.0)
    ignoreList.push(element.1)
  }
  let return_area = @ffi.malloc(8)
  wasmImportStaticFieldsFromList(address, entries.length(), return_area)
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(Fields::Fields(@ffi.load32(return_area + 4)))
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted10
}

///| Get all of the values corresponding to a key. If the key is not present
/// in this `fields` or is syntactically invalid, an empty list is returned.
/// However, if the key is present but empty, this is represented by a list
/// with one or more empty field-values present.
pub fn Fields::get(self : Fields, name : String) -> Array[FixedArray[Byte]] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodFieldsGet(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    return_area,
  )
  let array : Array[FixedArray[Byte]] = []
  for index = 0; index < @ffi.load32(return_area + 4); index = index + 1 {
    let base = @ffi.load32(return_area + 0) + index * 8
    let result = @ffi.ptr2bytes(@ffi.load32(base + 0), @ffi.load32(base + 4))
    array.push(result)
  }
  @ffi.free(@ffi.load32(return_area + 0))
  ignore(name)
  @ffi.free(return_area)
  return array
}

///| Returns `true` when the key is present in this `fields`. If the key is
/// syntactically invalid, `false` is returned.
pub fn Fields::has(self : Fields, name : String) -> Bool {
  let Fields(handle) = self
  let result : Int = wasmImportMethodFieldsHas(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
  )
  ignore(name)
  return result != 0
}

///| Set all of the values for a key. Clears any existing values for that
/// key, if they have been set.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or any of
/// the `field-value`s are syntactically invalid.
pub fn Fields::set(
  self : Fields,
  name : String,
  value : Array[FixedArray[Byte]]
) -> Result[Unit, HeaderError] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let Fields(handle) = self
  let address = @ffi.malloc(value.length() * 8)
  for index = 0; index < value.length(); index = index + 1 {
    let element : FixedArray[Byte] = value[index]
    let base = address + index * 8
    @ffi.store32(base + 4, element.length())
    @ffi.store32(base + 0, @ffi.bytes2ptr(element))
    ignoreList.push(element)
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsSet(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    address,
    value.length(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted10
}

///| Delete all values for a key. Does nothing if no values for the key
/// exist.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` is
/// syntactically invalid.
pub fn Fields::delete(
  self : Fields,
  name : String
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsDelete(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    return_area,
  )
  let lifted8 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  @ffi.free(return_area)
  return lifted8
}

///| Append a value for a key. Does not change or delete any existing
/// values for that key.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or
/// `field-value` are syntactically invalid.
pub fn Fields::append(
  self : Fields,
  name : String,
  value : FixedArray[Byte]
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsAppend(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    @ffi.bytes2ptr(value),
    value.length(),
    return_area,
  )
  let lifted8 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  ignore(value)
  @ffi.free(return_area)
  return lifted8
}

///| Retrieve the full set of keys and values in the Fields. Like the
/// constructor, the list represents each key-value pair.
///
/// The outer list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
pub fn Fields::entries(self : Fields) -> Array[(String, FixedArray[Byte])] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodFieldsEntries(handle, return_area)
  let array : Array[(String, FixedArray[Byte])] = []
  for index = 0; index < @ffi.load32(return_area + 4); index = index + 1 {
    let base = @ffi.load32(return_area + 0) + index * 16
    ignore(@ffi.load32(base + 4))
    let result = @ffi.ptr2str(@ffi.load32(base + 0))
    let result0 = @ffi.ptr2bytes(@ffi.load32(base + 8), @ffi.load32(base + 12))
    array.push((result, result0))
  }
  @ffi.free(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return array
}

///| Make a deep copy of the Fields. Equivalent in behavior to calling the
/// `fields` constructor on the return value of `entries`. The resulting
/// `fields` is mutable.
pub fn Fields::clone(self : Fields) -> Fields {
  let Fields(handle) = self
  let result : Int = wasmImportMethodFieldsClone(handle)
  return Fields::Fields(result)
}

///| Returns the method of the incoming request.
pub fn IncomingRequest::method_(self : IncomingRequest) -> Method {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestMethod(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Method::Other(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the path with query parameters from the request, as a string.
pub fn IncomingRequest::path_with_query(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the protocol scheme from the request.
pub fn IncomingRequest::scheme(self : IncomingRequest) -> Scheme? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodIncomingRequestScheme(handle, return_area)
  let lifted8 : Scheme? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          ignore(@ffi.load32(return_area + 12))
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted8
}

///| Returns the authority of the Request's target URI, if present.
pub fn IncomingRequest::authority(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestAuthority(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the `headers` associated with the request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// The `headers` returned are a child resource: it must be dropped before
/// the parent `incoming-request` is dropped. Dropping this
/// `incoming-request` before all children are dropped will trap.
pub fn IncomingRequest::headers(self : IncomingRequest) -> Fields {
  let IncomingRequest(handle) = self
  let result : Int = wasmImportMethodIncomingRequestHeaders(handle)
  return Fields::Fields(result)
}

///| Gives the `incoming-body` associated with this request. Will only
/// return success at most once, and subsequent calls will return error.
pub fn IncomingRequest::consume(
  self : IncomingRequest
) -> Result[IncomingBody, Unit] {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingRequestConsume(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Construct a new `outgoing-request` with a default `method` of `GET`, and
/// `none` values for `path-with-query`, `scheme`, and `authority`.
///
/// * `headers` is the HTTP Headers for the Request.
///
/// It is possible to construct, or manipulate with the accessor functions
/// below, an `outgoing-request` with an invalid combination of `scheme`
/// and `authority`, or `headers` which are not permitted to be sent.
/// It is the obligation of the `outgoing-handler.handle` implementation
/// to reject invalid constructions of `outgoing-request`.
pub fn OutgoingRequest::outgoing_request(headers : Fields) -> OutgoingRequest {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingRequest(handle)
  return OutgoingRequest::OutgoingRequest(result)
}

///| Returns the resource corresponding to the outgoing Body for this
/// Request.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-request` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingRequest::body(
  self : OutgoingRequest
) -> Result[OutgoingBody, Unit] {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingRequestBody(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the Method for the Request.
pub fn OutgoingRequest::method_(self : OutgoingRequest) -> Method {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestMethod(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Method::Other(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the Method for the Request. Fails if the string present in a
/// `method.other` argument is not a syntactically valid method.
pub fn OutgoingRequest::set_method(
  self : OutgoingRequest,
  method_ : Method
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered27, lowered28) = match method_ {
    Get => (0, 0, 0)
    Head => (1, 0, 0)
    Post => (2, 0, 0)
    Put => (3, 0, 0)
    Delete => (4, 0, 0)
    Connect => (5, 0, 0)
    Options => (6, 0, 0)
    Trace => (7, 0, 0)
    Patch => (8, 0, 0)
    Other(payload26) => {
      ignoreList.push(payload26)
      (9, @ffi.str2ptr(payload26), payload26.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetMethod(
    handle, lowered, lowered27, lowered28,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query.
pub fn OutgoingRequest::path_with_query(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query. Fails is the
/// string given is not a syntactically valid path and query uri component.
pub fn OutgoingRequest::set_path_with_query(
  self : OutgoingRequest,
  path_with_query : String?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered3, lowered4) = match path_with_query {
    None => (0, 0, 0)
    Some(payload2) => {
      ignoreList.push(payload2)
      (1, @ffi.str2ptr(payload2), payload2.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetPathWithQuery(
    handle, lowered, lowered3, lowered4,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme.
pub fn OutgoingRequest::scheme(self : OutgoingRequest) -> Scheme? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutgoingRequestScheme(handle, return_area)
  let lifted8 : Scheme? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          ignore(@ffi.load32(return_area + 12))
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted8
}

///| Set the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme. Fails if the
/// string given is not a syntactically valid uri scheme.
pub fn OutgoingRequest::set_scheme(
  self : OutgoingRequest,
  scheme : Scheme?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered14, lowered15, lowered16, lowered17) = match scheme {
    None => (0, 0, 0, 0)
    Some(payload2) => {
      let (lowered, lowered12, lowered13) = match payload2 {
        Http => (0, 0, 0)
        Https => (1, 0, 0)
        Other(payload11) => {
          ignoreList.push(payload11)
          (2, @ffi.str2ptr(payload11), payload11.iter().count())
        }
      }
      (1, lowered, lowered12, lowered13)
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetScheme(
    handle, lowered14, lowered15, lowered16, lowered17,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority.
pub fn OutgoingRequest::authority(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestAuthority(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority. Fails if the string given is
/// not a syntactically valid URI authority.
pub fn OutgoingRequest::set_authority(
  self : OutgoingRequest,
  authority : String?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered3, lowered4) = match authority {
    None => (0, 0, 0)
    Some(payload2) => {
      ignoreList.push(payload2)
      (1, @ffi.str2ptr(payload2), payload2.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetAuthority(
    handle, lowered, lowered3, lowered4,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingRequest::headers(self : OutgoingRequest) -> Fields {
  let OutgoingRequest(handle) = self
  let result : Int = wasmImportMethodOutgoingRequestHeaders(handle)
  return Fields::Fields(result)
}

///| Construct a default `request-options` value.
pub fn RequestOptions::request_options() -> RequestOptions {
  let result : Int = wasmImportConstructorRequestOptions()
  return RequestOptions::RequestOptions(result)
}

///| The timeout for the initial connect to the HTTP Server.
pub fn RequestOptions::connect_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsConnectTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for the initial connect to the HTTP Server. An error
/// return value indicates that this timeout is not supported.
pub fn RequestOptions::set_connect_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetConnectTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| The timeout for receiving the first byte of the Response body.
pub fn RequestOptions::first_byte_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsFirstByteTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for receiving the first byte of the Response body. An
/// error return value indicates that this timeout is not supported.
pub fn RequestOptions::set_first_byte_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetFirstByteTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| The timeout for receiving subsequent chunks of bytes in the Response
/// body stream.
pub fn RequestOptions::between_bytes_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsBetweenBytesTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for receiving subsequent chunks of bytes in the Response
/// body stream. An error return value indicates that this timeout is not
/// supported.
pub fn RequestOptions::set_between_bytes_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetBetweenBytesTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| Set the value of the `response-outparam` to either send a response,
/// or indicate an error.
///
/// This method consumes the `response-outparam` to ensure that it is
/// called at most once. If it is never called, the implementation
/// will respond with an error.
///
/// The user may provide an `error` to `response` to allow the
/// implementation determine how to respond with an HTTP error response.
pub fn ResponseOutparam::set(
  param : ResponseOutparam,
  response : Result[OutgoingResponse, ErrorCode]
) -> Unit {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let ResponseOutparam(handle) = param
  let (
    lowered316,
    lowered317,
    lowered318,
    lowered319,
    lowered320,
    lowered321,
    lowered322,
    lowered323,
  ) = match response {
    Ok(payload) => {
      let OutgoingResponse(handle0) = payload
      (0, handle0, 0, 0L, 0, 0, 0, 0)
    }
    Err(payload3) => {
      let (
        lowered309,
        lowered310,
        lowered311,
        lowered312,
        lowered313,
        lowered314,
        lowered315,
      ) = match payload3 {
        DnsTimeout => (0, 0, 0L, 0, 0, 0, 0)
        DnsError(payload9) => {
          let (lowered, lowered16, lowered17) = match payload9.rcode {
            None => (0, 0, 0)
            Some(payload15) => {
              ignoreList.push(payload15)
              (1, @ffi.str2ptr(payload15), payload15.iter().count())
            }
          }
          let (lowered24, lowered25) = match payload9.info_code {
            None => (0, 0)
            Some(payload23) => (1, payload23.reinterpret_as_int())
          }
          (
            1,
            lowered,
            Int::to_int64(lowered16),
            lowered17,
            lowered24,
            lowered25,
            0,
          )
        }
        DestinationNotFound => (2, 0, 0L, 0, 0, 0, 0)
        DestinationUnavailable => (3, 0, 0L, 0, 0, 0, 0)
        DestinationIpProhibited => (4, 0, 0L, 0, 0, 0, 0)
        DestinationIpUnroutable => (5, 0, 0L, 0, 0, 0, 0)
        ConnectionRefused => (6, 0, 0L, 0, 0, 0, 0)
        ConnectionTerminated => (7, 0, 0L, 0, 0, 0, 0)
        ConnectionTimeout => (8, 0, 0L, 0, 0, 0, 0)
        ConnectionReadTimeout => (9, 0, 0L, 0, 0, 0, 0)
        ConnectionWriteTimeout => (10, 0, 0L, 0, 0, 0, 0)
        ConnectionLimitReached => (11, 0, 0L, 0, 0, 0, 0)
        TlsProtocolError => (12, 0, 0L, 0, 0, 0, 0)
        TlsCertificateError => (13, 0, 0L, 0, 0, 0, 0)
        TlsAlertReceived(payload64) => {
          let (lowered71, lowered72) = match payload64.alert_id {
            None => (0, 0)
            Some(payload70) => (1, payload70.to_int())
          }
          let (lowered79, lowered80, lowered81) = match
            payload64.alert_message {
            None => (0, 0, 0)
            Some(payload78) => {
              ignoreList.push(payload78)
              (1, @ffi.str2ptr(payload78), payload78.iter().count())
            }
          }
          (
            14,
            lowered71,
            Int::to_int64(lowered72),
            lowered79,
            lowered80,
            lowered81,
            0,
          )
        }
        HttpRequestDenied => (15, 0, 0L, 0, 0, 0, 0)
        HttpRequestLengthRequired => (16, 0, 0L, 0, 0, 0, 0)
        HttpRequestBodySize(payload90) => {
          let (lowered97, lowered98) = match payload90 {
            None => (0, 0L)
            Some(payload96) => (1, payload96.reinterpret_as_int64())
          }
          (17, lowered97, lowered98, 0, 0, 0, 0)
        }
        HttpRequestMethodInvalid => (18, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriInvalid => (19, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriTooLong => (20, 0, 0L, 0, 0, 0, 0)
        HttpRequestHeaderSectionSize(payload110) => {
          let (lowered117, lowered118) = match payload110 {
            None => (0, 0)
            Some(payload116) => (1, payload116.reinterpret_as_int())
          }
          (21, lowered117, Int::to_int64(lowered118), 0, 0, 0, 0)
        }
        HttpRequestHeaderSize(payload121) => {
          let (
            lowered145,
            lowered146,
            lowered147,
            lowered148,
            lowered149,
            lowered150,
          ) = match payload121 {
            None => (0, 0, 0, 0, 0, 0)
            Some(payload127) => {
              let (lowered134, lowered135, lowered136) = match
                payload127.field_name {
                None => (0, 0, 0)
                Some(payload133) => {
                  ignoreList.push(payload133)
                  (1, @ffi.str2ptr(payload133), payload133.iter().count())
                }
              }
              let (lowered143, lowered144) = match payload127.field_size {
                None => (0, 0)
                Some(payload142) => (1, payload142.reinterpret_as_int())
              }
              (1, lowered134, lowered135, lowered136, lowered143, lowered144)
            }
          }
          (
            22,
            lowered145,
            Int::to_int64(lowered146),
            lowered147,
            lowered148,
            lowered149,
            lowered150,
          )
        }
        HttpRequestTrailerSectionSize(payload153) => {
          let (lowered160, lowered161) = match payload153 {
            None => (0, 0)
            Some(payload159) => (1, payload159.reinterpret_as_int())
          }
          (23, lowered160, Int::to_int64(lowered161), 0, 0, 0, 0)
        }
        HttpRequestTrailerSize(payload164) => {
          let (lowered171, lowered172, lowered173) = match
            payload164.field_name {
            None => (0, 0, 0)
            Some(payload170) => {
              ignoreList.push(payload170)
              (1, @ffi.str2ptr(payload170), payload170.iter().count())
            }
          }
          let (lowered180, lowered181) = match payload164.field_size {
            None => (0, 0)
            Some(payload179) => (1, payload179.reinterpret_as_int())
          }
          (
            24,
            lowered171,
            Int::to_int64(lowered172),
            lowered173,
            lowered180,
            lowered181,
            0,
          )
        }
        HttpResponseIncomplete => (25, 0, 0L, 0, 0, 0, 0)
        HttpResponseHeaderSectionSize(payload187) => {
          let (lowered194, lowered195) = match payload187 {
            None => (0, 0)
            Some(payload193) => (1, payload193.reinterpret_as_int())
          }
          (26, lowered194, Int::to_int64(lowered195), 0, 0, 0, 0)
        }
        HttpResponseHeaderSize(payload198) => {
          let (lowered205, lowered206, lowered207) = match
            payload198.field_name {
            None => (0, 0, 0)
            Some(payload204) => {
              ignoreList.push(payload204)
              (1, @ffi.str2ptr(payload204), payload204.iter().count())
            }
          }
          let (lowered214, lowered215) = match payload198.field_size {
            None => (0, 0)
            Some(payload213) => (1, payload213.reinterpret_as_int())
          }
          (
            27,
            lowered205,
            Int::to_int64(lowered206),
            lowered207,
            lowered214,
            lowered215,
            0,
          )
        }
        HttpResponseBodySize(payload218) => {
          let (lowered225, lowered226) = match payload218 {
            None => (0, 0L)
            Some(payload224) => (1, payload224.reinterpret_as_int64())
          }
          (28, lowered225, lowered226, 0, 0, 0, 0)
        }
        HttpResponseTrailerSectionSize(payload229) => {
          let (lowered236, lowered237) = match payload229 {
            None => (0, 0)
            Some(payload235) => (1, payload235.reinterpret_as_int())
          }
          (29, lowered236, Int::to_int64(lowered237), 0, 0, 0, 0)
        }
        HttpResponseTrailerSize(payload240) => {
          let (lowered247, lowered248, lowered249) = match
            payload240.field_name {
            None => (0, 0, 0)
            Some(payload246) => {
              ignoreList.push(payload246)
              (1, @ffi.str2ptr(payload246), payload246.iter().count())
            }
          }
          let (lowered256, lowered257) = match payload240.field_size {
            None => (0, 0)
            Some(payload255) => (1, payload255.reinterpret_as_int())
          }
          (
            30,
            lowered247,
            Int::to_int64(lowered248),
            lowered249,
            lowered256,
            lowered257,
            0,
          )
        }
        HttpResponseTransferCoding(payload260) => {
          let (lowered267, lowered268, lowered269) = match payload260 {
            None => (0, 0, 0)
            Some(payload266) => {
              ignoreList.push(payload266)
              (1, @ffi.str2ptr(payload266), payload266.iter().count())
            }
          }
          (31, lowered267, Int::to_int64(lowered268), lowered269, 0, 0, 0)
        }
        HttpResponseContentCoding(payload272) => {
          let (lowered279, lowered280, lowered281) = match payload272 {
            None => (0, 0, 0)
            Some(payload278) => {
              ignoreList.push(payload278)
              (1, @ffi.str2ptr(payload278), payload278.iter().count())
            }
          }
          (32, lowered279, Int::to_int64(lowered280), lowered281, 0, 0, 0)
        }
        HttpResponseTimeout => (33, 0, 0L, 0, 0, 0, 0)
        HttpUpgradeFailed => (34, 0, 0L, 0, 0, 0, 0)
        HttpProtocolError => (35, 0, 0L, 0, 0, 0, 0)
        LoopDetected => (36, 0, 0L, 0, 0, 0, 0)
        ConfigurationError => (37, 0, 0L, 0, 0, 0, 0)
        InternalError(payload299) => {
          let (lowered306, lowered307, lowered308) = match payload299 {
            None => (0, 0, 0)
            Some(payload305) => {
              ignoreList.push(payload305)
              (1, @ffi.str2ptr(payload305), payload305.iter().count())
            }
          }
          (38, lowered306, Int::to_int64(lowered307), lowered308, 0, 0, 0)
        }
      }
      (
        1, lowered309, lowered310, lowered311, lowered312, lowered313, lowered314,
        lowered315,
      )
    }
  }
  wasmImportStaticResponseOutparamSet(
    handle, lowered316, lowered317, lowered318, lowered319, lowered320, lowered321,
    lowered322, lowered323,
  )
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
}

///| Returns the status code from the incoming response.
pub fn IncomingResponse::status(self : IncomingResponse) -> UInt {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseStatus(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///| Returns the headers from the incoming response.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `incoming-response` is dropped.
pub fn IncomingResponse::headers(self : IncomingResponse) -> Fields {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseHeaders(handle)
  return Fields::Fields(result)
}

///| Returns the incoming body. May be called at most once. Returns error
/// if called additional times.
pub fn IncomingResponse::consume(
  self : IncomingResponse
) -> Result[IncomingBody, Unit] {
  let IncomingResponse(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingResponseConsume(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the contents of the body, as a stream of bytes.
///
/// Returns success on first call: the stream representing the contents
/// can be retrieved at most once. Subsequent calls will return error.
///
/// The returned `input-stream` resource is a child: it must be dropped
/// before the parent `incoming-body` is dropped, or consumed by
/// `incoming-body.finish`.
///
/// This invariant ensures that the implementation can determine whether
/// the user is consuming the contents of the body, waiting on the
/// `future-trailers` to be ready, or neither. This allows for network
/// backpressure is to be applied when the user is consuming the body,
/// and for that backpressure to not inhibit delivery of the trailers if
/// the user does not read the entire body.
pub fn IncomingBody::stream(
  self : IncomingBody
) -> Result[@streams.InputStream, Unit] {
  let IncomingBody(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingBodyStream(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.InputStream::InputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Takes ownership of `incoming-body`, and returns a `future-trailers`.
/// This function will trap if the `input-stream` child is still alive.
pub fn IncomingBody::finish(this : IncomingBody) -> FutureTrailers {
  let IncomingBody(handle) = this
  let result : Int = wasmImportStaticIncomingBodyFinish(handle)
  return FutureTrailers::FutureTrailers(result)
}

///| Returns a pollable which becomes ready when either the trailers have
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureTrailers::subscribe(self : FutureTrailers) -> @poll.Pollable {
  let FutureTrailers(handle) = self
  let result : Int = wasmImportMethodFutureTrailersSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Returns the contents of the trailers, or an error which occurred,
/// once the future is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the trailers or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the HTTP Request or Response
/// body, as well as any trailers, were received successfully, or that an
/// error occurred receiving them. The optional `trailers` indicates whether
/// or not trailers were present in the body.
///
/// When some `trailers` are returned by this method, the `trailers`
/// resource is immutable, and a child. Use of the `set`, `append`, or
/// `delete` methods will return an error, and the resource must be
/// dropped before the parent `future-trailers` is dropped.
pub fn FutureTrailers::get(
  self : FutureTrailers
) -> Result[Result[Fields?, ErrorCode], Unit]? {
  let FutureTrailers(handle) = self
  let return_area = @ffi.malloc(56)
  wasmImportMethodFutureTrailersGet(handle, return_area)
  let lifted213 : Result[Result[Fields?, ErrorCode], Unit]? = match
    @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted212 = match @ffi.load8_u(return_area + 8) {
        0 => {
          let lifted209 = match @ffi.load8_u(return_area + 16) {
            0 => {
              let lifted : Fields? = match @ffi.load8_u(return_area + 24) {
                0 => Option::None
                1 => Option::Some(Fields::Fields(@ffi.load32(return_area + 28)))
                _ => panic()
              }
              Result::Ok(lifted)
            }
            1 => {
              let lifted208 = match @ffi.load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted20 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result = @ffi.ptr2str(@ffi.load32(return_area + 36))
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted25 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted20,
                    info_code: lifted25,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted56 : Byte? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => Option::Some(@ffi.load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted62 : String? = match
                    @ffi.load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 44))
                      let result61 = @ffi.ptr2str(@ffi.load32(return_area + 40))
                      Option::Some(result61)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted56,
                    alert_message: lifted62,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted73 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted73)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted86 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted86)
                }
                22 => {
                  let lifted104 : FieldSizePayload? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted98 : String? = match
                        @ffi.load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          ignore(@ffi.load32(return_area + 44))
                          let result97 = @ffi.ptr2str(
                            @ffi.load32(return_area + 40),
                          )
                          Option::Some(result97)
                        }
                        _ => panic()
                      }
                      let lifted103 : UInt? = match
                        @ffi.load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            @ffi.load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted98,
                        field_size: lifted103,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted104)
                }
                23 => {
                  let lifted111 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted111)
                }
                24 => {
                  let lifted119 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result118 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result118)
                    }
                    _ => panic()
                  }
                  let lifted124 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted119,
                    field_size: lifted124,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted133 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted133)
                }
                27 => {
                  let lifted141 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result140 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result140)
                    }
                    _ => panic()
                  }
                  let lifted146 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted141,
                    field_size: lifted146,
                  })
                }
                28 => {
                  let lifted153 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted153)
                }
                29 => {
                  let lifted160 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted160)
                }
                30 => {
                  let lifted168 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result167 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result167)
                    }
                    _ => panic()
                  }
                  let lifted173 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted168,
                    field_size: lifted173,
                  })
                }
                31 => {
                  let lifted181 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result180 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result180)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted181)
                }
                32 => {
                  let lifted189 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result188 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result188)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted189)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted207 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result206 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result206)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted207)
                }
                _ => panic()
              }
              Result::Err(lifted208)
            }
            _ => panic()
          }
          Result::Ok(lifted209)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted212)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted213
}

///| Construct an `outgoing-response`, with a default `status-code` of `200`.
/// If a different `status-code` is needed, it must be set via the
/// `set-status-code` method.
///
/// * `headers` is the HTTP Headers for the Response.
pub fn OutgoingResponse::outgoing_response(
  headers : Fields
) -> OutgoingResponse {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingResponse(handle)
  return OutgoingResponse::OutgoingResponse(result)
}

///| Get the HTTP Status Code for the Response.
pub fn OutgoingResponse::status_code(self : OutgoingResponse) -> UInt {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseStatusCode(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///| Set the HTTP Status Code for the Response. Fails if the status-code
/// given is not a valid http status code.
pub fn OutgoingResponse::set_status_code(
  self : OutgoingResponse,
  status_code : UInt
) -> Result[Unit, Unit] {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseSetStatusCode(
    handle,
    status_code.reinterpret_as_int(),
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingResponse::headers(self : OutgoingResponse) -> Fields {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseHeaders(handle)
  return Fields::Fields(result)
}

///| Returns the resource corresponding to the outgoing Body for this Response.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-response` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingResponse::body(
  self : OutgoingResponse
) -> Result[OutgoingBody, Unit] {
  let OutgoingResponse(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingResponseBody(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns a stream for writing the body contents.
///
/// The returned `output-stream` is a child resource: it must be dropped
/// before the parent `outgoing-body` resource is dropped (or finished),
/// otherwise the `outgoing-body` drop or `finish` will trap.
///
/// Returns success on the first call: the `output-stream` resource for
/// this `outgoing-body` may be retrieved at most once. Subsequent calls
/// will return error.
pub fn OutgoingBody::write(
  self : OutgoingBody
) -> Result[@streams.OutputStream, Unit] {
  let OutgoingBody(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingBodyWrite(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Finalize an outgoing body, optionally providing trailers. This must be
/// called to signal that the response is complete. If the `outgoing-body`
/// is dropped without calling `outgoing-body.finalize`, the implementation
/// should treat the body as corrupted.
///
/// Fails if the body's `outgoing-request` or `outgoing-response` was
/// constructed with a Content-Length header, and the contents written
/// to the body (via `write`) does not match the value given in the
/// Content-Length.
pub fn OutgoingBody::finish(
  this : OutgoingBody,
  trailers : Fields?
) -> Result[Unit, ErrorCode] {
  let OutgoingBody(handle) = this
  let (lowered, lowered4) = match trailers {
    None => (0, 0)
    Some(payload2) => {
      let Fields(handle3) = payload2
      (1, handle3)
    }
  }
  let return_area = @ffi.malloc(40)
  wasmImportStaticOutgoingBodyFinish(handle, lowered, lowered4, return_area)
  let lifted205 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted204 = match @ffi.load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted21 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted21,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted52 : Byte? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(@ffi.load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted58 : String? = match @ffi.load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 28))
              let result57 = @ffi.ptr2str(@ffi.load32(return_area + 24))
              Option::Some(result57)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted52,
            alert_message: lifted58,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted69 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted69)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted82 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted82)
        }
        22 => {
          let lifted100 : FieldSizePayload? = match
            @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted94 : String? = match @ffi.load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  ignore(@ffi.load32(return_area + 28))
                  let result93 = @ffi.ptr2str(@ffi.load32(return_area + 24))
                  Option::Some(result93)
                }
                _ => panic()
              }
              let lifted99 : UInt? = match @ffi.load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    @ffi.load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted94,
                field_size: lifted99,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted100)
        }
        23 => {
          let lifted107 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted107)
        }
        24 => {
          let lifted115 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result114 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result114)
            }
            _ => panic()
          }
          let lifted120 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted115,
            field_size: lifted120,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted129 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted129)
        }
        27 => {
          let lifted137 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result136 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result136)
            }
            _ => panic()
          }
          let lifted142 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted137,
            field_size: lifted142,
          })
        }
        28 => {
          let lifted149 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted149)
        }
        29 => {
          let lifted156 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted156)
        }
        30 => {
          let lifted164 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result163 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result163)
            }
            _ => panic()
          }
          let lifted169 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted164,
            field_size: lifted169,
          })
        }
        31 => {
          let lifted177 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result176 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result176)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted177)
        }
        32 => {
          let lifted185 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result184 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result184)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted185)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted203 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result202 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result202)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted203)
        }
        _ => panic()
      }
      Result::Err(lifted204)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted205
}

///| Returns a pollable which becomes ready when either the Response has
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureIncomingResponse::subscribe(
  self : FutureIncomingResponse
) -> @poll.Pollable {
  let FutureIncomingResponse(handle) = self
  let result : Int = wasmImportMethodFutureIncomingResponseSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Returns the incoming HTTP Response, or an error, once one is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the response or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the incoming HTTP Response
/// status and headers have received successfully, or that an error
/// occurred. Errors may also occur while consuming the response body,
/// but those will be reported by the `incoming-body` and its
/// `output-stream` child.
pub fn FutureIncomingResponse::get(
  self : FutureIncomingResponse
) -> Result[Result[IncomingResponse, ErrorCode], Unit]? {
  let FutureIncomingResponse(handle) = self
  let return_area = @ffi.malloc(56)
  wasmImportMethodFutureIncomingResponseGet(handle, return_area)
  let lifted208 : Result[Result[IncomingResponse, ErrorCode], Unit]? = match
    @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted207 = match @ffi.load8_u(return_area + 8) {
        0 => {
          let lifted204 = match @ffi.load8_u(return_area + 16) {
            0 =>
              Result::Ok(
                IncomingResponse::IncomingResponse(
                  @ffi.load32(return_area + 24),
                ),
              )
            1 => {
              let lifted203 = match @ffi.load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted : String? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result = @ffi.ptr2str(@ffi.load32(return_area + 36))
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted20 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted,
                    info_code: lifted20,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted51 : Byte? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => Option::Some(@ffi.load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted57 : String? = match
                    @ffi.load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 44))
                      let result56 = @ffi.ptr2str(@ffi.load32(return_area + 40))
                      Option::Some(result56)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted51,
                    alert_message: lifted57,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted68 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted68)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted81 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted81)
                }
                22 => {
                  let lifted99 : FieldSizePayload? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted93 : String? = match
                        @ffi.load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          ignore(@ffi.load32(return_area + 44))
                          let result92 = @ffi.ptr2str(
                            @ffi.load32(return_area + 40),
                          )
                          Option::Some(result92)
                        }
                        _ => panic()
                      }
                      let lifted98 : UInt? = match
                        @ffi.load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            @ffi.load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted93,
                        field_size: lifted98,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted99)
                }
                23 => {
                  let lifted106 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted106)
                }
                24 => {
                  let lifted114 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result113 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result113)
                    }
                    _ => panic()
                  }
                  let lifted119 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted114,
                    field_size: lifted119,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted128 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted128)
                }
                27 => {
                  let lifted136 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result135 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result135)
                    }
                    _ => panic()
                  }
                  let lifted141 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted136,
                    field_size: lifted141,
                  })
                }
                28 => {
                  let lifted148 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted148)
                }
                29 => {
                  let lifted155 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted155)
                }
                30 => {
                  let lifted163 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result162 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result162)
                    }
                    _ => panic()
                  }
                  let lifted168 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted163,
                    field_size: lifted168,
                  })
                }
                31 => {
                  let lifted176 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result175 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result175)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted176)
                }
                32 => {
                  let lifted184 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result183 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result183)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted184)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted202 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result201 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result201)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted202)
                }
                _ => panic()
              }
              Result::Err(lifted203)
            }
            _ => panic()
          }
          Result::Ok(lifted204)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted207)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted208
}
