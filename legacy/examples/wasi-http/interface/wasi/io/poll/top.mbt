// Generated by `wit-bindgen` 0.48.1. DO NOT EDIT!

///|
/// `pollable` represents a single I/O event which may be ready, or not.
pub(all) struct Pollable(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn Pollable::drop(self : Pollable) -> Unit {
  let Pollable(resource) = self
  wasmImportResourceDropPollable(resource)
}

///|
/// Return the readiness of a pollable. This function never blocks.
///
/// Returns `true` when the pollable is ready, and `false` otherwise.
pub fn Pollable::ready(self : Pollable) -> Bool {
  let Pollable(handle) = self
  let result : Int = wasmImportMethodPollableReady(handle)
  return result != 0
}

///|
/// `block` returns immediately if the pollable is ready, and otherwise
/// blocks until ready.
///
/// This function is equivalent to calling `poll.poll` on a list
/// containing only this pollable.
pub fn Pollable::block(self : Pollable) -> Unit {
  let Pollable(handle) = self
  wasmImportMethodPollableBlock(handle)
}

///|
/// Poll for completion on a set of pollables.
///
/// This function takes a list of pollables, which identify I/O sources of
/// interest, and waits until one or more of the events is ready for I/O.
///
/// The result `list<u32>` contains one or more indices of handles in the
/// argument list that is ready for I/O.
///
/// This function traps if either:
/// - the list is empty, or:
/// - the list contains more elements than can be indexed with a `u32` value.
///
/// A timeout can be implemented by adding a pollable from the
/// wasi-clocks API to the list.
///
/// This function does not return a `result`; polling in itself does not
/// do any I/O so it doesn't fail. If any of the I/O sources identified by
/// the pollables has an error, it is indicated by marking the source as
/// being ready for I/O.
pub fn poll(in_ : Array[Pollable]) -> FixedArray[UInt] {
  let address = mbt_ffi_malloc(in_.length() * 4)
  for index = 0; index < in_.length(); index = index + 1 {
    let iter_elem : Pollable = in_[index]
    let iter_base = address + index * 4
    let Pollable(handle) = iter_elem
    mbt_ffi_store32(iter_base + 0, handle)
  }
  let return_area = mbt_ffi_malloc(8)
  wasmImportPoll(address, in_.length(), return_area)
  let result = mbt_ffi_ptr2uint_array(
    mbt_ffi_load32(return_area + 0),
    mbt_ffi_load32(return_area + 4),
  )
  mbt_ffi_free(address)
  mbt_ffi_free(return_area)
  return result
}
