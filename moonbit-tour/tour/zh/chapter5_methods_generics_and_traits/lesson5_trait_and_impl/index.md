# 特征

假如说方法定义了类型的行为，那么特征（trait）则总结了一组类型所共有的行为。在定义一个全新的
特征时，通常需要编写两个部分：

- 特征定义：使用`trait`关键字定义，它描述了特征所包含的方法签名。
- 特征实现：使用`impl`关键字为特定类型定义特征的实现。

在示例中，我们定义了一个`Equal`特征，它总结了一个`is_equal`方法：接受两个`Self`类型的参数，
`Self`类型表示实现该特征的具体类型；方法返回一个布尔值，在这里用来表示`Self`类型的两个值
是否相等。

我们分别为内建的`Int`类型和自己定义的`Pos`类型实现了`Equal`特征，提供了`is_equal`方法的具体实现。
因为特征定义已经声明过`is_equal`方法的类型，所以在实现中可以省略参数和返回值的类型标注。

在`main`函数中，通过`Equal::is_equal()`可以调用该特征总结的方法，根据传入的`a`、`b`类型，不同类型
会调用各自的实现版本。也就是说：

- 当`a`和`b`是`Int`类型时，执行的是`impl Int for Equal with is_equal`内的代码。
- 当`a`和`b`是`Pos`类型时，执行的是`impl Pos for Equal with is_equal`内的代码。

调用哪个实现版本是静态地决定的，没有运行时动态分派的开销。

## 限制

在为类型实现特征时，MoonBit 遵循**孤儿规则**（orphan rule）：`impl Type for Trait ...`实现必须和`Type`或`Trait`在同一个包，
而不允许孤立地存在于某个包中。
这一限制保证了特征实现的唯一性，避免了不同包中对同一类型和特征的重复实现引发冲突，或者因为其他包的变化而改变已有代码的行为。

## 用途

其实，在 MoonBit 的标准库的`moonbitlang/core/builtin`包中就定义了这样一个特征，名为`Eq`，
它总结了一个`equal`方法，用于比较两个值是否相等。并且标准库已经为许多内建类型实现了`Eq`特征，
比如`Int`、`Bool`、`Array`等。标准库还提供了`Show`特征，用于将值转换为字符串表示。
我们后续将会介绍这些特征的使用场景。

你可能会疑惑为什么要使用`trait`, 而不是直接分别为类型定义`is_equal`方法。
下一节我们将介绍特征的一个重要用途：*特征约束*。













