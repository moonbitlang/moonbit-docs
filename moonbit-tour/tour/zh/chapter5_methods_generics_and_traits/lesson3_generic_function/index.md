# 泛型与函数

泛型允许你为多种不同类型编写同一套代码，而无需重复相似的逻辑。

示例中给`Array[Int]`和`Array[Bool]`分别定义了`swap_int`和`swap_bool`函数，假如我们还要
交换`Array[String]`、`Array[Char]`中的元素，就不得不再写两个类似的函数！要是类型也可以像函
数参数一样，由调用者决定并传入就好了。

MoonBit 提供了**泛型**来实现这个功能，泛型参数使用`[]`包裹，可以定义多个泛型参数。对于函数来说，
泛型参数写在关键字`fn`后。示例中函数`swap`定义了一个泛型参数`T`，`T`在整个函数定义里使用了两次：

- 作为参数`arr`的元素类型：`arr : Array[T]`
- 作为局部变量`tmp`的类型：`let tmp : T = arr[0]`

这样，数组中的元素和`tmp`变量就拥有了相同的类型`T`，而`T`是什么类型由调用者决定。在`main`中
调用时，类型推导能够从传入的参数`array`推导出泛型参数`T`的具体类型，因此不需要显式地传入类型参数。


## 显示指定泛型参数类型

在大部分函数调用的场景，类型推导都能够推出泛型参数类型，因此 MoonBit 没有类似于其他语言中显式传入
泛型参数类型的语法。如果希望显示指定，可以通过增加额外的类型注解来实现，例如：

```moonbit
swap((arr : Array[Int]))
```

或者

```moonbit
let arr : Array[Int] = [1, 2]
swap(arr)
```






