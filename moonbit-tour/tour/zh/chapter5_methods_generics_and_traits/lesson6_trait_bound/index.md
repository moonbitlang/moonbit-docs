# 特征约束

在介绍泛型函数时，我们实现了一个`swap`函数：

```moonbit
fn[T] swap(arr : Array[T]) -> Unit {
  let tmp : T = arr[0]
  arr[0] = arr[1]
  arr[1] = tmp
}
```

`swap`函数只需要移动元素在数组中的位置, 它实际上无法对元素本身进行任何操作，
这是因为`T`对`swap`内部来说完全是未知的类型：我们不知道`T`支持什么方法，例如，比较两个元素是否相等，
或者打印元素的值用于调试。

我们可以通过**特征约束**（trait bounds）来为`T`增加一个类似于类型标注的标记，
语法为`T : Eq`，表示`T`必须实现`Eq`特征。一个泛型参数声明可以有多个特征约束，
例如`T : Eq + Show`，表示`T`必须实现`Eq`和`Show`。
这样就保证了我们可以在函数体内安全地使用这些特征的方法。

示例中改变了`swap`的行为：在交换元素之前，打印debug信息。`Show`特征包含了`to_string`方法，
因此可以对类型`T`的值调用`to_string`方法将其转换为字符串。或者直接在字符串插值中使用。

示例中还包含一个`find_index`函数，它尝试找到一个元素在数组中的位置。如果存在，返回该元素的索引，否则返回`None`。
为了比较数组中的元素和目标元素是否相等，我们为泛型参数`T`添加了`Eq`特征约束，从而可以调用`Eq::equal`方法进行比较。






