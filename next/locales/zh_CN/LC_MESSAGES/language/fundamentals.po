# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 11:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals.md:1
msgid "Fundamentals"
msgstr "基础"

#: ../../language/fundamentals.md:3
msgid "Built-in Data Structures"
msgstr "内置数据结构"

#: ../../language/fundamentals.md:5
msgid "Unit"
msgstr ""

#: ../../language/fundamentals.md:7
msgid ""
"`Unit` is a built-in type in MoonBit that represents the absence of a "
"meaningful value. It has only one value, written as `()`. `Unit` is similar "
"to `void` in languages like C/C++/Java, but unlike `void`, it is a real type"
" and can be used anywhere a type is expected."
msgstr ""
"`Unit` 是 MoonBit 中的一个内置类型，它表示没有有意义的值。它只有一个值，写作 `()`。`Unit` 类似于 C/C++/Java 中的"
" `void`，但与 `void` 不同的是，它是一个真正的类型，可以在任何需要类型的地方使用。"

#: ../../language/fundamentals.md:9
msgid ""
"The `Unit` type is commonly used as the return type for functions that "
"perform some action but do not produce a meaningful result:"
msgstr "`Unit` 类型通常用作执行某些操作但不产生有意义结果的函数的返回类型："

#: ../../language/fundamentals.md:11
msgid ""
"fn print_hello() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}"
msgstr ""

#: ../../language/fundamentals.md:18
msgid ""
"Unlike some other languages, MoonBit treats `Unit` as a first-class type, "
"allowing it to be used in generics, stored in data structures, and passed as"
" function arguments."
msgstr "与其他一些语言不同，MoonBit 将 `Unit` 视为一等类型，允许它在泛型中使用、存储在数据结构中以及作为函数参数传递。"

#: ../../language/fundamentals.md:20
msgid "Boolean"
msgstr "布尔值"

#: ../../language/fundamentals.md:22
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr "MoonBit 有一个内置的布尔类型，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。"

#: ../../language/fundamentals.md:24
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/fundamentals.md:31
msgid "Number"
msgstr "数字"

#: ../../language/fundamentals.md:33
msgid "MoonBit have integer type and floating point type:"
msgstr "MoonBit 有整数类型和浮点类型："

#: ../../language/fundamentals.md:24
msgid "type"
msgstr "类型"

#: ../../language/fundamentals.md:24 ../../language/fundamentals.md:135
#: ../../language/fundamentals.md:235
msgid "description"
msgstr "描述"

#: ../../language/fundamentals.md:24
msgid "example"
msgstr "示例"

#: ../../language/fundamentals.md:24
msgid "`Int16`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "16-bit signed integer"
msgstr "16 位有符号整数"

#: ../../language/fundamentals.md:24
msgid "`(42 : Int16)`"
msgstr ""

#: ../../language/fundamentals.md:24 ../../language/fundamentals.md:463
msgid "`Int`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "32-bit signed integer"
msgstr "32 位有符号整数"

#: ../../language/fundamentals.md:24
msgid "`42`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "`Int64`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "64-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:24
msgid "`1000L`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "`UInt16`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "16-bit unsigned integer"
msgstr "16 位无符号整数"

#: ../../language/fundamentals.md:24
msgid "`(14 : UInt16)`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "`UInt`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "32-bit unsigned integer"
msgstr "32 位无符号整数"

#: ../../language/fundamentals.md:24
msgid "`14U`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "`UInt64`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "64-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:24
msgid "`14UL`"
msgstr ""

#: ../../language/fundamentals.md:24 ../../language/fundamentals.md:463
msgid "`Double`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "64-bit floating point, defined by IEEE754"
msgstr "64 位浮点数，由 IEEE754 定义"

#: ../../language/fundamentals.md:24 ../../language/fundamentals.md:463
msgid "`3.14`"
msgstr ""

#: ../../language/fundamentals.md:24 ../../language/fundamentals.md:463
msgid "`Float`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "32-bit floating point"
msgstr "32 位浮点数"

#: ../../language/fundamentals.md:24
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:24
msgid "represents numeric values larger than other types"
msgstr "表示比其他类型更大的数值"

#: ../../language/fundamentals.md:24
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/fundamentals.md:47
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal, "
"and hexadecimal numbers."
msgstr "MoonBit 还支持数字字面量，包括十进制、二进制、八进制和十六进制数字。"

#: ../../language/fundamentals.md:49
msgid ""
"To improve readability, you may place underscores in the middle of numeric "
"literals such as `1_000_000`. Note that underscores can be placed anywhere "
"within a number, not just every three digits."
msgstr "为了提高可读性，您可以在数字字面量中间放置下划线，例如 `1_000_000`。请注意，下划线可以放在数字中的任何位置，而不仅仅是每三位数字。"

#: ../../language/fundamentals.md:51
msgid "Decimal numbers can have underscore between the numbers."
msgstr "十进制数之间可以有下划线。"

#: ../../language/fundamentals.md:53
msgid ""
"By default, an int literal is signed 32-bit number. For unsigned numbers, a "
"postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed."
msgstr "默认情况下，整数字面量是有符号的 32 位数字。对于无符号数字，需要后缀 `U`；对于 64 位数字，需要后缀 `L`。"

#: ../../language/fundamentals.md:55
msgid ""
"let a = 1234\n"
"let b : Int = 1_000_000 + a\n"
"let unsigned_num       : UInt   = 4_294_967_295U\n"
"let large_num          : Int64  = 9_223_372_036_854_775_807L\n"
"let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/fundamentals.md:62
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr "二进制数有一个前导零，后跟字母 \"B\"，即 `0b`/`0B`。请注意，`0b`/`0B` 后的数字必须是 `0` 或 `1`。"

#: ../../language/fundamentals.md:65
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/fundamentals.md:72
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from "
"`0` through `7`:"
msgstr "八进制数有一个前导零，后跟字母 \"O\"，即 `0o`/`0O`。请注意，`0o`/`0O` 后的数字必须在 `0` 到 `7` 的范围内："

#: ../../language/fundamentals.md:75
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/fundamentals.md:82
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""
"十六进制数有一个前导零，后跟字母 \"X\"，即 `0x`/`0X`。请注意，`0x`/`0X` 后的数字必须在 `0123456789ABCDEF` "
"范围内。"

#: ../../language/fundamentals.md:85
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA_B_C\n"
msgstr ""

#: ../../language/fundamentals.md:92
msgid ""
"A floating-point number literal is 64-bit floating-point number. To define a"
" float, type annotation is needed."
msgstr "浮点数字面量是 64 位浮点数。要定义一个浮点数，需要类型注释。"

#: ../../language/fundamentals.md:94
msgid ""
"let double = 3.14 // Double\n"
"let float : Float = 3.14\n"
"let float2 = (3.14 : Float)\n"
msgstr ""

#: ../../language/fundamentals.md:101
msgid "A 64-bit floating-point number can also be defined using hexadecimal format:"
msgstr "64 位浮点数也可以使用十六进制格式定义："

#: ../../language/fundamentals.md:103
msgid "let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9\n"
msgstr ""

#: ../../language/fundamentals.md:110
msgid ""
"When the expected type is known, MoonBit can automatically overload literal,"
" and there is no need to specify the type of number via letter postfix:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型："

#: ../../language/fundamentals.md:112
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/fundamentals.md:121 ../../language/fundamentals.md:188
#: ../../language/fundamentals.md:213 ../../language/fundamentals.md:275
#: ../../language/fundamentals.md:395 ../../language/fundamentals.md:436
#: ../../language/fundamentals.md:455
msgid "[Overloaded Literals](#overloaded-literals)"
msgstr "[重载字面量](#overloaded-literals)"

#: ../../language/fundamentals.md:124
msgid "String"
msgstr "字符串"

#: ../../language/fundamentals.md:126
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes to"
" create a string, or use `#|` to write a multi-line string."
msgstr "`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。"

#: ../../language/fundamentals.md:128
msgid ""
"let a = \"兔rabbit\"\n"
"println(a.code_unit_at(0).to_char())\n"
"println(a.code_unit_at(1).to_char())\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:169
#: ../../language/fundamentals.md:229 ../../language/fundamentals.md:290
#: ../../language/fundamentals.md:787 ../../language/fundamentals.md:801
#: ../../language/fundamentals.md:815 ../../language/fundamentals.md:829
#: ../../language/fundamentals.md:841 ../../language/fundamentals.md:858
#: ../../language/fundamentals.md:896 ../../language/fundamentals.md:943
#: ../../language/fundamentals.md:957 ../../language/fundamentals.md:1128
#: ../../language/fundamentals.md:1164 ../../language/fundamentals.md:1195
#: ../../language/fundamentals.md:1222 ../../language/fundamentals.md:1251
#: ../../language/fundamentals.md:1271 ../../language/fundamentals.md:1305
#: ../../language/fundamentals.md:1319
msgid "Output"
msgstr "输出"

#: ../../language/fundamentals.md:135
msgid ""
"Some('兔')\n"
"Some('r')\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/fundamentals.md:139
msgid ""
"In double quotes string, a backslash followed by certain special characters "
"forms an escape sequence:"
msgstr "在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列："

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:235
msgid "escape sequences"
msgstr "转义序列"

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:235
msgid "`\\n`, `\\r`, `\\t`, `\\b`"
msgstr ""

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:235
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr "换行，回车，水平制表符，退格"

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:235
msgid "`\\\\`"
msgstr "`\\\\`"

#: ../../language/fundamentals.md:135 ../../language/fundamentals.md:235
msgid "Backslash"
msgstr "反斜杠"

#: ../../language/fundamentals.md:135
msgid "`\\u5154` , `\\u{1F600}`"
msgstr "`\\u5154` , `\\u{1F600}`"

#: ../../language/fundamentals.md:135
msgid "Unicode escape sequence"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:147
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the process "
"of constructing dynamic strings by directly embedding variable values into "
"the text. Variables used for string interpolation must implement the [`Show`"
" trait](/language/methods.md#builtin-traits)."
msgstr ""
"MoonBit 支持字符串插值。它允许您在插值字符串中替换变量。此功能通过直接将变量值嵌入文本来简化构建动态字符串的过程。用于字符串插值的变量必须实现 "
"[`Show` 特征](/language/methods.md#builtin-traits)。"

#: ../../language/fundamentals.md:149
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/fundamentals.md:157
msgid "The interpolated expression can not contain newline, `{}` or `\"`."
msgstr "插值表达式不能包含换行符、`{}` 或 `\"`。"

#: ../../language/fundamentals.md:160
msgid ""
"Multi-line strings can be defined using the leading `#|` or `$|`, where the "
"former will keep the raw string and the former will perform the escape and "
"interpolation:"
msgstr "多行字符串可以使用前缀 `#|` 或 `$|` 定义，其中前者将保留原始字符串，后者将执行转义和插值："

#: ../../language/fundamentals.md:162
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/fundamentals.md:169
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/fundamentals.md:173
msgid ""
"The [VSCode extension](/toolchain/vscode/index.md#actions) can help you "
"switch between a plain text and the MoonBit's multiline string."
msgstr ""
"[VSCode 扩展](/toolchain/vscode/index.md#actions) 可以帮助您在纯文本和 MoonBit "
"的多行字符串之间切换。"

#: ../../language/fundamentals.md:175
msgid ""
"When the expected type is `String` , the array literal syntax is overloaded "
"to construct the `String` by specifying each character in the string."
msgstr "当期望类型是 `String` 时，数组字面量被重载为字符串。你可以通过单独列出每个字符来构造`String`。"

#: ../../language/fundamentals.md:178
msgid ""
"test {\n"
"  let c : Char = '中'\n"
"  let s : String = [c, '文']\n"
"  inspect(s, content=\"中文\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:186
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/string>"
msgstr ""

#: ../../language/fundamentals.md:191 ../../language/fundamentals.md:1401
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals.md:193
msgid "`Char` represents a Unicode code point."
msgstr "`Char` 表示一个 Unicode 码点。"

#: ../../language/fundamentals.md:195
msgid ""
"let a : Char = 'A'\n"
"let b = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/fundamentals.md:202
msgid ""
"Char literals can be overloaded to type `Int` or `UInt16` when it is the "
"expected type:"
msgstr "当期望类型是 `Int` 或 `UInt16` 时，字符字面量可以重载为对应类型："

#: ../../language/fundamentals.md:204
msgid ""
"test {\n"
"  let s : String = \"hello\"\n"
"  let b : UInt16 = s.code_unit_at(0) // 'h'\n"
"  assert_eq(b, 'h') // 'h' is overloaded to UInt16\n"
"  let c : Int = '兔'\n"
"  // Not ok : exceed range\n"
"  // let d : UInt16 = '𠮷'\n"
"}\n"
msgstr ""
"test {\n"
"  let s : String = \"hello\"\n"
"  let b : UInt16 = s.code_unit_at(0) // 'h'\n"
"  assert_eq(b, 'h') // 'h' 被重载为 UInt16\n"
"  let c : Int = '兔'\n"
"  // 不可：超出范围\n"
"  // let d : UInt16 = '𠮷'\n"
"}\n"

#: ../../language/fundamentals.md:211
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/char>"
msgstr ""

#: ../../language/fundamentals.md:217
msgid "Byte(s)"
msgstr "字节"

#: ../../language/fundamentals.md:219
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape, have the form of `b'...'`. Byte literals are of type `Byte`. For "
"example:"
msgstr "MoonBit 中的字节字面量是一个 ASCII 字符或一个转义序列，语法形式为 `b'...'`。字节字面量的类型是 `Byte`。例如："

#: ../../language/fundamentals.md:221
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:229
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/fundamentals.md:233
msgid ""
"A `Bytes` is an immutable sequence of bytes. Similar to byte, bytes literals"
" have the form of `b\"...\"`. For example:"
msgstr "`Bytes` 是不可修改的字节序列。与字节类似，字节序列字面量的形式是 `b\"...\"`。例如："

#: ../../language/fundamentals.md:235
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:241
msgid ""
"The byte literal and bytes literal also support escape sequences, but "
"different from those in string literals. The following table lists the "
"supported escape sequences for byte and bytes literals:"
msgstr "`Byte`字面量和`Bytes`字面量也支持转义序列，但是和字符串字面量的转义序列有些不同。下面的表格列出了支持的转义序列："

#: ../../language/fundamentals.md:235
msgid "`\\x41`"
msgstr ""

#: ../../language/fundamentals.md:235
msgid "Hexadecimal escape sequence"
msgstr "十六进制转义序列"

#: ../../language/fundamentals.md:235
msgid "`\\o102`"
msgstr ""

#: ../../language/fundamentals.md:235
msgid "Octal escape sequence"
msgstr "八进制转义序列"

#: ../../language/fundamentals.md:252
msgid ""
"You can use `@buffer.T` to construct bytes by writing various types of data."
" For example:"
msgstr "你可以通过向`@buffer.T`写入不同类型的数据来构造一个`Bytes`。例如："

#: ../../language/fundamentals.md:254
msgid ""
"test \"buffer 1\" {\n"
"  let buf : @buffer.Buffer = @buffer.new()\n"
"  buf.write_bytes(b\"Hello\")\n"
"  buf.write_byte(b'!')\n"
"  assert_eq(buf.contents(), b\"Hello!\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:262
msgid ""
"When the expected type is `Bytes`, the `b` prefix can be omitted. Array "
"literals can also be overloaded to construct a `Bytes` sequence by "
"specifying each byte in the sequence."
msgstr ""
"当期望类型是 `Bytes` 时，`b`前缀可以省略。此时也可以通过在`[]`中列出`Byte`, 来将数组字面量重载为`Bytes`的值 "
"也可以被重载为`Bytes`的值。"

#: ../../language/fundamentals.md:264
msgid ""
"test {\n"
"  let b : Byte = '\\xFF'\n"
"  let bs : Bytes = [b, '\\x01']\n"
"  inspect(\n"
"    bs,\n"
"    content=(\n"
"      #|b\"\\xff\\x01\"\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:271
msgid ""
"API for `Byte`: <https://mooncakes.io/docs/moonbitlang/core/byte>   API for "
"`Bytes`: <https://mooncakes.io/docs/moonbitlang/core/bytes>   API for "
"`@buffer.T`: <https://mooncakes.io/docs/moonbitlang/core/buffer>"
msgstr ""
"`Byte` 的 API：<https://mooncakes.io/docs/moonbitlang/core/byte>  \n"
"`Bytes` 的 API：<https://mooncakes.io/docs/moonbitlang/core/bytes>  \n"
"`@buffer.T` 的 API：<https://mooncakes.io/docs/moonbitlang/core/buffer>"

#: ../../language/fundamentals.md:278
msgid "Tuple"
msgstr "元组"

#: ../../language/fundamentals.md:280
msgid ""
"A tuple is a collection of finite values constructed using round brackets "
"`()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. Here's"
" an example:"
msgstr ""
"元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要；例如，`(1,true)` 和 `(true,1)` "
"有不同的类型。以下是一个示例："

#: ../../language/fundamentals.md:282
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:290
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/fundamentals.md:294
msgid "Tuples can be accessed via pattern matching or index:"
msgstr "元组可以通过模式匹配或索引访问："

#: ../../language/fundamentals.md:296
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq(x1, x2)\n"
"  assert_eq(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:302
msgid "Ref"
msgstr ""

#: ../../language/fundamentals.md:304
msgid "A `Ref[T]` is a mutable reference containing a value `val` of type `T`."
msgstr "`Ref[T]` 是一个包含类型 `T` 的值 `val` 的可变引用。"

#: ../../language/fundamentals.md:306
msgid ""
"It can be constructed using `{ val : x }`, and can be accessed using "
"`ref.val`. See [struct](#struct) for detailed explanation."
msgstr "可以使用 `{ val : x }` 构造它，并可以使用 `ref.val` 访问它。有关详细说明，请参见 [结构体](#struct)。"

#: ../../language/fundamentals.md:308
msgid ""
"let a : Ref[Int] = { val: 100 }\n"
"\n"
"test {\n"
"  a.val = 200\n"
"  assert_eq(a.val, 200)\n"
"  a.val += 1\n"
"  assert_eq(a.val, 201)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:315
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/ref>"
msgstr ""

#: ../../language/fundamentals.md:318
msgid "Option and Result"
msgstr "Option 和 Result"

#: ../../language/fundamentals.md:320
msgid ""
"`Option` and `Result` are the most common types to represent a possible "
"error or failure in MoonBit."
msgstr "`Option` 和 `Result` 是 MoonBit 中表示可能的错误或失败的最常见类型。"

#: ../../language/fundamentals.md:322
msgid ""
"`Option[T]` represents a possibly missing value of type `T`. It can be "
"abbreviated as `T?`."
msgstr "`Option[T]` 表示可能缺失的类型 `T` 的值。它可以缩写为 `T?`。"

#: ../../language/fundamentals.md:323
msgid "`Result[T, E]` represents either a value of type `T` or an error of type `E`."
msgstr "`Result[T, E]` 表示类型 `T` 的值或类型 `E` 的错误。"

#: ../../language/fundamentals.md:325
msgid "See [enum](#enum) for detailed explanation."
msgstr "有关详细说明，请参见 [枚举](#enum)。"

#: ../../language/fundamentals.md:327
msgid ""
"test {\n"
"  let a : Int? = None\n"
"  let b : Option[Int] = Some(42)\n"
"  let c : Result[Int, String] = Ok(42)\n"
"  let d : Result[Int, String] = Err(\"error\")\n"
"  match a {\n"
"    Some(_) => assert_true(false)\n"
"    None => assert_true(true)\n"
"  }\n"
"  match d {\n"
"    Ok(_) => assert_true(false)\n"
"    Err(_) => assert_true(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:334
msgid ""
"API for `Option`: <https://mooncakes.io/docs/moonbitlang/core/option>   API "
"for `Result`: <https://mooncakes.io/docs/moonbitlang/core/result>"
msgstr ""
"`Option` 的 API：<https://mooncakes.io/docs/moonbitlang/core/option>  \n"
"`Result` 的 API：<https://mooncakes.io/docs/moonbitlang/core/result>"

#: ../../language/fundamentals.md:338
msgid "Array"
msgstr "数组"

#: ../../language/fundamentals.md:340
msgid ""
"An array is a finite sequence of values constructed using square brackets "
"`[]`, with elements separated by commas `,`. For example:"
msgstr "数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。例如："

#: ../../language/fundamentals.md:342
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/fundamentals.md:349
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts from "
"zero."
msgstr "您可以使用 `numbers[x]` 来引用第 x 个元素。索引从零开始。"

#: ../../language/fundamentals.md:351
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:358
msgid "There are `Array[T]` and `FixedArray[T]`:"
msgstr "有 `Array[T]` 和 `FixedArray[T]`："

#: ../../language/fundamentals.md:360
msgid ""
"`Array[T]` can grow in size, while `FixedArray[T]` has a fixed size, thus it"
" needs to be created with initial value."
msgstr "`Array[T]` 可以增长，`FixedArray[T]` 有固定的大小，因此需要使用初始值创建。"

#: ../../language/fundamentals.md:363
msgid "A common pitfall is creating `FixedArray` with the same initial value:"
msgstr "一个常见的陷阱是使用相同的初始值创建 `FixedArray`："

#: ../../language/fundamentals.md:365
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq(two_dimension_array[5][5], 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:372
msgid ""
"This is because all the cells reference to the same object (the "
"`FixedArray[Int]` in this case). One should use `FixedArray::makei()` "
"instead which creates an object for each index."
msgstr ""
"这是因为所有单元格引用相同的对象（在这种情况下是 `FixedArray[Int]`）。应该使用 "
"`FixedArray::makei()`，它为每个索引创建一个对象。"

#: ../../language/fundamentals.md:374
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::makei(10, fn(_i) {\n"
"    FixedArray::make(10, 0)\n"
"  })\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq(two_dimension_array[5][5], 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:382
msgid ""
"When the expected type is known, MoonBit can automatically overload array, "
"otherwise `Array[T]` is created:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载数组，否则将创建 `Array[T]`："

#: ../../language/fundamentals.md:385
msgid ""
"let fixed_array_1 : FixedArray[Int] = [1, 2, 3]\n"
"\n"
"let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])\n"
"\n"
"let array_3 : Array[Int] = [1, 2, 3] // Array[Int]\n"
msgstr ""

#: ../../language/fundamentals.md:393 ../../language/fundamentals.md:417
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/array>"
msgstr ""

#: ../../language/fundamentals.md:398
msgid "ArrayView"
msgstr ""

#: ../../language/fundamentals.md:400
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create a "
"view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""
"类似于其他语言中的 `slice`，视图是对集合的特定段的引用。您可以使用 `data[start:end]` 创建数组 `data` 的视图，引用从 "
"`start` 到 `end`（不包括）的元素。`start` 和 `end` 索引都可以省略。"

#: ../../language/fundamentals.md:406
msgid ""
"`ArrayView` is an immutable data structure on its own, but the underlying "
"`Array` or `FixedArray` could be modified."
msgstr "`ArrayView` 本身是一个不可变的数据结构，但底层的 `Array` 或 `FixedArray` 可以被修改。"

#: ../../language/fundamentals.md:410
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:420
msgid "Map"
msgstr "Map"

#: ../../language/fundamentals.md:422
msgid ""
"MoonBit provides a hash map data structure that preserves insertion order "
"called `Map` in its standard library. `Map`s can be created via a convenient"
" literal syntax:"
msgstr "MoonBit 在其标准库中提供了一个保留插入顺序的哈希映射数据结构，称为 `Map`。`Map` 可以通过方便的字面量语法创建："

#: ../../language/fundamentals.md:425
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/fundamentals.md:431
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be "
"destructed elegantly with pattern matching, see [Map Pattern](#map-pattern)."
msgstr "目前，映射字面量语法中的键必须是常量。`Map` 也可以通过模式匹配优雅地解构，参见 [Map 模式](#map-pattern)。"

#: ../../language/fundamentals.md:434
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/builtin#Map>"
msgstr ""

#: ../../language/fundamentals.md:439
msgid "Json"
msgstr "Json"

#: ../../language/fundamentals.md:441
msgid ""
"MoonBit supports convenient json handling by overloading literals. When the "
"expected type of an expression is `Json`, number, string, array and map "
"literals can be directly used to create json data:"
msgstr ""
"MoonBit 通过重载字面量支持方便的 json 处理。当表达式的期望类型是 `Json` 时，数字、字符串、数组和映射字面量可以直接用于创建 "
"json 数据："

#: ../../language/fundamentals.md:444
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", \"moonbitlang/core/coverage\"],"
"\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:450
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr "Json 值也可以进行模式匹配，参见 [Json 模式](#json-pattern)。"

#: ../../language/fundamentals.md:453
msgid "API: <https://mooncakes.io/docs/moonbitlang/core/json>"
msgstr ""

#: ../../language/fundamentals.md:458
msgid "Overloaded Literals"
msgstr "重载字面量"

#: ../../language/fundamentals.md:460
msgid ""
"Overloaded literals allow you to use the same syntax to represent different "
"types of values.  For example, you can use `1` to represent `UInt` or "
"`Double` depending on the expected type. If the expected type is not known, "
"the literal will be interpreted as `Int` by default."
msgstr "通过重载字面量，你可以使用同一个语法来表示不同类型的值。例如，根据上下文期望的类型，使用`1`表示一个`UInt`或者`Double`。如果一个上下文中不能确定期望的类型，那么它默认为`Int`。"

#: ../../language/fundamentals.md:463
msgid ""
"fn expect_double(x : Double) -> Unit {\n"
"\n"
"}\n"
"\n"
"test {\n"
"  let x = 1 // type of x is Int\n"
"  let y : Double = 1\n"
"  expect_double(1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:469
msgid ""
"The overloaded literals can be composed. If array literal can be overloaded "
"to `Bytes` , and number literal can be overloaded to `Byte` , then you can "
"overload `[1,2,3]` to `Bytes` as well. Here is a table of overloaded "
"literals in MoonBit:"
msgstr "重载字面量可以组合使用。如果一个数组字面量能够被重载为`Bytes`类型，并且一个数字字面量可以被重载为`Byte`类型，那么`[1,2,3]`就可以被重载为`Bytes`。下面的表格列出了可以重载的字面量和规则："

#: ../../language/fundamentals.md:463
msgid "Overloaded literal"
msgstr "重载字面量"

#: ../../language/fundamentals.md:463
msgid "Default type"
msgstr "默认类型"

#: ../../language/fundamentals.md:463
msgid "Can be overloaded to"
msgstr "可以被重载为"

#: ../../language/fundamentals.md:463
msgid "`10`, `0xFF`, `0o377`, `10_000`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid ""
"`UInt`, `Int64`, `UInt64`, `Int16`, `UInt16`, `Byte`, `Double`, `Float`, "
"`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`\"str\"`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`String`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`Bytes`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`'c'`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`Char`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`Int` , `Byte`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid "`[a, b, c]` (where the types of literals a, b, and c are E)"
msgstr "`[a, b, c]`（字面量 a、b、c 的类型为 E）"

#: ../../language/fundamentals.md:463
msgid "`Array[E]`"
msgstr ""

#: ../../language/fundamentals.md:463
msgid ""
"`FixedArray[E]`, `String`  (if E is of type Char), `Bytes` (if E is of type "
"Byte)"
msgstr "`FixedArray[E]`、`String`（如果 E 的类型是 Char）、`Bytes`（如果 E 的类型是 Byte）"

#: ../../language/fundamentals.md:479
msgid ""
"There are also some similar overloading rules in pattern. For more details, "
"see [Pattern Matching](#pattern-matching)."
msgstr "在模式中也有类似的重载规则，更多细节见 [模式匹配](#pattern-matching)。"

#: ../../language/fundamentals.md:482
msgid ""
"Literal overloading is not the same as value conversion. To convert a "
"variable to a different type, you can use methods prefixed with `to_`, such "
"as `to_int()`, `to_double()`, etc."
msgstr "字面量重载不是值转换。如果要将一个变量转换为不同的类型的值，可以使用以`to_`开头的方法，例如`to_int()`和`to_double()`，等等。"

#: ../../language/fundamentals.md:486
msgid "Escape Sequences in Overloaded Literals"
msgstr "重载字面量中的转义序列"

#: ../../language/fundamentals.md:488
msgid ""
"Escape sequences can be used in overloaded `\"...\"` literals and `'...'` "
"literals. The interpretation of escape sequences depends on the types they "
"are overloaded to:"
msgstr "转义序列能在重载的`\"...\"`和`'...'`字面量中使用。转义序列的解释根据它被重载到的具体类型而定："

#: ../../language/fundamentals.md:490
msgid "Simple escape sequences"
msgstr "简单转义序列"

#: ../../language/fundamentals.md:492
msgid ""
"Including `\\n`, `\\r`, `\\t`, `\\\\`, and `\\b`. These escape sequences are"
" supported in any `\"...\"` or `'...'` literals. They are interpreted as "
"their respective `Char` or `Byte` in `String` or `Bytes`."
msgstr "包括`\\n`、`\\r`、`\\t`、`\\\\`和`\\b`。这些转义序列在任何`\"...\"`和`'...'`字面量中都被支持。在期望的类型是`String`时，它们被解释为对应的字符；在期望的类型是`Bytes`时，它们被解释为对应的`Byte`。"

#: ../../language/fundamentals.md:494
msgid "Byte escape sequences"
msgstr "字节转义序列"

#: ../../language/fundamentals.md:496
msgid ""
"The `\\x41` and `\\o102` escape sequences represent a Byte. These are "
"supported in literals overloaded to `Bytes` and `Byte`."
msgstr "`\\x41`和`\\o102`转义序列表示一个`Byte`值。支持在重载为`Bytes`和`Byte`类型的字面量中使用。"

#: ../../language/fundamentals.md:498
msgid "Unicode escape sequences"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:500
msgid ""
"The `\\u5154` and `\\u{1F600}` escape sequences represent a `Char`. These "
"are supported in literals of type `String` and `Char`."
msgstr "`\\u5154`和`\\u{1F600}`转义序列表示一个`Char`。支持在重载为`String`和`Char`类型的字面量中使用。"

#: ../../language/fundamentals.md:502
msgid "Functions"
msgstr "函数"

#: ../../language/fundamentals.md:504
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values of"
" other functions. MoonBit's naming convention requires that function names "
"should not begin with uppercase letters (A-Z). Compare for constructors in "
"the `enum` section below."
msgstr ""
"函数接受参数并产生结果。在 MoonBit 中，函数是一等公民，这意味着函数可以是其他函数的参数或返回值。MoonBit "
"的命名约定要求函数名不应以大写字母（A-Z）开头。请参见下面的 `enum` 部分中的构造器。"

#: ../../language/fundamentals.md:506
msgid "Top-Level Functions"
msgstr "顶层函数"

#: ../../language/fundamentals.md:508
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` keyword "
"to define a top-level function that sums three integers and returns the "
"result, as follows:"
msgstr "函数可以定义为顶级或局部。我们可以使用 `fn` 关键字定义一个顶级函数，它将三个整数相加并返回结果，如下所示："

#: ../../language/fundamentals.md:510
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:516
msgid ""
"Note that the arguments and return value of top-level functions require "
"**explicit** type annotations."
msgstr "请注意，顶级函数的参数和返回值需要**显式**类型注释。"

#: ../../language/fundamentals.md:518
msgid "Local Functions"
msgstr "局部函数"

#: ../../language/fundamentals.md:520
msgid ""
"Local functions can be named or anonymous. Type annotations can be omitted "
"for local function definitions: they can be automatically inferred in most "
"cases. For example:"
msgstr "局部函数可以是命名的或匿名的。局部函数定义可以省略类型注释：在大多数情况下，它们可以自动推断。例如："

#: ../../language/fundamentals.md:522
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly applied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(local_1(), 9)\n"
"}\n"
msgstr ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // 命名为 `inc`\n"
"    x + 1\n"
"  }\n"
"  // 匿名，立即应用于整数字面量 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(local_1(), 9)\n"
"}\n"

#: ../../language/fundamentals.md:528
msgid ""
"For simple anonymous function, MoonBit provides a very concise syntax called"
" arrow function:"
msgstr "MoonBit 为简单的匿名函数提供了一个非常简洁的箭头函数语法："

#: ../../language/fundamentals.md:530
msgid ""
"  [1, 2, 3].eachi((i, x) => println(\"\\{i} => \\{x}\"))\n"
"  // parenthesis can be omitted when there is only one parameter\n"
"  [1, 2, 3].each(x => println(x * x))\n"
msgstr ""
"  [1, 2, 3].eachi((i, x) => println(\"\\{i} => \\{x}\"))\n"
"  // 只有一个参数时可以省略括号\n"
"  [1, 2, 3].each(x => println(x * x))\n"

#: ../../language/fundamentals.md:536
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr "函数，无论是命名的还是匿名的，都是 _词法闭包_：没有局部绑定的任何标识符必须引用来自周围词法范围的绑定。例如："

#: ../../language/fundamentals.md:538
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:544
msgid ""
"A local function can only refer to itself and other previously defined local"
" functions. To define  mutually recursive local functions, use the syntax "
"`letrec f = .. and g = ..` instead:"
msgstr ""
"局部函数的定义内，可以使用这个函数自己或者之前定义的其他局部函数。如果要定义多个互相递归的局部函数，需要使用 `letrec f = .. and g "
"= ..` 语法："

#: ../../language/fundamentals.md:547
msgid ""
"  fn f(x) {\n"
"    // `f` can refer to itself here, but cannot use `g`\n"
"    if x > 0 {\n"
"      f(x - 1)\n"
"    }\n"
"  }\n"
"\n"
"  fn g(x) {\n"
"    // `g` can refer to `f` and `g` itself\n"
"    if x < 0 {\n"
"      f(-x)\n"
"    } else {\n"
"      f(x)\n"
"    }\n"
"  }\n"
"  // mutually recursive local functions\n"
"  letrec even = x => x == 0 || odd(x - 1)\n"
"  and odd = x => x != 0 && even(x - 1)\n"
msgstr ""
"  fn f(x) {\n"
"    // `f` 可以调用它自己，但不能调用 `g`\n"
"    if x > 0 {\n"
"      f(x - 1)\n"
"    }\n"
"  }\n"
"\n"
"  fn g(x) {\n"
"    // `g` 可以调用 `f` 和 `g` 自身\n"
"    if x < 0 {\n"
"      f(-x)\n"
"    } else {\n"
"      f(x)\n"
"    }\n"
"  }\n"
"  // 互递归的局部函数\n"
"  letrec even = x => x == 0 || odd(x - 1)\n"
"  and odd = x => x != 0 && even(x - 1)\n"

#: ../../language/fundamentals.md:553
msgid "Function Applications"
msgstr "函数应用"

#: ../../language/fundamentals.md:555
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr "函数可以应用于括号中的参数列表："

#: ../../language/fundamentals.md:557
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/fundamentals.md:561
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown below:"
msgstr "无论 `add3` 是一个使用名称定义的函数（如前面的示例）还是绑定到函数值的变量，都可以工作，如下所示："

#: ../../language/fundamentals.md:563
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:569
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that evaluates "
"to a function value is applicable:"
msgstr "表达式 `add3(1, 2, 7)` 返回 `10`。任何求值为函数值的表达式都是可应用的："

#: ../../language/fundamentals.md:571
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:578
msgid "Partial Applications"
msgstr "部分应用"

#: ../../language/fundamentals.md:580
msgid ""
"Partial application is a technique of applying a function to some of its "
"arguments, resulting in a new function that takes the remaining arguments. "
"In MoonBit, partial application is achieved by using the `_` operator in "
"function application:"
msgstr "部分应用允许函数调用时只提供部分的参数，生成一个接受被余下的参数并返回结果的函数。在 MoonBit 中，通过`_`操作符可以对函数进行部分应用："

#: ../../language/fundamentals.md:582
msgid ""
"fn add(x : Int, y : Int) -> Int {\n"
"  x + y\n"
"}\n"
"\n"
"test {\n"
"  let add10 : (Int) -> Int = add(10, _)\n"
"  println(add10(5)) // prints 15\n"
"  println(add10(10)) // prints 20\n"
"}\n"
msgstr ""
"fn add(x : Int, y : Int) -> Int {\n"
"  x + y\n"
"}\n"
"\n"
"test {\n"
"  let add10 : (Int) -> Int = add(10, _)\n"
"  println(add10(5)) // 输出 15\n"
"  println(add10(10)) // 输出 20\n"
"}\n"

#: ../../language/fundamentals.md:589
msgid ""
"The `_` operator represents the missing argument in parentheses. The partial"
" application allows multiple `_` in the same parentheses. For example, "
"`Array::fold(_, _, init=5)` is equivalent to `fn(x, y) { Array::fold(x, y, "
"init=5) }`."
msgstr ""
"`_`操作符表示括号中缺少的参数。部分应用允许在一对括号中使用多个`_`。例如，`Array::fold(_, _, init=5)`等价于`fn(x,"
" y) { Array::fold(x, y, init=5) }`。"

#: ../../language/fundamentals.md:592
msgid ""
"The `_` operator can also be used in enum creation, dot style function calls"
" and in the pipelines."
msgstr "`_`操作符也可以在创建枚举值、`self.f(args)`形式的函数调用和管道中使用。"

#: ../../language/fundamentals.md:594
msgid "Labelled arguments"
msgstr "带标签的参数"

#: ../../language/fundamentals.md:596
msgid ""
"**Top-level** functions can declare labelled argument with the syntax "
"`label~ : Type`. `label` will also serve as parameter name inside function "
"body:"
msgstr "**顶层**函数可以使用语法 `label~ : Type` 声明带标签的参数。`label` 也将作为函数体内的参数名："

#: ../../language/fundamentals.md:598
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:604
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. `label=label`"
" can be abbreviated as `label~`:"
msgstr "可以通过语法 `label=arg` 提供带标签的参数。`label=label` 可以缩写为 `label~`："

#: ../../language/fundamentals.md:606
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:612
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr "带标签的函数可以以任何顺序提供。参数的求值顺序与函数声明中参数的顺序相同。"

#: ../../language/fundamentals.md:614
msgid "Optional arguments"
msgstr "可选参数"

#: ../../language/fundamentals.md:616
msgid ""
"An argument can be made optional by supplying a default expression with the "
"syntax `label?: Type = default_expr`, where the `default_expr` may be "
"omitted. If this argument is not supplied at call site, the default "
"expression will be used:"
msgstr ""
"可以通过语法 `label? : Type = default_expr` 使参数变为可选，其中 `default_expr` "
"可以省略。如果在调用处未提供该参数，则将使用默认表达式："

#: ../../language/fundamentals.md:618
msgid ""
"fn optional(opt? : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(optional(), 42)\n"
"  assert_eq(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:624
msgid ""
"The default expression will be evaluated every time it is used. And the side"
" effect in the default expression, if any, will also be triggered. For "
"example:"
msgstr "默认表达式每次使用时都会被求值。并且默认表达式中的副作用（如果有）也会被触发。例如："

#: ../../language/fundamentals.md:626
msgid ""
"fn incr(counter? : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect(incr(), content=\"{val: 1}\")\n"
"  inspect(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect(incr(counter~), content=\"{val: 1}\")\n"
"  inspect(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:632
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr "如果要在不同的函数调用之间共享默认表达式的结果，可以将默认表达式提升到顶层 `let` 声明："

#: ../../language/fundamentals.md:634
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter? : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(incr_2(), 1)\n"
"  assert_eq(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:640
msgid "The default expression can depend on previous arguments, such as:"
msgstr "默认表达式可以依赖于之前的参数，例如："

#: ../../language/fundamentals.md:642
msgid ""
"fn create_rectangle(a : Int, b? : Int = a) -> (Int, Int) {\n"
"  (a, b)\n"
"}\n"
"\n"
"test {\n"
"  inspect(create_rectangle(10), content=\"(10, 10)\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:648
msgid "Optional arguments without default values"
msgstr "没有默认值的可选参数"

#: ../../language/fundamentals.md:650
msgid ""
"It is quite common to have different semantics when a user does not provide "
"a value. Optional arguments without default values have type `T?` and `None`"
" as the default value. When supplying this kind of optional argument "
"directly, MoonBit will automatically wrap the value with `Some`:"
msgstr ""
"当用户未提供值时，具有不同语义的情况是很常见的。没有默认值的可选参数的类型为 `T?`，默认值为 `None`。在直接提供这种可选参数时，MoonBit"
" 将自动用 `Some` 包装该值："

#: ../../language/fundamentals.md:654
msgid ""
"fn new_image(width? : Int, height? : Int) -> Image {\n"
"  if width is Some(w) {\n"
"    ...\n"
"  }\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = new_image(width=1920, height=1080)\n"
msgstr ""

#: ../../language/fundamentals.md:660
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""
"有时，直接传递类型为 `T?` 的值也很有用，例如在转发可选参数时。MoonBit 为此提供了一个语法 `label?=value`，并且 "
"`label?` 是 `label?=label` 的缩写："

#: ../../language/fundamentals.md:664
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:670
msgid "Autofill arguments"
msgstr "自动填充参数"

#: ../../language/fundamentals.md:672
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare a labelled argument, and add a "
"function attribute `#callsite(autofill(param_a, param_b))`. Now if the "
"argument is not explicitly supplied, MoonBit will automatically fill it at "
"the call site."
msgstr ""
"MoonBit 支持在不同的调用位置自动填充特定类型的参数，例如函数调用的源位置。要声明一个自动填充参数，只需声明一个带标签的参数，并添加一个函数属性 "
"`#callsite(autofill(param_a, param_b))`。现在，如果未显式提供参数，MoonBit 将在调用时自动填充它。"

#: ../../language/fundamentals.md:676
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is an array containing the source location of each argument, if any:"
msgstr ""
"目前 MoonBit 支持两种类型的自动填充参数，`SourceLoc`，它是整个函数调用的源位置，以及 "
"`ArgsLoc`，它是一个数组，包含每个参数的源位置（如果有）："

#: ../../language/fundamentals.md:679
msgid ""
"#callsite(autofill(loc, args_loc))\n"
"fn f(_x : Int, loc~ : SourceLoc, args_loc~ : ArgsLoc) -> String {\n"
"  (\n"
"    $|loc of whole function call: \\{loc}\n"
"    $|loc of arguments: \\{args_loc}\n"
"  )\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), Some(<filename>:7:8-7:9), "
"None, None]\n"
"}\n"
msgstr ""
"#callsite(autofill(loc, args_loc))\n"
"fn f(_x : Int, loc~ : SourceLoc, args_loc~ : ArgsLoc) -> String {\n"
"  (\n"
"    $|loc of whole function call: \\{loc}\n"
"    $|loc of arguments: \\{args_loc}\n"
"  )\n"
"  // 整个函数调用的位置：<filename>:7:3-7:10\n"
"  // 参数的位置：[Some(<filename>:7:5-7:6), Some(<filename>:7:8-7:9), "
"None, None]\n"
"}\n"

#: ../../language/fundamentals.md:685
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr "自动填充参数非常有用，用于编写调试和测试工具。"

#: ../../language/fundamentals.md:687
msgid "Function alias"
msgstr "函数别名"

#: ../../language/fundamentals.md:688
msgid ""
"MoonBit allows calling functions with alternative names via function alias. "
"Function alias can be declared as follows:"
msgstr "MoonBit 允许用户用别名来调用一个函数。声明函数别名的语法如下："

#: ../../language/fundamentals.md:690
msgid ""
"#alias(g)\n"
"#alias(h, visibility=\"pub\")\n"
"fn k() -> Bool {\n"
"  true\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:696
msgid ""
"You can also create function alias that has different visibility with the "
"field `visibility`."
msgstr "你也可以通过字段 `visibility` 创建具有不同可见性的函数别名。"

#: ../../language/fundamentals.md:698
msgid "Control Structures"
msgstr "控制结构"

#: ../../language/fundamentals.md:700
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../language/fundamentals.md:702
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr "条件表达式由条件、结果和可选的 `else` 子句或 `else if` 子句组成。"

#: ../../language/fundamentals.md:704
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:711
msgid "The curly brackets around the consequent are required."
msgstr "结果周围的大括号是必需的。"

#: ../../language/fundamentals.md:713
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and "
"the return values of the consequent and the else clause must be of the same "
"type. Here is an example:"
msgstr "请注意，条件表达式在 MoonBit 中始终返回一个值，结果和 else 子句的返回值必须是相同的类型。以下是一个示例："

#: ../../language/fundamentals.md:715
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals.md:722
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr "`else` 子句只有在返回值的类型为 `Unit`的时候省略。"

#: ../../language/fundamentals.md:724
msgid "Match Expression"
msgstr "匹配表达式"

#: ../../language/fundamentals.md:726
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](#pattern-matching) to decide which consequent to evaluate"
" and extracting variables at the same time."
msgstr "`match` 表达式类似于条件表达式，但它使用 [模式匹配](#pattern-matching) 来决定要评估哪个结果，并同时提取变量。"

#: ../../language/fundamentals.md:728
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:735
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, and "
"the program will terminate if that case were reached."
msgstr "如果省略了可能的条件，编译器将发出警告；如果真的出现该情况，程序将终止。"

#: ../../language/fundamentals.md:737
msgid "Guard Statement"
msgstr "卫语句"

#: ../../language/fundamentals.md:739
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing the"
" subsequent statements and returns. If the condition is not satisfied (i.e.,"
" false), the code in the `else` block is executed and its evaluation result "
"is returned (the subsequent statements are skipped)."
msgstr ""
"`guard` 语句用于检查指定的不变量。如果不变量的条件得到满足，程序将继续执行后续语句。如果条件不满足（即为假），则执行 `else` "
"块中的代码且返回其值（并跳过后续语句）。"

#: ../../language/fundamentals.md:744
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:751
msgid "Guard statement and is expression"
msgstr "卫语句与 is 表达式"

#: ../../language/fundamentals.md:753
msgid ""
"The `let` statement can be used with [pattern matching](#pattern-matching). "
"However, `let` statement can only handle one case. And using [is expression"
"](#is-expression) with `guard` statement can solve this issue."
msgstr ""
"`let` 语句可以与 [模式匹配](#pattern-matching) 一起使用。但是，`let` 语句只能处理一种情况。使用 [is 表达式"
"](#is-expression) 配合卫语句可以解决这个问题。"

#: ../../language/fundamentals.md:755
msgid ""
"In the following example, `getProcessedText` assumes that the input `path` "
"points to resources that are all plain text, and it uses the `guard` "
"statement to ensure this invariant while extracting the plain text resource."
" Compared to using a `match` statement, the subsequent processing of `text` "
"can have one less level of indentation."
msgstr ""
"在以下示例中，`getProcessedText` 假设输入的 `path` 指向的资源都是纯文本，并使用 `guard` "
"语句来在确保这个不变量的同时，解构出纯文本资源。与使用 `match` 语句相比，`text` 的后续处理可以少一级缩进。"

#: ../../language/fundamentals.md:759
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String,\n"
") -> String raise Error {\n"
"  guard resources.get(path) is Some(resource) else { fail(\"\\{path} not "
"found\") }\n"
"  guard resource is PlainText(text) else { fail(\"\\{path} is not plain "
"text\") }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:765
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr "如果省略了 `else` 部分，程序将在 `guard` 语句中指定的条件不为真或无法匹配时终止。"

#: ../../language/fundamentals.md:768
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard expr is Some(x)\n"
"// <=> guard expr is Some(x) else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals.md:775
msgid "While loop"
msgstr "While 循环"

#: ../../language/fundamentals.md:777
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code repeatedly "
"as long as a condition is true. The condition is evaluated before executing "
"the block of code. The `while` loop is defined using the `while` keyword, "
"followed by a condition and the loop body. The loop body is a sequence of "
"statements. The loop body is executed as long as the condition is true."
msgstr ""
"在 MoonBit 中，`while` 循环可用于在条件为真时重复执行一段代码块。在执行代码块之前，将评估条件。使用 `while` 关键字定义 "
"`while` 循环，后跟条件和循环体。循环体是一系列语句。只要条件为真，就会执行循环体。"

#: ../../language/fundamentals.md:779
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:787
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals.md:791
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you to "
"exit the current loop, while using `continue` skips the remaining part of "
"the current iteration and proceeds to the next iteration."
msgstr ""
"循环体支持 `break` 和 `continue`。使用 `break` 可以退出当前循环，而使用 `continue` "
"则跳过当前迭代的剩余部分并继续下一次迭代。"

#: ../../language/fundamentals.md:793
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:801
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals.md:805
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the "
"loop will end."
msgstr "`while` 循环还支持可选的 `else` 子句。当循环条件变为假时，将执行 `else` 子句，然后循环将结束。"

#: ../../language/fundamentals.md:807
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:815
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:819
msgid ""
"When there is an `else` clause, the `while` loop can also return a value. "
"The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value of"
" the `else` clause."
msgstr ""
"当有 `else` 子句时，`while` 循环还可以返回一个值。返回值是 `else` 子句的评估结果。在这种情况下，如果使用 `break` "
"退出循环，需要在 `break` 后提供一个返回值，该返回值应与 `else` 子句的返回值类型相同。"

#: ../../language/fundamentals.md:821
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:829
msgid "5\n"
msgstr ""

#: ../../language/fundamentals.md:833
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:841
msgid "7\n"
msgstr ""

#: ../../language/fundamentals.md:845
msgid "For Loop"
msgstr "For 循环"

#: ../../language/fundamentals.md:847
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by "
"variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. For"
" example, the code below creates a new variable binding `i`, which has a "
"scope throughout the entire loop and is immutable. This makes it easier to "
"write clear code and reason about it:"
msgstr ""
"MoonBit 还支持 C 风格的 For 循环。关键字 `for` "
"后跟由分号分隔的变量初始化子句、循环条件和更新子句。它们不需要用括号括起来。例如，下面的代码创建了一个新的变量绑定 "
"`i`，它在整个循环中都有作用域且是不可变的。这使得编写清晰的代码并对其进行推理更容易："

#: ../../language/fundamentals.md:850
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:858
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals.md:862
msgid "The variable initialization clause can create multiple bindings:"
msgstr "变量初始化子句可以创建多个绑定："

#: ../../language/fundamentals.md:864
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:871
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In other"
" words, in the example above, the update clause does not execute `i = i + "
"1`, `j = j + 1` sequentially, but rather increments `i` and `j` at the same "
"time. Therefore, when reading the values of the binding variables in the "
"update clause, you will always get the values updated in the previous "
"iteration."
msgstr ""
"应该注意，在更新子句中，当有多个绑定变量时，语义是同时更新它们。换句话说，在上面的示例中，更新子句不会按顺序执行 `i = i + 1`，`j = j "
"+ 1`，而是同时递增 `i` 和 `j`。因此，在更新子句中读取绑定变量的值时，总是会得到上一次迭代中更新的值。"

#: ../../language/fundamentals.md:873
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are all"
" optional. For example, the following two are infinite loops:"
msgstr "变量初始化子句、循环条件和更新子句都是可选的。例如，以下两个是无限循环："

#: ../../language/fundamentals.md:875
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:882
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. Like "
"the `while` loop, the `for` loop can also return a value using the `break` "
"and `else` clauses."
msgstr ""
"`for` 循环还支持 `continue`、`break` 和 `else` 子句。与 `while` 循环一样，`for` 循环也可以使用 "
"`break` 和 `else` 子句返回一个值。"

#: ../../language/fundamentals.md:884
msgid ""
"The `continue` statement skips the remaining part of the current iteration "
"of the `for` loop (including the update clause) and proceeds to the next "
"iteration. The `continue` statement can also update the binding variables of"
" the `for` loop, as long as it is followed by expressions that match the "
"number of binding variables, separated by commas."
msgstr ""
"`continue` 语句跳过当前 `for` 循环的剩余部分（包括更新子句）并继续下一次迭代。`continue` 语句还可以更新 `for` "
"循环的绑定变量，只要后面跟着与绑定变量数量匹配的表达式，用逗号分隔。"

#: ../../language/fundamentals.md:886
msgid ""
"For example, the following program calculates the sum of even numbers from 1"
" to 6:"
msgstr "例如，以下程序计算从 1 到 6 的偶数之和："

#: ../../language/fundamentals.md:888
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:896
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals.md:900
msgid "`for .. in` loop"
msgstr "`for .. in` 循环"

#: ../../language/fundamentals.md:902
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr "MoonBit 支持通过 `for .. in` 循环语法遍历不同数据结构和序列的元素："

#: ../../language/fundamentals.md:904
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:911
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard "
"library. Any type with a method `.iter() : Iter[T]` can be traversed using "
"`for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""
"`for .. in` 循环被转换为在 MoonBit 标准库中使用 `Iter`。任何具有方法 `.iter() : Iter[T]` "
"的类型都可以使用 `for .. in` 进行遍历。有关 `Iter` 类型的更多信息，请参见下面的 [迭代器](#iterator)。"

#: ../../language/fundamentals.md:914
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr "`for .. in` 循环还支持遍历整数序列，例如："

#: ../../language/fundamentals.md:916
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq(i, 45)\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:923
msgid ""
"In addition to sequences of a single value, MoonBit also supports traversing"
" sequences of two values, such as `Map`, via the `Iter2` type in MoonBit's "
"standard library. Any type with method `.iter2() : Iter2[A, B]` can be "
"traversed using `for .. in` with two loop variables:"
msgstr ""
"除了单个值的序列外，MoonBit 还支持通过 MoonBit 标准库中的 `Iter2` 类型遍历两个值的序列，例如 `Map`。任何具有方法 "
"`.iter2() : Iter2[A, B]` 的类型都可以使用两个循环变量的 `for .. in` 进行遍历："

#: ../../language/fundamentals.md:926
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:933
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr "另一个使用两个循环变量的 `for .. in` 的示例是在遍历数组时跟踪数组索引："

#: ../../language/fundamentals.md:935
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:943
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals.md:947
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr "`for .. in` 循环的主体支持诸如 `return`、`break` 和错误处理等控制流操作："

#: ../../language/fundamentals.md:949
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:957
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals.md:961
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr "如果循环变量未使用，可以使用 `_` 忽略它。"

#: ../../language/fundamentals.md:963
msgid "Functional loop"
msgstr "函数式循环"

#: ../../language/fundamentals.md:965
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to write "
"loops in a functional style."
msgstr "函数式循环是 MoonBit 中的一个强大功能，它使您可以以函数式风格编写循环。"

#: ../../language/fundamentals.md:967
msgid ""
"A functional loop consumes an argument and returns a value. It is defined "
"using the `loop` keyword, followed by its argument and the loop body. The "
"loop body is a sequence of clauses, each of which consists of a pattern and "
"an expression. The clause whose pattern matches the input will be executed, "
"and the loop will return the value of the expression. If no pattern matches,"
" the loop will panic. Use the `continue` keyword with arguments to start the"
" next iteration of the loop. Use the `break` keyword with an argument to "
"return a value from the loop. The `break` keyword can be omitted if the "
"value is the last expression in the loop body."
msgstr ""
"函数式循环接收一个参数并返回一个值。它使用 `loop` "
"关键字定义，后跟其参数和循环体。循环体是一系列子句，每个子句由模式和表达式组成。与输入匹配的模式的子句将会被执行，并且循环将返回表达式的值。如果没有对应的模式，程序会中止。使用"
" `continue` 关键字和参数进入循环的下一次迭代。使用 `break` "
"关键字和参数从循环中返回一个值。如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。"

#: ../../language/fundamentals.md:969
msgid ""
"test {\n"
"  fn sum(xs : @list.List[Int]) -> Int {\n"
"    loop (xs, 0) {\n"
"      (Empty, acc) => break acc // <=> Nil, acc => acc\n"
"      (More(x, tail=rest), acc) => continue (rest, x + acc)\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq(sum(@list.from_array([1, 2, 3])), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:976
msgid "Use `while true { ... }` or `for { ... }` for infinite loop."
msgstr "使用 `while true { ... }` 或 `for { ... }` 来表示无限循环。"

#: ../../language/fundamentals.md:979
msgid "Labelled Continue/Break"
msgstr "带标记的 Continue/Break"

#: ../../language/fundamentals.md:981
msgid ""
"When a loop is labelled, it can be referenced from a `break` or `continue` "
"from within a nested loop. For example:"
msgstr "当一个循环被标记的时候，它可以从循环中的 `break` 或者 `continue` 中引用，例如："

#: ../../language/fundamentals.md:984
msgid ""
"test \"break label\" {\n"
"  let mut count = 0\n"
"  let xs = [1, 2, 3]\n"
"  let ys = [4, 5, 6]\n"
"  let res = outer~: for i in xs {\n"
"    for j in ys {\n"
"      count = count + i\n"
"      break outer~ j\n"
"    }\n"
"  } else {\n"
"    -1\n"
"  }\n"
"  assert_eq(res, 4)\n"
"  assert_eq(count, 1)\n"
"}\n"
"\n"
"test \"continue label\" {\n"
"  let mut count = 0\n"
"  let init = 10\n"
"  let res = outer~: loop init {\n"
"    0 => 42\n"
"    i =>\n"
"      for {\n"
"        count = count + 1\n"
"        continue outer~ i - 1\n"
"      }\n"
"  }\n"
"  assert_eq(res, 42)\n"
"  assert_eq(count, 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:990
msgid "`defer` expression"
msgstr "`defer` 表达式"

#: ../../language/fundamentals.md:992
msgid ""
"`defer` expression can be used to perform reliable resource cleanup. The "
"syntax for `defer` is as follows:"
msgstr "`defer` 表达式可以实现可靠的资源释放。`defer` 的语法如下"

#: ../../language/fundamentals.md:995
msgid ""
"defer <expr>\n"
"<body>\n"
msgstr ""

#: ../../language/fundamentals.md:1000
msgid ""
"Whenever the program leaves `body`, `expr` will be executed. For example, "
"the following program:"
msgstr "当程序离开 `body` 时，`expr` 里的内容会被执行。例如，下面的程序："

#: ../../language/fundamentals.md:1003
msgid ""
"  defer println(\"perform resource cleanup\")\n"
"  println(\"do things with the resource\")\n"
msgstr ""
"  defer println(\"释放资源\")\n"
"  println(\"使用资源\")\n"

#: ../../language/fundamentals.md:1009
msgid ""
"will first print `do things with the resource`, and then `perform resource "
"cleanup`. `defer` expression will always get executed no matter how its body"
" exits. It can handle [error](/language/error-handling.md), as well as "
"control flow constructs including `return`, `break` and `continue`."
msgstr ""
"会先输出 `使用资源`，然后输出 `释放资源`。无论 `body` 以何种方式退出，`defer` 表达式都会被执行。`defer` 能够处理 "
"[错误](/language/error-handling.md)，以及 `return`/`break`/`continue` 等控制流构造。"

#: ../../language/fundamentals.md:1014
msgid ""
"Consecutive `defer` will be executed in reverse order, for example, the "
"following:"
msgstr "连续的 `defer` 会以倒序执行。例如，下面的程序："

#: ../../language/fundamentals.md:1016
msgid ""
"  defer println(\"first defer\")\n"
"  defer println(\"second defer\")\n"
"  println(\"do things\")\n"
msgstr ""
"  defer println(\"第一处 defer\")\n"
"  defer println(\"第二处 defer\")\n"
"  println(\"做些事情\")\n"

#: ../../language/fundamentals.md:1022
msgid ""
"will output first `do things`, then `second defer`, and finally `first "
"defer`."
msgstr "会先输出 `做些事情`，然后输出 `第二处 defer`，最后输出 `第一处 defer`"

#: ../../language/fundamentals.md:1024
msgid ""
"`return`, `break` and `continue` are disallowed in the right hand side of "
"`defer`. Currently, raising error or calling `async` function is also "
"disallowed in the right hand side of `defer`."
msgstr ""
"在 `defer` 右边的表达式里，不能使用 `return`/`break`/`continue`。目前，在 `defer` "
"右边的表达式里也不能抛出错误或调用 `async` 函数。"

#: ../../language/fundamentals.md:1027
msgid "Iterator"
msgstr "迭代器"

#: ../../language/fundamentals.md:1029
msgid ""
"An iterator is an object that traverse through a sequence while providing "
"access to its elements. Traditional OO languages like Java's `Iterator<T>` "
"use `next()` `hasNext()` to step through the iteration process, whereas "
"functional languages (JavaScript's `forEach`, Lisp's `mapcar`) provides a "
"high-order function which takes an operation and a sequence then consumes "
"the sequence with that operation being applied to the sequence. The former "
"is called _external iterator_ (visible to user) and the latter is called "
"_internal iterator_ (invisible to user)."
msgstr ""
"迭代器是一个对象，它在遍历序列的同时提供对其元素的访问。传统的面向对象语言如 Java 的 `Iterator<T>` 使用 `next()` "
"和`hasNext()` 来遍历迭代过程，而函数式语言（JavaScript 的 `forEach`，Lisp 的 "
"`mapcar`）提供了一个高阶函数，该函数接受一个操作和一个序列，然后使用该操作应用于序列。前者称为外部迭代器（对用户可见），后者称为内部迭代器（对用户不可见）。"

#: ../../language/fundamentals.md:1037
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator implementation. "
"Almost all built-in sequential data structures have implemented `Iter`:"
msgstr "内置类型 `Iter[T]` 是 MoonBit 的内部迭代器实现。几乎所有内置的顺序数据结构都已经实现了 `Iter`："

#: ../../language/fundamentals.md:1040
msgid ""
"///|\n"
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(x => (x & 1) == 0).collect()\n"
"}\n"
"\n"
"///|\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1046
msgid "Commonly used methods include:"
msgstr "常用的方法包括："

#: ../../language/fundamentals.md:1048
msgid ""
"`each`: Iterates over each element in the iterator, applying some function "
"to each element."
msgstr "`each`: 遍历迭代器中的每个元素，对每个元素应用某个函数。"

#: ../../language/fundamentals.md:1049
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr "`fold`: 使用给定的函数，从给定的初始值开始，对迭代器的元素进行“折叠”。"

#: ../../language/fundamentals.md:1050
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr "`collect`: 将迭代器的元素收集到一个数组中。"

#: ../../language/fundamentals.md:1052
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a predicate "
"function."
msgstr "`filter`: （惰性）根据谓词函数过滤迭代器的元素。"

#: ../../language/fundamentals.md:1053
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr "`map`: （惰性）使用映射函数转换迭代器的元素。"

#: ../../language/fundamentals.md:1054
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the elements "
"of the second iterator to the first."
msgstr "`concat`: （惰性）通过将第二个迭代器的元素附加到第一个迭代器，将两个迭代器合并为一个。"

#: ../../language/fundamentals.md:1056
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. Array."
" But what makes `Iter` special is that any method that constructs a new "
"`Iter` is _lazy_ (i.e. iteration doesn't start on call because it's wrapped "
"inside a function), as a result of no allocation for intermediate value. "
"That's what makes `Iter` superior for traversing through sequence: no extra "
"cost. MoonBit encourages user to pass an `Iter` across functions instead of "
"the sequence object itself."
msgstr ""
"像 `filter` `map` 这样的方法在序列对象（例如 Array）上非常常见。但是，`Iter` 的不同之处在于，任何构造新 `Iter` "
"的方法都是**惰性**的（即在调用时不会开始迭代，因为它被包装在一个函数内），因此不会为中间值分配内存。这就是使 `Iter` "
"优于遍历序列的原因：没有额外的成本。MoonBit 鼓励用户将 `Iter` 传递给函数，而不是传递序列对象本身。"

#: ../../language/fundamentals.md:1064
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement `Iter`,"
" namely, a function that returns an `Iter[S]`. Take `Bytes` as an example:"
msgstr ""
"预定义的序列结构如 `Array` 及其迭代器应该足够使用。但是，为了在自定义序列（元素类型为 `S`）中使用这些方法，我们需要实现 "
"`Iter`，即返回 `Iter[S]` 的函数。以 `Bytes` 为例："

#: ../../language/fundamentals.md:1069
msgid ""
"///|\n"
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"    for byte in data {\n"
"      guard visit(byte) is IterContinue else { break IterEnd }\n"
"    } else {\n"
"      IterContinue\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1075
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the only"
" main difference being the code block that actually does the iteration."
msgstr "几乎所有 `Iter` 实现都与 `Bytes` 的实现相同，唯一的主要区别是实际执行迭代的代码块。"

#: ../../language/fundamentals.md:1078
msgid "Implementation details"
msgstr "实现细节"

#: ../../language/fundamentals.md:1080
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration "
"which consists any of the 2 states:"
msgstr ""
"类型 `Iter[T]` 基本上是 `((T) -> IterResult) -> IterResult` "
"的类型别名，它是一个高阶函数，接受一个操作，`IterResult` 是一个枚举对象，用于跟踪当前迭代的状态，包含以下 2 种状态："

#: ../../language/fundamentals.md:1085
msgid "`IterEnd`: marking the end of an iteration"
msgstr "`IterEnd`: 标记迭代结束"

#: ../../language/fundamentals.md:1086
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr "`IterContinue`: 标记迭代结束尚未到达，暗示迭代将在此状态继续"

#: ../../language/fundamentals.md:1088
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use it "
"to transform `Iter[T]` itself to a new state of type `IterResult`. Whether "
"that state being `IterEnd` `IterContinue` depends on the function."
msgstr ""
"简单来说，`Iter[T]` 接受一个函数 `(T) -> IterResult` 并使用它将 `Iter[T]` 本身转换为类型为 "
"`IterResult` 的新状态。"

#: ../../language/fundamentals.md:1092
msgid ""
"Iterator provides a unified way to iterate through data structures, and they"
" can be constructed at basically no cost: as long as `fn(yield)` doesn't "
"execute, the iteration process doesn't start."
msgstr "迭代器提供了一种统一的遍历数据结构的方式，它们基本上可以无成本地构建：只要 `fn(yield)` 不执行，迭代过程就不会开始。"

#: ../../language/fundamentals.md:1096
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all "
"sorts of `Iter` methods might be visually pleasing, but do notice the heavy "
"work underneath the abstraction."
msgstr "`Iter::run()` 在在内部触发迭代。链接各种 `Iter` 方法可能看起来很美观，但请注意抽象层下面的繁重工作。"

#: ../../language/fundamentals.md:1100
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no way "
"to stop unless the end is reached. Methods such as `count()` which counts "
"the number of elements in a iterator looks like an `O(1)` operation but "
"actually has linear time complexity. Carefully use iterators or performance "
"issue might occur."
msgstr ""
"因此，与外部迭代器不同，一旦迭代开始，除非到达末尾，否则无法停止。诸如 `count()` 这样的方法，它计算迭代器中元素的数量看起来像是一个 "
"`O(1)` 操作，但实际上具有线性时间复杂度。请谨慎使用迭代器，否则可能会出现性能问题。"

#: ../../language/fundamentals.md:1106
msgid "Custom Data Types"
msgstr "自定义数据类型"

#: ../../language/fundamentals.md:1108
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr "创建新数据类型有两种方法：`struct` 和 `enum`。"

#: ../../language/fundamentals.md:1110
msgid "Struct"
msgstr "结构体"

#: ../../language/fundamentals.md:1112
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed by "
"field names. A struct can be constructed using a struct literal, which is "
"composed of a set of labeled values and delimited with curly brackets. The "
"type of a struct literal can be automatically inferred if its fields exactly"
" match the type definition. A field can be accessed using the dot syntax "
"`s.f`. If a field is marked as mutable using the keyword `mut`, it can be "
"assigned a new value."
msgstr ""
"在 MoonBit "
"中，结构体类似于元组，但其字段由字段名称索引。可以使用结构体字面量构造结构体，结构体字面量由一组带标签的值组成，并用大括号括起来。如果结构体的字段与类型定义完全匹配，那么结构体字面量的类型可以自动推断。可以使用点语法"
" `s.f` 访问字段。如果使用关键字 `mut` 标记字段为可变的，则可以为其分配新值。"

#: ../../language/fundamentals.md:1114
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1120
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1128
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals.md:1132
msgid "Constructing Struct with Shorthand"
msgstr "使用简写构造结构体"

#: ../../language/fundamentals.md:1134
msgid ""
"If you already have some variable like `name` and `email`, it's redundant to"
" repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr "如果已经有一些变量，如 `name` 和 `email`，在构造结构体时重复这些名称是多余的。可以使用简写，它的行为完全相同："

#: ../../language/fundamentals.md:1136
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:1143
msgid ""
"If there's no other struct that has the same fields, it's redundant to add "
"the struct's name when constructing it:"
msgstr "如果没有其他具有相同字段的结构体，在构造结构体时添加结构体的名称是多余的："

#: ../../language/fundamentals.md:1145
msgid "let u2 = { id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:1152
msgid "Struct Update Syntax"
msgstr "结构体更新语法"

#: ../../language/fundamentals.md:1154
msgid ""
"It's useful to create a new struct based on an existing one, but with some "
"fields updated."
msgstr "可以用这个语法来根据现有结构体创建一个新的结构体，但只更新部分字段。"

#: ../../language/fundamentals.md:1156
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    (\n"
"      $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"      $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1164
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals.md:1168
msgid "Enum"
msgstr "枚举"

#: ../../language/fundamentals.md:1170
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr "枚举类型类似于函数式语言中的代数数据类型。熟悉 C/C++ 的用户可能更喜欢称其为标记联合。"

#: ../../language/fundamentals.md:1172
msgid ""
"An enum can have a set of cases (constructors). Constructor names must start"
" with capitalized letter. You can use these names to construct corresponding"
" cases of an enum, or checking which branch an enum value belongs to in "
"pattern matching:"
msgstr "枚举可以有一组情况（构造函数）。构造函数的名称必须以大写字母开头。可以使用这些名称来构造枚举的相应情况，或在模式匹配中检查枚举值属于哪个分支："

#: ../../language/fundamentals.md:1174
msgid ""
"/// An enum type that represents the ordering relation between two values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""
"/// 一个枚举类型，表示两个值之间的顺序关系，\n"
"/// 有三种情况 \"Smaller\"、\"Greater\" 和 \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"

#: ../../language/fundamentals.md:1180
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""
"/// 比较两个整数之间的顺序关系\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // 当创建一个枚举时，如果目标类型已知，\n"
"    // 可以直接写构造函数名称\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // 但是当目标类型未知时，\n"
"    // 你总是可以使用 `TypeName::Constructor` 来创建一个枚举\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// 输出一个类型为 `Relation` 的值\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // 使用模式匹配来决定 `r` 属于哪种情况\n"
"  match r {\n"
"    // 在模式匹配期间，如果类型已知，\n"
"    // 写构造函数的名称就足够了\n"
"    Smaller => println(\"smaller!\")\n"
"    // 但是你也可以在模式匹配中使用 `TypeName::Constructor` 语法\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1187
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1195
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals.md:1199
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr "枚举情况也可以携带额外数据。以下是使用枚举定义整数列表类型的示例："

#: ../../language/fundamentals.md:1201
msgid ""
"enum Lst {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of the"
" list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, Lst)\n"
"}\n"
msgstr ""
"enum Lst {\n"
"  Nil\n"
"  // 构造函数 `Cons` 携带额外的数据：列表的第一个元素，\n"
"  // 和列表的其余部分\n"
"  Cons(Int, Lst)\n"
"}\n"

#: ../../language/fundamentals.md:1207
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : Lst) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : Lst) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 除了将额外数据绑定到变量之外，\n"
"// 你还可以继续匹配构造函数内部的额外数据。\n"
"// 以下是一个函数，用于判断列表是否只包含一个元素\n"
"fn is_singleton(l : Lst) -> Bool {\n"
"  match l {\n"
"    // 此分支仅匹配形状为 `Cons(_, Nil)` 的值，\n"
"    // 即长度为 1 的列表\n"
"    Cons(_, Nil) => true\n"
"    // 使用 `_` 匹配其他所有情况\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : Lst) -> Unit {\n"
"  // 在模式匹配带有额外数据的枚举时，\n"
"  // 除了决定值属于哪种情况\n"
"  // 你还可以提取该情况内部的额外数据\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // 这里 `x` 和 `xs` 定义了新变量\n"
"    // 而不是引用现有变量，\n"
"    // 如果 `l` 是一个 `Cons`，那么 `Cons` 的额外数据\n"
"    // （第一个元素和列表的其余部分）\n"
"    // 将绑定到 `x` 和 `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1214
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : Lst = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""
"fn main {\n"
"  // 使用 `Cons` 创建值时，必须提供 `Cons` 的额外数据\n"
"  let l : Lst = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"

#: ../../language/fundamentals.md:1222
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals.md:1226
msgid "Constructor with labelled arguments"
msgstr "构造器与带标签参数"

#: ../../language/fundamentals.md:1228
msgid "Enum constructors can have labelled argument:"
msgstr "枚举构造器可以有带标签的参数："

#: ../../language/fundamentals.md:1230
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""
"enum E {\n"
"  // `x` 和 `y` 是有标签参数\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"

#: ../../language/fundamentals.md:1236
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""
"// 使用有标签参数的构造函数进行模式匹配\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` 是 `x=x` 的缩写\n"
"    // 未匹配的有标签参数可以通过 `..` 省略\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1243
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1251
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:1255
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr "也可以像在模式匹配中访问结构体字段一样访问构造函数的有标签参数："

#: ../../language/fundamentals.md:1257
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"suberror NotImplementedError derive(Show)\n"
"\n"
"fn Object::distance_with(\n"
"  self : Object,\n"
"  other : Object,\n"
") -> Double raise NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc.\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), Circle(_)) "
"=>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"suberror NotImplementedError derive(Show)\n"
"\n"
"fn Objecct::distance_with(\n"
"  self : Object,\n"
"  other : Object,\n"
") -> Double raise NotImplementedError {\n"
"  match (self, other) {\n"
"    // 对于通过 `Point(..) as p` 定义的变量，\n"
"    // 编译器知道它必须是构造函数 `Point`，\n"
"    // 因此可以通过 `p.x`、`p.y` 等直接访问 `Point` 的字段。\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), Circle(_)) "
"=>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
"\n"

#: ../../language/fundamentals.md:1263
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with(p2))\n"
"    println(p1.distance_with(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1271
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals.md:1275
msgid "Constructor with mutable fields"
msgstr "构造器与可变字段"

#: ../../language/fundamentals.md:1277
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr "也可以为构造器定义可变字段。这对于定义命令式数据结构特别有用："

#: ../../language/fundamentals.md:1279
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn[X : Compare] Set::insert(self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn[X : Compare] Tree::insert(\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X],\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 使用可变二叉搜索树实现的集合。\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn[X : Compare] Set::insert(self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// 带有亲指针的可变二叉搜索树\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // 只有带标签的参数可以是可变的\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// 将一个新元素插入到二叉搜索树中。\n"
"// 返回新的树\n"
"fn[X : Compare] Tree::insert(\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X],\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // 修改构造器的字段\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // 在这里创建的 `node` 和 `node.left` 之间的循环\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // 树不为空，所以新的树就是原来的树\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1285
msgid "Tuple Struct"
msgstr "元组结构体"

#: ../../language/fundamentals.md:1287
msgid "MoonBit supports a special kind of struct called tuple struct:"
msgstr "MoonBit 支持一种特殊的结构体称为元组结构体："

#: ../../language/fundamentals.md:1289
msgid ""
"struct UserId(Int)\n"
"\n"
"struct UserInfo(UserId, String)\n"
msgstr ""

#: ../../language/fundamentals.md:1295
msgid ""
"Tuple structs are similar to enum with only one constructor (with the same "
"name as the tuple struct itself). So, you can use the constructor to create "
"values, or use pattern matching to extract the underlying representation:"
msgstr "元组结构体类似于只有一个构造函数的枚举（与元组结构体本身的名称相同）。因此，可以使用构造函数创建或使用模式匹配提取底层表示："

#: ../../language/fundamentals.md:1297
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserInfo = UserInfo(id, \"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserInfo(_, uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1305 ../../language/fundamentals.md:1319
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals.md:1309
msgid ""
"Besides pattern matching, you can also use index to access the elements "
"similar to tuple:"
msgstr "除了模式匹配之外，还可以使用索引访问元素，类似于元组："

#: ../../language/fundamentals.md:1311
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let info : UserInfo = UserInfo(id, \"John Doe\")\n"
"  let uid : Int = id.0\n"
"  let uname : String = info.1\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1323
msgid "Type alias"
msgstr "类型别名"

#: ../../language/fundamentals.md:1324
msgid "MoonBit supports type alias via the syntax `type NewType = OldType`:"
msgstr "MoonBit 支持使用语法 `type NewType = OldType` 定义类型别名："

#: ../../language/fundamentals.md:1327
msgid "The old syntax `typealias OldType as NewType` may be removed in the future."
msgstr "旧语法 `typealias OldType as NewType` 可能会在将来被移除。"

#: ../../language/fundamentals.md:1330
msgid ""
"pub type Index = Int\n"
"pub type MyIndex = Int\n"
"pub type MyMap = Map[Int, String]\n"
msgstr ""

#: ../../language/fundamentals.md:1336
msgid ""
"Unlike all other kinds of type declaration above, type alias does not define"
" a new type, it is merely a type macro that behaves exactly the same as its "
"definition. So for example one cannot define new methods or implement traits"
" for a type alias."
msgstr "与上面所有其他类型声明不同，类型别名不定义新类型，它只是一个行为与其定义完全相同的类型宏。因此，例如，不能为类型别名定义新方法或实现特征。"

#: ../../language/fundamentals.md:1341
msgid "Type alias can be used to perform incremental code refactor."
msgstr "类型别名可用于执行增量代码重构。"

#: ../../language/fundamentals.md:1343
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you can"
" leave a type alias `type T = @pkgB.T` in `@pkgA`, and **incrementally** "
"port uses of `@pkgA.T` to `@pkgB.T`. The type alias can be removed after all"
" uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr "例如，如果要将类型 `T` 从 `@pkgA` 移动到 `@pkgB`，可以在 `@pkgA` 中留下一个类型别名 `type T = @pkgB.T`，"

#: ../../language/fundamentals.md:1348
msgid "Local types"
msgstr "本地类型"

#: ../../language/fundamentals.md:1350
msgid ""
"MoonBit supports declaring structs/enums at the top of a toplevel function, "
"which are only visible within the current toplevel function. These local "
"types can use the generic parameters of the toplevel function but cannot "
"introduce additional generic parameters themselves. Local types can derive "
"methods using derive, but no additional methods can be defined manually. For"
"  example:"
msgstr ""
"MoonBit "
"支持在顶层函数的顶部声明结构体/枚举，这些类型仅在当前顶层函数中可见。这些本地类型可以使用顶层函数的泛型参数，但不能引入额外的泛型参数。本地类型可以使用"
" derive 派生方法，但不能手动定义额外的方法。例如："

#: ../../language/fundamentals.md:1357
msgid ""
"fn[T : Show] toplevel(x : T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a : (String, T)\n"
"  } derive(Show)\n"
"  struct LocalStructTuple(T) derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1363
msgid "Currently, local types do not support being declared as error types."
msgstr "目前，本地类型不支持声明为错误类型。"

#: ../../language/fundamentals.md:1365
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../language/fundamentals.md:1367
msgid ""
"Pattern matching allows us to match on specific pattern and bind data from "
"data structures."
msgstr "模式匹配允许我们匹配特定模式并从数据结构中绑定数据。"

#: ../../language/fundamentals.md:1369
msgid "Simple Patterns"
msgstr "简单模式"

#: ../../language/fundamentals.md:1371
msgid "We can pattern match expressions against"
msgstr "我们可以将表达式与以下内容进行模式匹配："

#: ../../language/fundamentals.md:1373
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr "字面量，例如布尔值、数字、字符、字符串等"

#: ../../language/fundamentals.md:1374
msgid "constants"
msgstr "常量"

#: ../../language/fundamentals.md:1375
msgid "structs"
msgstr "结构体"

#: ../../language/fundamentals.md:1376
msgid "enums"
msgstr "枚举"

#: ../../language/fundamentals.md:1377
msgid "arrays"
msgstr "数组"

#: ../../language/fundamentals.md:1378
msgid "maps"
msgstr "键值对"

#: ../../language/fundamentals.md:1379
msgid "JSONs"
msgstr "JSON"

#: ../../language/fundamentals.md:1381
msgid ""
"and so on. We can define identifiers to bind the matched values so that they"
" can be used later."
msgstr "等等。我们可以定义标识符来绑定匹配的值，以便稍后使用。"

#: ../../language/fundamentals.md:1383
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1390
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use `..`"
" to ignore remaining fields of struct or enum, or array (see [array pattern"
"](#array-pattern))."
msgstr ""
"我们可以使用 `_` 作为我们不关心的值的通配符，并使用 `..` 忽略结构体或枚举的剩余字段，或数组（参见 [数组模式](#array-"
"pattern））。"

#: ../../language/fundamentals.md:1392
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~ : String, payload~ : T)\n"
"}\n"
"\n"
"fn[T] match_point(p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1399
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to match "
"several cases at once. A variable name can only be bound once in a single "
"pattern, and the same set of variables should be bound on both sides of `|` "
"patterns."
msgstr ""
"我们可以使用 `as` 为某些模式命名，可以使用 `|` 一次匹配多个情况。在单个模式中，变量名只能绑定一次，并且在 `|` "
"模式的两侧应绑定相同的变量集。"

#: ../../language/fundamentals.md:1401
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1408
msgid "Array Pattern"
msgstr "数组模式"

#: ../../language/fundamentals.md:1410
msgid ""
"Array patterns can be used to match on the following types to obtain their "
"corresponding elements or views:"
msgstr "数组模式可以用来匹配以下类型以获取其对应的元素或视图（View）："

#: ../../language/fundamentals.md:1401
msgid "Type"
msgstr "类型"

#: ../../language/fundamentals.md:1401
msgid "Element"
msgstr "元素"

#: ../../language/fundamentals.md:1401
msgid "View"
msgstr "视图"

#: ../../language/fundamentals.md:1401
msgid "Array[T], ArrayView[T], FixedArray[T]"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "T"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "ArrayView[T]"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "Bytes, BytesView"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "Byte"
msgstr "字节"

#: ../../language/fundamentals.md:1401
msgid "BytesView"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "String, StringView"
msgstr ""

#: ../../language/fundamentals.md:1401
msgid "StringView"
msgstr ""

#: ../../language/fundamentals.md:1420
msgid "Array patterns have the following forms:"
msgstr "数组模式可以有以下形式："

#: ../../language/fundamentals.md:1422
msgid "`[]` : matching for empty array"
msgstr "`[]`：匹配空数组"

#: ../../language/fundamentals.md:1423
msgid ""
"`[pa, pb, pc]` : matching for array of length three, and bind `pa`, `pb`, "
"`pc` to the three elements"
msgstr "`[pa, pb, pc]`：匹配长度为 3 的数组，并将其中的元素分别绑定到 `pa`, `pb`, `pc`"

#: ../../language/fundamentals.md:1425
msgid ""
"`[pa, ..rest, pb]` : matching for array with at least two elements, and bind"
" `pa` to the first element, `pb` to the last element, and `rest` to the "
"remaining elements. the binder `rest` can be omitted if the rest of the "
"elements are not needed. Arbitrary number of elements are allowed preceding "
"and following the `..` part. Because `..` can match uncertain number of "
"elements, it can appear at most once in an array pattern."
msgstr ""
"`[pa, ..rest, pb]`：匹配至少有两个元素的数组，并将第一个元素绑定到`pa`，最后一个元素绑定到 `pb`，其余元素绑定到 "
"`rest`。如果不需要其余元素，可以省略绑定 `rest`。在 `..` 部分前后允许任意数量的元素。由于 `..` "
"可以匹配不确定数量的元素，因此在数组模式中最多只能出现一次。"

#: ../../language/fundamentals.md:1432
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  if ary is [a, b, .. rest] && a == 1 && b == 2 && rest.length() == 2 {\n"
"    inspect(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  } else {\n"
"    fail(\"\")\n"
"  }\n"
"  guard ary is [.., a, b] else { fail(\"\") }\n"
"  inspect(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1438
msgid ""
"Array patterns provide a unicode-safe way to manipulate strings, meaning "
"that it respects the code unit boundaries. For example, we can check if a "
"string is a  palindrome:"
msgstr ""
"数组模式提供了一种 Unicode 安全的方式来操作字符串，这意味着它在访问元素的时候不会跨越代码单元边界。例如，我们可以检查一个包含 Unicode "
"的字符串是否是回文："

#: ../../language/fundamentals.md:1442
msgid ""
"test {\n"
"  fn palindrome(s : String) -> Bool {\n"
"    loop s.view() {\n"
"      [] | [_] => true\n"
"      [a, .. rest, b] => if a == b { continue rest } else { false }\n"
"    }\n"
"  }\n"
"\n"
"  inspect(palindrome(\"abba\"), content=\"true\")\n"
"  inspect(palindrome(\"中b中\"), content=\"true\")\n"
"  inspect(palindrome(\"文bb中\"), content=\"false\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1448
msgid ""
"When there are consecutive char or byte constants in an array pattern, the "
"pattern spread `..` operator can be used to combine them to make the code "
"look cleaner. Note that in this case the `..` followed by string or bytes "
"constant matches exact number of elements so its usage is not limited to "
"once."
msgstr ""
"当数组模式中有连续的字符或字节常量时，可以使用模式展开 `..` 运算符将它们组合起来，使代码看起来更整洁。在这种情况下，`..` "
"后跟字符串或字节常量匹配确切数量的元素，因此它可以在数组模式中多次使用。"

#: ../../language/fundamentals.md:1453
msgid ""
"const NO : Bytes = \"no\"\n"
"\n"
"test {\n"
"  fn match_string(s : String) -> Bool {\n"
"    match s {\n"
"      [.. \"yes\", ..] => true // equivalent to ['y', 'e', 's', ..]\n"
"    }\n"
"  }\n"
"\n"
"  fn match_bytes(b : Bytes) -> Bool {\n"
"    match b {\n"
"      [.. NO, ..] => false // equivalent to ['n', 'o', ..]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1459
msgid "Range Pattern"
msgstr "范围模式"

#: ../../language/fundamentals.md:1460
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the "
"value falls in a specific range."
msgstr "对于内置整数类型和 `Char`，MoonBit 允许匹配值是否落在特定范围内。"

#: ../../language/fundamentals.md:1462
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the upper"
" bound is exclusive, and `..=` means inclusive upper bound. `a` and `b` can "
"be one of:"
msgstr "范围模式的形式为 `a..<b` 或 `a..=b`，其中 `..<` 表示上限是排他的，`..=` 表示包含上限。`a` 和 `b` 可以是以下之一："

#: ../../language/fundamentals.md:1465
msgid "literal"
msgstr "字面量"

#: ../../language/fundamentals.md:1466
msgid "named constant declared with `const`"
msgstr "使用 `const` 声明的常量"

#: ../../language/fundamentals.md:1467
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr "`_`，表示此模式在此侧没有限制"

#: ../../language/fundamentals.md:1469
msgid "Here are some examples:"
msgstr "以下是一些示例："

#: ../../language/fundamentals.md:1471
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1478
msgid "Map Pattern"
msgstr "Map 模式"

#: ../../language/fundamentals.md:1480
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a map"
" pattern, the `key : value` syntax will match if `key` exists in the map, "
"and match the value of `key` with pattern `value`. The `key? : value` syntax"
" will match no matter `key` exists or not, and `value` will be matched "
"against `map[key]` (an optional)."
msgstr ""
"MoonBit 允许在类似 map 的数据结构上方便地进行匹配。在 map 模式内，`key : value` 语法将在 map 中存在 `key` "
"时匹配，并将 `key` 的值与模式 `value` 匹配。`key? : value` 语法将无论 `key` 是否存在都匹配，`value` 将与 "
"`map[key]`（一个可选项）匹配。"

#: ../../language/fundamentals.md:1484
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _, .. } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" exists "
"in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""
"match map {\n"
"  // 仅在 `map` 中存在 \"b\" 时匹配\n"
"  { \"b\": _, .. } => ...\n"
"  // 仅在 `map` 中不存在 \"b\" 且 \"a\" 存在于 `map` 时匹配。\n"
"  // 匹配时，将 `map` 中的 \"a\" 的值绑定到 `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // 编译器报告缺失的情况：{ \"b\"? : None, \"a\"? : None }\n"
"}\n"

#: ../../language/fundamentals.md:1491
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and "
"trait](./methods.md))."
msgstr ""
"要使用 map 模式匹配数据类型 `T`，`T` 必须具有某种类型 `K` 和 `V` 的方法 `op_get(Self, K) -> "
"Option[V]`（请参见 [方法和特征](./methods.md)）。"

#: ../../language/fundamentals.md:1492
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr "目前，map 模式的键部分必须是字面量或常量"

#: ../../language/fundamentals.md:1493
msgid ""
"Map patterns are always open: the unmatched keys are silently ignored, and "
"`..` needs to be added to identify this nature"
msgstr "Map 模式始终是开放的：未匹配的键会被静默忽略，并且需要添加 `..` 以显示这一点"

#: ../../language/fundamentals.md:1494
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched at"
" most once"
msgstr "Map 模式将编译为高效的代码：每个键最多只会被获取一次"

#: ../../language/fundamentals.md:1496
msgid "Json Pattern"
msgstr "Json 模式"

#: ../../language/fundamentals.md:1498
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr "当匹配的值具有类型 `Json` 时，可以直接使用字面量模式，以及构造函数："

#: ../../language/fundamentals.md:1500
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports, .. } => ...\n"
"  { \"version\": Number(i, ..), \"import\": Array(imports), .. } => ...\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1507
msgid "Guard condition"
msgstr "守卫条件"

#: ../../language/fundamentals.md:1509
msgid ""
"Each case in a pattern matching expression can have a guard condition. A "
"guard condition is a boolean expression that must be true for the case to be"
" matched. If the guard condition is false, the case is skipped and the next "
"case is tried. For example:"
msgstr "模式匹配表达式中的每个分支都可以有一个守卫条件。守卫条件是一个布尔表达式，只有当该条件为真时，对应的分支才会被匹配。如果守卫条件为假，则跳过该分支并尝试下一个分支。例如："

#: ../../language/fundamentals.md:1513
msgid ""
"fn guard_cond(x : Int?) -> Int {\n"
"  fn f(x : Int) -> Array[Int] {\n"
"    [x, x + 42]\n"
"  }\n"
"\n"
"  match x {\n"
"    Some(a) if f(a) is [0, b] => a + b\n"
"    Some(b) => b\n"
"    None => -1\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(guard_cond(None), -1)\n"
"  assert_eq(guard_cond(Some(0)), 42)\n"
"  assert_eq(guard_cond(Some(1)), 1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1520
msgid ""
"Note that the guard conditions will not be considered when checking if all "
"patterns are covered by the match expression. So you will see a warning of "
"partial match for the following case:"
msgstr "注意，在检查所有模式是否都被匹配表达式覆盖时，不会考虑守卫条件。因此，您会看到以下情况的警告："

#: ../../language/fundamentals.md:1524
msgid ""
"fn guard_check(x : Int?) -> Unit {\n"
"  match x {\n"
"    Some(a) if a >= 0 => ()\n"
"    Some(a) if a < 0 => ()\n"
"    None => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1532
msgid ""
"It is not encouraged to call a function that mutates a part of the value "
"being matched inside a guard condition. When such case happens, the part "
"being mutated will not be re-evaluated in the subsequent patterns. Use it "
"with caution."
msgstr "不鼓励在守卫条件中调用可能通过副作用改变被匹配的值的函数。在这种情况下，被改变的部分不会在后续模式中重新求值。请谨慎使用。"

#: ../../language/fundamentals.md:1537
msgid "Generics"
msgstr "泛型"

#: ../../language/fundamentals.md:1539
msgid ""
"Generics are supported in top-level function and data type definitions. Type"
" parameters can be introduced within square brackets. We can rewrite the "
"aforementioned data type `List` to add a type parameter `T` to obtain a "
"generic version of lists. We can then define generic functions over lists "
"like `map` and `reduce`."
msgstr ""
"泛型在顶层函数和数据类型定义中受支持。可以在方括号内引入类型参数。我们可以重写上述数据类型 `List`，添加类型参数 `T` "
"以获得列表的通用版本。然后，我们可以定义列表上的通用函数，如 `map` 和 `reduce`。"

#: ../../language/fundamentals.md:1541
msgid ""
"///|\n"
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"///|\n"
"fn[S, T] List::map(self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), xs.map(f))\n"
"  }\n"
"}\n"
"\n"
"///|\n"
"fn[S, T] List::reduce(self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => xs.reduce(op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1545
msgid "Special Syntax"
msgstr "特殊语法"

#: ../../language/fundamentals.md:1547
msgid "Pipelines"
msgstr "管道"

#: ../../language/fundamentals.md:1549
msgid ""
"MoonBit provides a convenient pipe syntax `x |> f(y)`, which can be used to "
"chain regular function calls:"
msgstr "MoonBit 提供了一个方便的管道语法`x |> f(y)`，可以用于链接常规函数调用："

#: ../../language/fundamentals.md:1551
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> Array::push(5) // <=> Array::push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> x => { x + 1 }\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals.md:1558
msgid ""
"The MoonBit code follows the *data-first* style, meaning the function places"
" its \"subject\" as the first argument.  Thus, the pipe operator inserts the"
" left-hand side value into the first argument of the right-hand side "
"function call by default.  For example, `x |> f(y)` is equivalent to `f(x, "
"y)`."
msgstr ""
"MoonBit "
"代码遵循*数据优先*风格，也就是说，函数将它的“主题”放置在第一个参数的位置。所以，管道默认将左侧的值填入右侧的函数调用的第一个参数的位置。例如`x "
"|> f(y)`等价于`f(x,y)`。"

#: ../../language/fundamentals.md:1562
msgid ""
"You can use the `_` operator to insert `x` into any argument of the function"
" `f`, such as `x |> f(y, _)`, which is equivalent to `f(y, x)`. Labeled "
"arguments are also supported."
msgstr "你也可以使用`_`操作符改变`x`在函数`f`的调用中的插入位置，例如`x |> f(y, _)`, 这等价于`f(y,x)`。带标签的参数也是支持的。"

#: ../../language/fundamentals.md:1565
msgid ""
"The pipe operator can also connect to an arrow function. When piping into an"
" arrow function, the function body must be wrapped in curly braces, for "
"example `value |> x => { x + 1 }`."
msgstr ""
"管道操作符也可以连接到箭头函数。通过管道传入箭头函数时，函数体必须用花括号包裹，例如 "
"`value |> x => { x + 1 }`。"

#: ../../language/fundamentals.md:1567
msgid "Cascade Operator"
msgstr "级联运算符"

#: ../../language/fundamentals.md:1567
msgid ""
"The cascade operator `..` is used to perform a series of mutable operations "
"on the same value consecutively. The syntax is as follows:"
msgstr "级联运算符`..`用于连续对同一值执行一系列可变操作。语法如下："

#: ../../language/fundamentals.md:1570
msgid "[]..append([1])\n"
msgstr ""

#: ../../language/fundamentals.md:1577
msgid "`x..f()..g()` is equivalent to `{ x.f(); x.g(); }`."
msgstr "`x..f()..g()` 等价于 `{x.f(); x.g(); }`。"

#: ../../language/fundamentals.md:1578
msgid "`x..f().g()` is equivalent to `{ x.f(); x.g(); }`."
msgstr "`x..f().g()` 等价于 `{x.f(); x.g(); }`。"

#: ../../language/fundamentals.md:1581
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has methods"
" like `write_string`, `write_char`, `write_object`, etc., we often need to "
"perform a series of operations on the same `StringBuilder` value:"
msgstr "考虑以下情况：对于具有诸如`write_string`，`write_char`，`write_object`等方法的`StringBuilder`类型，我们经常需要对同一`StringBuilder`值执行一系列操作："

#: ../../language/fundamentals.md:1585
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1592
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed to "
"return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used "
"for consecutive operations without the need to modify the return type of the"
" methods."
msgstr ""
"为了避免重复输入`builder`，其方法通常设计为返回`self`本身，允许使用`.`运算符链接操作。为了区分不可变和可变操作，在 MoonBit "
"中，对于所有返回`Unit`的方法，可以使用级联运算符进行连续操作，而无需修改方法的返回类型。"

#: ../../language/fundamentals.md:1598
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1605
msgid "is Expression"
msgstr "is 表达式"

#: ../../language/fundamentals.md:1607
msgid ""
"The `is` expression tests whether a value conforms to a specific pattern. It"
" returns a `Bool` value and can be used anywhere a boolean value is "
"expected, for example:"
msgstr "`is` 表达式测试值是否符合特定模式。它返回一个 `Bool` 值，并可以在期望布尔值的任何地方使用，例如："

#: ../../language/fundamentals.md:1611
msgid ""
"fn[T] is_none(x : T?) -> Bool {\n"
"  x is None\n"
"}\n"
"\n"
"fn start_with_lower_letter(s : String) -> Bool {\n"
"  s is ['a'..='z', ..]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1618
msgid ""
"Pattern binders introduced by `is` expressions can be used in the following "
"contexts:"
msgstr "通过 `is` 表达式绑定的标识符可以在以下的上下文中使用："

#: ../../language/fundamentals.md:1621
msgid ""
"In boolean AND expressions (`&&`): binders introduced in the left-hand "
"expression can be used in the right-hand expression"
msgstr "在与表达式（`&&`）中：左侧表达式中绑定的标识符可以在右侧表达式中使用"

#: ../../language/fundamentals.md:1625
msgid ""
"fn f(x : Int?) -> Bool {\n"
"  x is Some(v) && v >= 0\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1632
msgid ""
"In the first branch of `if` expression: if the condition is a sequence of "
"boolean expressions `e1 && e2 && ...`, the binders introduced by the `is` "
"expression can be used in the branch where the condition evaluates to "
"`true`."
msgstr ""
"在 `if` 的第一个分支中：如果条件是一系列布尔表达式 `e1 && e2 && ...`，则可以在条件为真的分支中使用 `is` "
"表达式中绑定的标识符。"

#: ../../language/fundamentals.md:1636
msgid ""
"fn g(x : Array[Int?]) -> Unit {\n"
"  if x is [v, .. rest] && v is Some(i) && i is (0..=10) {\n"
"    println(v)\n"
"    println(i)\n"
"    println(rest)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1643
msgid "In the following statements of a `guard` condition:"
msgstr "下面举一个在 `guard` 中使用的情况："

#: ../../language/fundamentals.md:1645
msgid ""
"fn h(x : Int?) -> Unit {\n"
"  guard x is Some(v)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1652
msgid "In the body of a `while` loop:"
msgstr "在 `while` 循环中的使用："

#: ../../language/fundamentals.md:1654
msgid ""
"fn i(x : Int?) -> Unit {\n"
"  let mut m = x\n"
"  while m is Some(v) {\n"
"    println(v)\n"
"    m = None\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1661
msgid ""
"Note that `is` expression can only take a simple pattern. If you need to use"
" `as` to bind the pattern to a variable, you have to add parentheses. For "
"example:"
msgstr "`is` 表达式只能接受一个简单模式，如果你需要通过 `as` 把模式绑定到某个变量上，需要加括号。比如："

#: ../../language/fundamentals.md:1664
msgid ""
"fn j(x : Int) -> Int? {\n"
"  Some(x)\n"
"}\n"
"\n"
"fn init {\n"
"  guard j(42) is (Some(a) as b)\n"
"  println(a)\n"
"  println(b)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1671
msgid "Spread Operator"
msgstr "展开运算符"

#: ../../language/fundamentals.md:1673
msgid ""
"MoonBit provides a spread operator to expand a sequence of elements when "
"constructing `Array`, `String`, and `Bytes` using the array literal syntax. "
"To expand such a sequence, it needs to be prefixed with `..`, and it must "
"have `iter()` method that yields the corresponding type of element."
msgstr ""
"MoonBit 提供了一个展开运算符，用于在使用数组字面量语法构造 `Array`、`String`和 `Bytes` "
"时展开元素序列。要展开这样的序列，需要在其前面加上 `..` 前缀，并且该序列必须具有 `iter()` 方法，并且该方法能够产生相应类型的元素。"

#: ../../language/fundamentals.md:1678
msgid "For example, we can use the spread operator to construct an array:"
msgstr "例如，我们可以使用展开运算符构造一个数组："

#: ../../language/fundamentals.md:1680
msgid ""
"test {\n"
"  let a1 : Array[Int] = [1, 2, 3]\n"
"  let a2 : FixedArray[Int] = [4, 5, 6]\n"
"  let a3 : @list.List[Int] = @list.from_array([7, 8, 9])\n"
"  let a : Array[Int] = [..a1, ..a2, ..a3, 10]\n"
"  inspect(a, content=\"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1687
msgid "Similarly, we can use the spread operator to construct a string:"
msgstr "同样，我们可以使用展开运算符构造一个字符串："

#: ../../language/fundamentals.md:1689
msgid ""
"test {\n"
"  let s1 : String = \"Hello\"\n"
"  let s2 : StringView = \"World\".view()\n"
"  let s3 : Array[Char] = [..s1, ' ', ..s2, '!']\n"
"  let s : String = [..s1, ' ', ..s2, '!', ..s3]\n"
"  inspect(s, content=\"Hello World!Hello World!\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1696
msgid ""
"The last example shows how the spread operator can be used to construct a "
"bytes sequence."
msgstr "最后一个例子展示了如何使用展开运算符构造一个字节序列。"

#: ../../language/fundamentals.md:1699
msgid ""
"test {\n"
"  let b1 : Bytes = \"hello\"\n"
"  let b2 : BytesView = b1[1:4]\n"
"  let b : Bytes = [..b1, ..b2, 10]\n"
"  inspect(\n"
"    b,\n"
"    content=(\n"
"      #|b\"helloell\\x0a\"\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1707
msgid "TODO syntax"
msgstr "TODO 语法"

#: ../../language/fundamentals.md:1709
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of "
"code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr "`todo`语法 (`...`) 是一种特殊构造，用于标记尚未实现或用于未来功能的占位符代码段。例如："

#: ../../language/fundamentals.md:1711
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#~ msgid ""
#~ "This section covers the core language "
#~ "concepts, split into smaller pages for "
#~ "easier navigation and translation."
#~ msgstr ""
