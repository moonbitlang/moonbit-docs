# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/error_codes/E0013.md:1
msgid "E0013"
msgstr ""

#: ../../language/error_codes/E0013.md:3
msgid "The type of this expression contains unresolved type variables."
msgstr "这个表达式的类型包含未解析的类型变量。"

#: ../../language/error_codes/E0013.md:5
msgid ""
"This error occurs when the compiler encounters a type that contains type "
"variables which cannot be determined from the context. Type variables are "
"placeholders for types that should be inferred by the compiler."
msgstr "当编译器遇到无法从上下文确定的类型变量时，将会出现此错误。类型变量是应由编译器推断的类型的占位符。"

#: ../../language/error_codes/E0013.md:9
msgid "Common cases where this happens:"
msgstr "常见情况："

#: ../../language/error_codes/E0013.md:11
msgid "Writing local functions without explicit type annotations"
msgstr "编写没有明确类型注释的局部函数"

#: ../../language/error_codes/E0013.md:12
msgid ""
"Creating empty collections (Arrays, Options) without specifying their "
"element type"
msgstr "创建空集合（数组，选项），而未指定其元素类型。"

#: ../../language/error_codes/E0013.md:15
msgid ""
"When the compiler cannot resolve these type variables, it defaults them to "
"`Unit` type, which may not be what you intended."
msgstr "当编译器无法解析这些类型变量时，它将其默认为 `Unit` 类型，这可能并不是你所期望的。"

#: ../../language/error_codes/E0013.md:18
msgid "Erroneous example"
msgstr "错误示例"

#: ../../language/error_codes/E0013.md:20
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x) {\n"
"//     ^ Warning: The type of this expression is Option[_/0], which contains"
"\n"
"//                unresolved type variables. The type variable is default to"
"\n"
"//                Unit.\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"\n"
"  f(None)\n"
"}\n"
"\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[_]) -> Int {\n"
"//     ^ Warning: The type of this expression is Array[_/0], which contains\n"
"//                unresolved type variables. The type variable is default to"
"\n"
"//                Unit.\n"
"    x.length()\n"
"  }\n"
"\n"
"  println(f([]))\n"
"}\n"
"\n"
"fn main {\n"
"  let a = []\n"
"//        ^^ Warning: The type of this expression is Array[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(a.length())\n"
"  let b = None\n"
"//        ^^ Warning: The type of this expression is Option[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(b.is_empty())\n"
"}\n"
"\n"
msgstr ""

#: ../../language/error_codes/E0013.md:24
msgid "Suggestion"
msgstr "建议"

#: ../../language/error_codes/E0013.md:26
msgid "To fix this warning, you can:"
msgstr "要修复这个警告，你可以："

#: ../../language/error_codes/E0013.md:28
msgid "Add type annotations to local function parameters. For example,"
msgstr "为局部类型函数参数添加类型注释。例如："

#: ../../language/error_codes/E0013.md:30
msgid ""
"///|\n"
"pub fn f1() -> Unit {\n"
"  fn f(x : Int?) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"\n"
"  f(None)\n"
"}\n"
"\n"
"///|\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[Int]) -> Int {\n"
"    x.length()\n"
"  }\n"
"\n"
"  println(f([]))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E0013.md:34
msgid "Explicitly specify the type of the variable or the collection element type."
msgstr "显式指定变量或集合元素的类型。"

#: ../../language/error_codes/E0013.md:36
msgid ""
"///|\n"
"fn example_explicit_variable_types() -> Unit {\n"
"  let a : Array[Int] = []\n"
"  println(a.length())\n"
"  let b : Int? = None\n"
"  println(b is None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E0013.md:40
msgid "Or equivalently, add annotations on the collection creation."
msgstr "或者，等效地，在集合创建时添加类型注释。"

#: ../../language/error_codes/E0013.md:42
msgid ""
"///|\n"
"fn example_annotated_collections() -> Unit {\n"
"  let a = ([] : Array[Int])\n"
"  println(a.length())\n"
"  let b = (None : Int?)\n"
"  println(b is None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E0013.md:46
msgid "Provide enough context through usage."
msgstr "通过使用提供足够的上下文。"

#: ../../language/error_codes/E0013.md:48
msgid ""
"///|\n"
"fn example_context_usage() -> Unit {\n"
"  fn f(x) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a + 1)\n"
"      //                ^^^^^ through this usage, the compiler can infer the"
"\n"
"      //                      type of `x` is `Option[Int]`.\n"
"    }\n"
"  }\n"
"\n"
"  f(None)\n"
"}\n"
msgstr ""

