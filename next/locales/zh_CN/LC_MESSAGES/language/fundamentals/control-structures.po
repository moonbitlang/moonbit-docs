# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals/control-structures.md:1
msgid "Control Structures"
msgstr "控制结构"

#: ../../language/fundamentals/control-structures.md:3
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../language/fundamentals/control-structures.md:5
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr "条件表达式由条件、结果和可选的 `else` 子句或 `else if` 子句组成。"

#: ../../language/fundamentals/control-structures.md:7
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:14
msgid "The curly brackets around the consequent are required."
msgstr "结果周围的大括号是必需的。"

#: ../../language/fundamentals/control-structures.md:16
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and "
"the return values of the consequent and the else clause must be of the same "
"type. Here is an example:"
msgstr "请注意，条件表达式在 MoonBit 中始终返回一个值，结果和 else 子句的返回值必须是相同的类型。以下是一个示例："

#: ../../language/fundamentals/control-structures.md:18
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:25
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr "`else` 子句只有在返回值的类型为 `Unit`的时候省略。"

#: ../../language/fundamentals/control-structures.md:27
msgid "Match Expression"
msgstr "匹配表达式"

#: ../../language/fundamentals/control-structures.md:29
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](pattern-matching.md) to decide which consequent to "
"evaluate and extracting variables at the same time."
msgstr ""

#: ../../language/fundamentals/control-structures.md:31
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:38
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, and "
"the program will terminate if that case were reached."
msgstr "如果省略了可能的条件，编译器将发出警告；如果真的出现该情况，程序将终止。"

#: ../../language/fundamentals/control-structures.md:40
msgid "Guard Statement"
msgstr "卫语句"

#: ../../language/fundamentals/control-structures.md:42
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing the"
" subsequent statements and returns. If the condition is not satisfied (i.e.,"
" false), the code in the `else` block is executed and its evaluation result "
"is returned (the subsequent statements are skipped)."
msgstr ""
"`guard` 语句用于检查指定的不变量。如果不变量的条件得到满足，程序将继续执行后续语句。如果条件不满足（即为假），则执行 `else` "
"块中的代码且返回其值（并跳过后续语句）。"

#: ../../language/fundamentals/control-structures.md:47
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:54
msgid "Guard statement and is expression"
msgstr "卫语句与 is 表达式"

#: ../../language/fundamentals/control-structures.md:56
msgid ""
"The `let` statement can be used with [pattern matching](pattern-"
"matching.md). However, `let` statement can only handle one case. And using "
"[is expression](special-syntax.md#is-expression) with `guard` statement can "
"solve this issue."
msgstr ""

#: ../../language/fundamentals/control-structures.md:58
msgid ""
"In the following example, `getProcessedText` assumes that the input `path` "
"points to resources that are all plain text, and it uses the `guard` "
"statement to ensure this invariant while extracting the plain text resource."
" Compared to using a `match` statement, the subsequent processing of `text` "
"can have one less level of indentation."
msgstr ""
"在以下示例中，`getProcessedText` 假设输入的 `path` 指向的资源都是纯文本，并使用 `guard` "
"语句来在确保这个不变量的同时，解构出纯文本资源。与使用 `match` 语句相比，`text` 的后续处理可以少一级缩进。"

#: ../../language/fundamentals/control-structures.md:62
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String,\n"
") -> String raise Error {\n"
"  guard resources.get(path) is Some(resource) else { fail(\"\\{path} not "
"found\") }\n"
"  guard resource is PlainText(text) else { fail(\"\\{path} is not plain "
"text\") }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:68
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr "如果省略了 `else` 部分，程序将在 `guard` 语句中指定的条件不为真或无法匹配时终止。"

#: ../../language/fundamentals/control-structures.md:71
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard expr is Some(x)\n"
"// <=> guard expr is Some(x) else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:78
msgid "While loop"
msgstr "While 循环"

#: ../../language/fundamentals/control-structures.md:80
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code repeatedly "
"as long as a condition is true. The condition is evaluated before executing "
"the block of code. The `while` loop is defined using the `while` keyword, "
"followed by a condition and the loop body. The loop body is a sequence of "
"statements. The loop body is executed as long as the condition is true."
msgstr ""
"在 MoonBit 中，`while` 循环可用于在条件为真时重复执行一段代码块。在执行代码块之前，将评估条件。使用 `while` 关键字定义 "
"`while` 循环，后跟条件和循环体。循环体是一系列语句。只要条件为真，就会执行循环体。"

#: ../../language/fundamentals/control-structures.md:82
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:90
#: ../../language/fundamentals/control-structures.md:104
#: ../../language/fundamentals/control-structures.md:118
#: ../../language/fundamentals/control-structures.md:132
#: ../../language/fundamentals/control-structures.md:144
#: ../../language/fundamentals/control-structures.md:161
#: ../../language/fundamentals/control-structures.md:199
#: ../../language/fundamentals/control-structures.md:246
#: ../../language/fundamentals/control-structures.md:260
msgid "Output"
msgstr "输出"

#: ../../language/fundamentals/control-structures.md:90
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:94
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you to "
"exit the current loop, while using `continue` skips the remaining part of "
"the current iteration and proceeds to the next iteration."
msgstr ""
"循环体支持 `break` 和 `continue`。使用 `break` 可以退出当前循环，而使用 `continue` "
"则跳过当前迭代的剩余部分并继续下一次迭代。"

#: ../../language/fundamentals/control-structures.md:96
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:104
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:108
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the "
"loop will end."
msgstr "`while` 循环还支持可选的 `else` 子句。当循环条件变为假时，将执行 `else` 子句，然后循环将结束。"

#: ../../language/fundamentals/control-structures.md:110
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:118
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:122
msgid ""
"When there is an `else` clause, the `while` loop can also return a value. "
"The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value of"
" the `else` clause."
msgstr ""
"当有 `else` 子句时，`while` 循环还可以返回一个值。返回值是 `else` 子句的评估结果。在这种情况下，如果使用 `break` "
"退出循环，需要在 `break` 后提供一个返回值，该返回值应与 `else` 子句的返回值类型相同。"

#: ../../language/fundamentals/control-structures.md:124
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:132
msgid "5\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:136
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:144
msgid "7\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:148
msgid "For Loop"
msgstr "For 循环"

#: ../../language/fundamentals/control-structures.md:150
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by "
"variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. For"
" example, the code below creates a new variable binding `i`, which has a "
"scope throughout the entire loop and is immutable. This makes it easier to "
"write clear code and reason about it:"
msgstr ""
"MoonBit 还支持 C 风格的 For 循环。关键字 `for` "
"后跟由分号分隔的变量初始化子句、循环条件和更新子句。它们不需要用括号括起来。例如，下面的代码创建了一个新的变量绑定 "
"`i`，它在整个循环中都有作用域且是不可变的。这使得编写清晰的代码并对其进行推理更容易："

#: ../../language/fundamentals/control-structures.md:153
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:161
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:165
msgid "The variable initialization clause can create multiple bindings:"
msgstr "变量初始化子句可以创建多个绑定："

#: ../../language/fundamentals/control-structures.md:167
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:174
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In other"
" words, in the example above, the update clause does not execute `i = i + "
"1`, `j = j + 1` sequentially, but rather increments `i` and `j` at the same "
"time. Therefore, when reading the values of the binding variables in the "
"update clause, you will always get the values updated in the previous "
"iteration."
msgstr ""
"应该注意，在更新子句中，当有多个绑定变量时，语义是同时更新它们。换句话说，在上面的示例中，更新子句不会按顺序执行 `i = i + 1`，`j = j "
"+ 1`，而是同时递增 `i` 和 `j`。因此，在更新子句中读取绑定变量的值时，总是会得到上一次迭代中更新的值。"

#: ../../language/fundamentals/control-structures.md:176
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are all"
" optional. For example, the following two are infinite loops:"
msgstr "变量初始化子句、循环条件和更新子句都是可选的。例如，以下两个是无限循环："

#: ../../language/fundamentals/control-structures.md:178
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:185
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. Like "
"the `while` loop, the `for` loop can also return a value using the `break` "
"and `else` clauses."
msgstr ""
"`for` 循环还支持 `continue`、`break` 和 `else` 子句。与 `while` 循环一样，`for` 循环也可以使用 "
"`break` 和 `else` 子句返回一个值。"

#: ../../language/fundamentals/control-structures.md:187
msgid ""
"The `continue` statement skips the remaining part of the current iteration "
"of the `for` loop (including the update clause) and proceeds to the next "
"iteration. The `continue` statement can also update the binding variables of"
" the `for` loop, as long as it is followed by expressions that match the "
"number of binding variables, separated by commas."
msgstr ""
"`continue` 语句跳过当前 `for` 循环的剩余部分（包括更新子句）并继续下一次迭代。`continue` 语句还可以更新 `for` "
"循环的绑定变量，只要后面跟着与绑定变量数量匹配的表达式，用逗号分隔。"

#: ../../language/fundamentals/control-structures.md:189
msgid ""
"For example, the following program calculates the sum of even numbers from 1"
" to 6:"
msgstr "例如，以下程序计算从 1 到 6 的偶数之和："

#: ../../language/fundamentals/control-structures.md:191
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:199
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:203
msgid "`for .. in` loop"
msgstr "`for .. in` 循环"

#: ../../language/fundamentals/control-structures.md:205
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr "MoonBit 支持通过 `for .. in` 循环语法遍历不同数据结构和序列的元素："

#: ../../language/fundamentals/control-structures.md:207
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:214
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard "
"library. Any type with a method `.iter() : Iter[T]` can be traversed using "
"`for .. in`. For more information of the `Iter` type, see "
"[Iterator](iterator.md) below."
msgstr ""

#: ../../language/fundamentals/control-structures.md:217
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr "`for .. in` 循环还支持遍历整数序列，例如："

#: ../../language/fundamentals/control-structures.md:219
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq(i, 45)\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:226
msgid ""
"In addition to sequences of a single value, MoonBit also supports traversing"
" sequences of two values, such as `Map`, via the `Iter2` type in MoonBit's "
"standard library. Any type with method `.iter2() : Iter2[A, B]` can be "
"traversed using `for .. in` with two loop variables:"
msgstr ""
"除了单个值的序列外，MoonBit 还支持通过 MoonBit 标准库中的 `Iter2` 类型遍历两个值的序列，例如 `Map`。任何具有方法 "
"`.iter2() : Iter2[A, B]` 的类型都可以使用两个循环变量的 `for .. in` 进行遍历："

#: ../../language/fundamentals/control-structures.md:229
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:236
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr "另一个使用两个循环变量的 `for .. in` 的示例是在遍历数组时跟踪数组索引："

#: ../../language/fundamentals/control-structures.md:238
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:246
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:250
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr "`for .. in` 循环的主体支持诸如 `return`、`break` 和错误处理等控制流操作："

#: ../../language/fundamentals/control-structures.md:252
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:260
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:264
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr "如果循环变量未使用，可以使用 `_` 忽略它。"

#: ../../language/fundamentals/control-structures.md:266
msgid "Functional loop"
msgstr "函数式循环"

#: ../../language/fundamentals/control-structures.md:268
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to write "
"loops in a functional style."
msgstr "函数式循环是 MoonBit 中的一个强大功能，它使您可以以函数式风格编写循环。"

#: ../../language/fundamentals/control-structures.md:270
msgid ""
"A functional loop consumes an argument and returns a value. It is defined "
"using the `loop` keyword, followed by its argument and the loop body. The "
"loop body is a sequence of clauses, each of which consists of a pattern and "
"an expression. The clause whose pattern matches the input will be executed, "
"and the loop will return the value of the expression. If no pattern matches,"
" the loop will panic. Use the `continue` keyword with arguments to start the"
" next iteration of the loop. Use the `break` keyword with an argument to "
"return a value from the loop. The `break` keyword can be omitted if the "
"value is the last expression in the loop body."
msgstr ""
"函数式循环接收一个参数并返回一个值。它使用 `loop` "
"关键字定义，后跟其参数和循环体。循环体是一系列子句，每个子句由模式和表达式组成。与输入匹配的模式的子句将会被执行，并且循环将返回表达式的值。如果没有对应的模式，程序会中止。使用"
" `continue` 关键字和参数进入循环的下一次迭代。使用 `break` "
"关键字和参数从循环中返回一个值。如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。"

#: ../../language/fundamentals/control-structures.md:272
msgid ""
"test {\n"
"  fn sum(xs : @list.List[Int]) -> Int {\n"
"    loop (xs, 0) {\n"
"      (Empty, acc) => break acc // <=> Nil, acc => acc\n"
"      (More(x, tail=rest), acc) => continue (rest, x + acc)\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq(sum(@list.from_array([1, 2, 3])), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:279
msgid "Use `while true { ... }` or `for { ... }` for infinite loop."
msgstr "使用 `while true { ... }` 或 `for { ... }` 来表示无限循环。"

#: ../../language/fundamentals/control-structures.md:282
msgid "Labelled Continue/Break"
msgstr "带标记的 Continue/Break"

#: ../../language/fundamentals/control-structures.md:284
msgid ""
"When a loop is labelled, it can be referenced from a `break` or `continue` "
"from within a nested loop. For example:"
msgstr "当一个循环被标记的时候，它可以从循环中的 `break` 或者 `continue` 中引用，例如："

#: ../../language/fundamentals/control-structures.md:287
msgid ""
"test \"break label\" {\n"
"  let mut count = 0\n"
"  let xs = [1, 2, 3]\n"
"  let ys = [4, 5, 6]\n"
"  let res = outer~: for i in xs {\n"
"    for j in ys {\n"
"      count = count + i\n"
"      break outer~ j\n"
"    }\n"
"  } else {\n"
"    -1\n"
"  }\n"
"  assert_eq(res, 4)\n"
"  assert_eq(count, 1)\n"
"}\n"
"\n"
"test \"continue label\" {\n"
"  let mut count = 0\n"
"  let init = 10\n"
"  let res = outer~: loop init {\n"
"    0 => 42\n"
"    i =>\n"
"      for {\n"
"        count = count + 1\n"
"        continue outer~ i - 1\n"
"      }\n"
"  }\n"
"  assert_eq(res, 42)\n"
"  assert_eq(count, 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:293
msgid "`defer` expression"
msgstr "`defer` 表达式"

#: ../../language/fundamentals/control-structures.md:295
msgid ""
"`defer` expression can be used to perform reliable resource cleanup. The "
"syntax for `defer` is as follows:"
msgstr "`defer` 表达式可以实现可靠的资源释放。`defer` 的语法如下"

#: ../../language/fundamentals/control-structures.md:298
msgid ""
"defer <expr>\n"
"<body>\n"
msgstr ""

#: ../../language/fundamentals/control-structures.md:303
msgid ""
"Whenever the program leaves `body`, `expr` will be executed. For example, "
"the following program:"
msgstr "当程序离开 `body` 时，`expr` 里的内容会被执行。例如，下面的程序："

#: ../../language/fundamentals/control-structures.md:306
msgid ""
"  defer println(\"perform resource cleanup\")\n"
"  println(\"do things with the resource\")\n"
msgstr ""
"  defer println(\"释放资源\")\n"
"  println(\"使用资源\")\n"

#: ../../language/fundamentals/control-structures.md:312
msgid ""
"will first print `do things with the resource`, and then `perform resource "
"cleanup`. `defer` expression will always get executed no matter how its body"
" exits. It can handle [error](/language/error-handling.md), as well as "
"control flow constructs including `return`, `break` and `continue`."
msgstr ""
"会先输出 `使用资源`，然后输出 `释放资源`。无论 `body` 以何种方式退出，`defer` 表达式都会被执行。`defer` 能够处理 "
"[错误](/language/error-handling.md)，以及 `return`/`break`/`continue` 等控制流构造。"

#: ../../language/fundamentals/control-structures.md:317
msgid ""
"Consecutive `defer` will be executed in reverse order, for example, the "
"following:"
msgstr "连续的 `defer` 会以倒序执行。例如，下面的程序："

#: ../../language/fundamentals/control-structures.md:319
msgid ""
"  defer println(\"first defer\")\n"
"  defer println(\"second defer\")\n"
"  println(\"do things\")\n"
msgstr ""
"  defer println(\"第一处 defer\")\n"
"  defer println(\"第二处 defer\")\n"
"  println(\"做些事情\")\n"

#: ../../language/fundamentals/control-structures.md:325
msgid ""
"will output first `do things`, then `second defer`, and finally `first "
"defer`."
msgstr "会先输出 `做些事情`，然后输出 `第二处 defer`，最后输出 `第一处 defer`"

#: ../../language/fundamentals/control-structures.md:327
msgid ""
"`return`, `break` and `continue` are disallowed in the right hand side of "
"`defer`. Currently, raising error or calling `async` function is also "
"disallowed in the right hand side of `defer`."
msgstr ""
"在 `defer` 右边的表达式里，不能使用 `return`/`break`/`continue`。目前，在 `defer` "
"右边的表达式里也不能抛出错误或调用 `async` 函数。"

