# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals/special-syntax.md:1
msgid "Special Syntax"
msgstr "特殊语法"

#: ../../language/fundamentals/special-syntax.md:3
msgid "Pipelines"
msgstr "管道"

#: ../../language/fundamentals/special-syntax.md:5
msgid ""
"MoonBit provides a convenient pipe syntax `x |> f(y)`, which can be used to "
"chain regular function calls:"
msgstr "MoonBit 提供了一个方便的管道语法`x |> f(y)`，可以用于链接常规函数调用："

#: ../../language/fundamentals/special-syntax.md:7
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> Array::push(5) // <=> Array::push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:14
msgid ""
"The MoonBit code follows the *data-first* style, meaning the function places"
" its \"subject\" as the first argument.  Thus, the pipe operator inserts the"
" left-hand side value into the first argument of the right-hand side "
"function call by default.  For example, `x |> f(y)` is equivalent to `f(x, "
"y)`."
msgstr ""
"MoonBit "
"代码遵循*数据优先*风格，也就是说，函数将它的“主题”放置在第一个参数的位置。所以，管道默认将左侧的值填入右侧的函数调用的第一个参数的位置。例如`x "
"|> f(y)`等价于`f(x,y)`。"

#: ../../language/fundamentals/special-syntax.md:18
msgid ""
"You can use the `_` operator to insert `x` into any argument of the function"
" `f`, such as `x |> f(y, _)`, which is equivalent to `f(y, x)`. Labeled "
"arguments are also supported."
msgstr "你也可以使用`_`操作符改变`x`在函数`f`的调用中的插入位置，例如`x |> f(y, _)`, 这等价于`f(y,x)`。带标签的参数也是支持的。"

#: ../../language/fundamentals/special-syntax.md:21
msgid "Cascade Operator"
msgstr "级联运算符"

#: ../../language/fundamentals/special-syntax.md:23
msgid ""
"The cascade operator `..` is used to perform a series of mutable operations "
"on the same value consecutively. The syntax is as follows:"
msgstr "级联运算符`..`用于连续对同一值执行一系列可变操作。语法如下："

#: ../../language/fundamentals/special-syntax.md:26
msgid "[]..append([1])\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:33
msgid "`x..f()..g()` is equivalent to `{ x.f(); x.g(); }`."
msgstr "`x..f()..g()` 等价于 `{x.f(); x.g(); }`。"

#: ../../language/fundamentals/special-syntax.md:34
msgid "`x..f().g()` is equivalent to `{ x.f(); x.g(); }`."
msgstr "`x..f().g()` 等价于 `{x.f(); x.g(); }`。"

#: ../../language/fundamentals/special-syntax.md:37
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has methods"
" like `write_string`, `write_char`, `write_object`, etc., we often need to "
"perform a series of operations on the same `StringBuilder` value:"
msgstr "考虑以下情况：对于具有诸如`write_string`，`write_char`，`write_object`等方法的`StringBuilder`类型，我们经常需要对同一`StringBuilder`值执行一系列操作："

#: ../../language/fundamentals/special-syntax.md:41
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:48
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed to "
"return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used "
"for consecutive operations without the need to modify the return type of the"
" methods."
msgstr ""
"为了避免重复输入`builder`，其方法通常设计为返回`self`本身，允许使用`.`运算符链接操作。为了区分不可变和可变操作，在 MoonBit "
"中，对于所有返回`Unit`的方法，可以使用级联运算符进行连续操作，而无需修改方法的返回类型。"

#: ../../language/fundamentals/special-syntax.md:54
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:61
msgid "is Expression"
msgstr "is 表达式"

#: ../../language/fundamentals/special-syntax.md:63
msgid ""
"The `is` expression tests whether a value conforms to a specific pattern. It"
" returns a `Bool` value and can be used anywhere a boolean value is "
"expected, for example:"
msgstr "`is` 表达式测试值是否符合特定模式。它返回一个 `Bool` 值，并可以在期望布尔值的任何地方使用，例如："

#: ../../language/fundamentals/special-syntax.md:67
msgid ""
"fn[T] is_none(x : T?) -> Bool {\n"
"  x is None\n"
"}\n"
"\n"
"fn start_with_lower_letter(s : String) -> Bool {\n"
"  s is ['a'..='z', ..]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:74
msgid ""
"Pattern binders introduced by `is` expressions can be used in the following "
"contexts:"
msgstr "通过 `is` 表达式绑定的标识符可以在以下的上下文中使用："

#: ../../language/fundamentals/special-syntax.md:77
msgid ""
"In boolean AND expressions (`&&`): binders introduced in the left-hand "
"expression can be used in the right-hand expression"
msgstr "在与表达式（`&&`）中：左侧表达式中绑定的标识符可以在右侧表达式中使用"

#: ../../language/fundamentals/special-syntax.md:81
msgid ""
"fn f(x : Int?) -> Bool {\n"
"  x is Some(v) && v >= 0\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:88
msgid ""
"In the first branch of `if` expression: if the condition is a sequence of "
"boolean expressions `e1 && e2 && ...`, the binders introduced by the `is` "
"expression can be used in the branch where the condition evaluates to "
"`true`."
msgstr ""
"在 `if` 的第一个分支中：如果条件是一系列布尔表达式 `e1 && e2 && ...`，则可以在条件为真的分支中使用 `is` "
"表达式中绑定的标识符。"

#: ../../language/fundamentals/special-syntax.md:92
msgid ""
"fn g(x : Array[Int?]) -> Unit {\n"
"  if x is [v, .. rest] && v is Some(i) && i is (0..=10) {\n"
"    println(v)\n"
"    println(i)\n"
"    println(rest)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:99
msgid "In the following statements of a `guard` condition:"
msgstr "下面举一个在 `guard` 中使用的情况："

#: ../../language/fundamentals/special-syntax.md:101
msgid ""
"fn h(x : Int?) -> Unit {\n"
"  guard x is Some(v)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:108
msgid "In the body of a `while` loop:"
msgstr "在 `while` 循环中的使用："

#: ../../language/fundamentals/special-syntax.md:110
msgid ""
"fn i(x : Int?) -> Unit {\n"
"  let mut m = x\n"
"  while m is Some(v) {\n"
"    println(v)\n"
"    m = None\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:117
msgid ""
"Note that `is` expression can only take a simple pattern. If you need to use"
" `as` to bind the pattern to a variable, you have to add parentheses. For "
"example:"
msgstr "`is` 表达式只能接受一个简单模式，如果你需要通过 `as` 把模式绑定到某个变量上，需要加括号。比如："

#: ../../language/fundamentals/special-syntax.md:120
msgid ""
"fn j(x : Int) -> Int? {\n"
"  Some(x)\n"
"}\n"
"\n"
"fn init {\n"
"  guard j(42) is (Some(a) as b)\n"
"  println(a)\n"
"  println(b)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:127
msgid "Spread Operator"
msgstr "展开运算符"

#: ../../language/fundamentals/special-syntax.md:129
msgid ""
"MoonBit provides a spread operator to expand a sequence of elements when "
"constructing `Array`, `String`, and `Bytes` using the array literal syntax. "
"To expand such a sequence, it needs to be prefixed with `..`, and it must "
"have `iter()` method that yields the corresponding type of element."
msgstr ""
"MoonBit 提供了一个展开运算符，用于在使用数组字面量语法构造 `Array`、`String`和 `Bytes` "
"时展开元素序列。要展开这样的序列，需要在其前面加上 `..` 前缀，并且该序列必须具有 `iter()` 方法，并且该方法能够产生相应类型的元素。"

#: ../../language/fundamentals/special-syntax.md:134
msgid "For example, we can use the spread operator to construct an array:"
msgstr "例如，我们可以使用展开运算符构造一个数组："

#: ../../language/fundamentals/special-syntax.md:136
msgid ""
"test {\n"
"  let a1 : Array[Int] = [1, 2, 3]\n"
"  let a2 : FixedArray[Int] = [4, 5, 6]\n"
"  let a3 : @list.List[Int] = @list.from_array([7, 8, 9])\n"
"  let a : Array[Int] = [..a1, ..a2, ..a3, 10]\n"
"  inspect(a, content=\"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:143
msgid "Similarly, we can use the spread operator to construct a string:"
msgstr "同样，我们可以使用展开运算符构造一个字符串："

#: ../../language/fundamentals/special-syntax.md:145
msgid ""
"test {\n"
"  let s1 : String = \"Hello\"\n"
"  let s2 : StringView = \"World\".view()\n"
"  let s3 : Array[Char] = [..s1, ' ', ..s2, '!']\n"
"  let s : String = [..s1, ' ', ..s2, '!', ..s3]\n"
"  inspect(s, content=\"Hello World!Hello World!\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:152
msgid ""
"The last example shows how the spread operator can be used to construct a "
"bytes sequence."
msgstr "最后一个例子展示了如何使用展开运算符构造一个字节序列。"

#: ../../language/fundamentals/special-syntax.md:155
msgid ""
"test {\n"
"  let b1 : Bytes = \"hello\"\n"
"  let b2 : BytesView = b1[1:4]\n"
"  let b : Bytes = [..b1, ..b2, 10]\n"
"  inspect(\n"
"    b,\n"
"    content=(\n"
"      #|b\"helloell\\x0a\"\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/special-syntax.md:163
msgid "TODO syntax"
msgstr "TODO 语法"

#: ../../language/fundamentals/special-syntax.md:165
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of "
"code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr "`todo`语法 (`...`) 是一种特殊构造，用于标记尚未实现或用于未来功能的占位符代码段。例如："

#: ../../language/fundamentals/special-syntax.md:167
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

