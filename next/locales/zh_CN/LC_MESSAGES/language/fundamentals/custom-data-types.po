# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals/custom-data-types.md:1
msgid "Custom Data Types"
msgstr "自定义数据类型"

#: ../../language/fundamentals/custom-data-types.md:3
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr "创建新数据类型有两种方法：`struct` 和 `enum`。"

#: ../../language/fundamentals/custom-data-types.md:5
msgid "Struct"
msgstr "结构体"

#: ../../language/fundamentals/custom-data-types.md:7
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed by "
"field names. A struct can be constructed using a struct literal, which is "
"composed of a set of labeled values and delimited with curly brackets. The "
"type of a struct literal can be automatically inferred if its fields exactly"
" match the type definition. A field can be accessed using the dot syntax "
"`s.f`. If a field is marked as mutable using the keyword `mut`, it can be "
"assigned a new value."
msgstr ""
"在 MoonBit "
"中，结构体类似于元组，但其字段由字段名称索引。可以使用结构体字面量构造结构体，结构体字面量由一组带标签的值组成，并用大括号括起来。如果结构体的字段与类型定义完全匹配，那么结构体字面量的类型可以自动推断。可以使用点语法"
" `s.f` 访问字段。如果使用关键字 `mut` 标记字段为可变的，则可以为其分配新值。"

#: ../../language/fundamentals/custom-data-types.md:9
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:15
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:23
#: ../../language/fundamentals/custom-data-types.md:59
#: ../../language/fundamentals/custom-data-types.md:90
#: ../../language/fundamentals/custom-data-types.md:117
#: ../../language/fundamentals/custom-data-types.md:146
#: ../../language/fundamentals/custom-data-types.md:166
#: ../../language/fundamentals/custom-data-types.md:200
#: ../../language/fundamentals/custom-data-types.md:214
msgid "Output"
msgstr "输出"

#: ../../language/fundamentals/custom-data-types.md:23
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:27
msgid "Constructing Struct with Shorthand"
msgstr "使用简写构造结构体"

#: ../../language/fundamentals/custom-data-types.md:29
msgid ""
"If you already have some variable like `name` and `email`, it's redundant to"
" repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr "如果已经有一些变量，如 `name` 和 `email`，在构造结构体时重复这些名称是多余的。可以使用简写，它的行为完全相同："

#: ../../language/fundamentals/custom-data-types.md:31
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:38
msgid ""
"If there's no other struct that has the same fields, it's redundant to add "
"the struct's name when constructing it:"
msgstr "如果没有其他具有相同字段的结构体，在构造结构体时添加结构体的名称是多余的："

#: ../../language/fundamentals/custom-data-types.md:40
msgid "let u2 = { id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:47
msgid "Struct Update Syntax"
msgstr "结构体更新语法"

#: ../../language/fundamentals/custom-data-types.md:49
msgid ""
"It's useful to create a new struct based on an existing one, but with some "
"fields updated."
msgstr "可以用这个语法来根据现有结构体创建一个新的结构体，但只更新部分字段。"

#: ../../language/fundamentals/custom-data-types.md:51
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    (\n"
"      $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"      $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:59
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:63
msgid "Enum"
msgstr "枚举"

#: ../../language/fundamentals/custom-data-types.md:65
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr "枚举类型类似于函数式语言中的代数数据类型。熟悉 C/C++ 的用户可能更喜欢称其为标记联合。"

#: ../../language/fundamentals/custom-data-types.md:67
msgid ""
"An enum can have a set of cases (constructors). Constructor names must start"
" with capitalized letter. You can use these names to construct corresponding"
" cases of an enum, or checking which branch an enum value belongs to in "
"pattern matching:"
msgstr "枚举可以有一组情况（构造函数）。构造函数的名称必须以大写字母开头。可以使用这些名称来构造枚举的相应情况，或在模式匹配中检查枚举值属于哪个分支："

#: ../../language/fundamentals/custom-data-types.md:69
msgid ""
"/// An enum type that represents the ordering relation between two values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""
"/// 一个枚举类型，表示两个值之间的顺序关系，\n"
"/// 有三种情况 \"Smaller\"、\"Greater\" 和 \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:75
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""
"/// 比较两个整数之间的顺序关系\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // 当创建一个枚举时，如果目标类型已知，\n"
"    // 可以直接写构造函数名称\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // 但是当目标类型未知时，\n"
"    // 你总是可以使用 `TypeName::Constructor` 来创建一个枚举\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// 输出一个类型为 `Relation` 的值\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // 使用模式匹配来决定 `r` 属于哪种情况\n"
"  match r {\n"
"    // 在模式匹配期间，如果类型已知，\n"
"    // 写构造函数的名称就足够了\n"
"    Smaller => println(\"smaller!\")\n"
"    // 但是你也可以在模式匹配中使用 `TypeName::Constructor` 语法\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:82
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:90
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:94
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr "枚举情况也可以携带额外数据。以下是使用枚举定义整数列表类型的示例："

#: ../../language/fundamentals/custom-data-types.md:96
msgid ""
"enum Lst {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of the"
" list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, Lst)\n"
"}\n"
msgstr ""
"enum Lst {\n"
"  Nil\n"
"  // 构造函数 `Cons` 携带额外的数据：列表的第一个元素，\n"
"  // 和列表的其余部分\n"
"  Cons(Int, Lst)\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:102
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : Lst) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : Lst) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 除了将额外数据绑定到变量之外，\n"
"// 你还可以继续匹配构造函数内部的额外数据。\n"
"// 以下是一个函数，用于判断列表是否只包含一个元素\n"
"fn is_singleton(l : Lst) -> Bool {\n"
"  match l {\n"
"    // 此分支仅匹配形状为 `Cons(_, Nil)` 的值，\n"
"    // 即长度为 1 的列表\n"
"    Cons(_, Nil) => true\n"
"    // 使用 `_` 匹配其他所有情况\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : Lst) -> Unit {\n"
"  // 在模式匹配带有额外数据的枚举时，\n"
"  // 除了决定值属于哪种情况\n"
"  // 你还可以提取该情况内部的额外数据\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // 这里 `x` 和 `xs` 定义了新变量\n"
"    // 而不是引用现有变量，\n"
"    // 如果 `l` 是一个 `Cons`，那么 `Cons` 的额外数据\n"
"    // （第一个元素和列表的其余部分）\n"
"    // 将绑定到 `x` 和 `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:109
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : Lst = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""
"fn main {\n"
"  // 使用 `Cons` 创建值时，必须提供 `Cons` 的额外数据\n"
"  let l : Lst = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:117
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:121
msgid "Constructor with labelled arguments"
msgstr "构造器与带标签参数"

#: ../../language/fundamentals/custom-data-types.md:123
msgid "Enum constructors can have labelled argument:"
msgstr "枚举构造器可以有带标签的参数："

#: ../../language/fundamentals/custom-data-types.md:125
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""
"enum E {\n"
"  // `x` 和 `y` 是有标签参数\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:131
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""
"// 使用有标签参数的构造函数进行模式匹配\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` 是 `x=x` 的缩写\n"
"    // 未匹配的有标签参数可以通过 `..` 省略\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:138
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:146
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:150
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr "也可以像在模式匹配中访问结构体字段一样访问构造函数的有标签参数："

#: ../../language/fundamentals/custom-data-types.md:152
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"suberror NotImplementedError derive(Show)\n"
"\n"
"fn Object::distance_with(\n"
"  self : Object,\n"
"  other : Object,\n"
") -> Double raise NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc.\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), Circle(_)) "
"=>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"suberror NotImplementedError derive(Show)\n"
"\n"
"fn Objecct::distance_with(\n"
"  self : Object,\n"
"  other : Object,\n"
") -> Double raise NotImplementedError {\n"
"  match (self, other) {\n"
"    // 对于通过 `Point(..) as p` 定义的变量，\n"
"    // 编译器知道它必须是构造函数 `Point`，\n"
"    // 因此可以通过 `p.x`、`p.y` 等直接访问 `Point` 的字段。\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), Circle(_)) "
"=>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
"\n"

#: ../../language/fundamentals/custom-data-types.md:158
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with(p2))\n"
"    println(p1.distance_with(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:166
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:170
msgid "Constructor with mutable fields"
msgstr "构造器与可变字段"

#: ../../language/fundamentals/custom-data-types.md:172
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr "也可以为构造器定义可变字段。这对于定义命令式数据结构特别有用："

#: ../../language/fundamentals/custom-data-types.md:174
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn[X : Compare] Set::insert(self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn[X : Compare] Tree::insert(\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X],\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 使用可变二叉搜索树实现的集合。\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn[X : Compare] Set::insert(self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// 带有亲指针的可变二叉搜索树\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // 只有带标签的参数可以是可变的\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// 将一个新元素插入到二叉搜索树中。\n"
"// 返回新的树\n"
"fn[X : Compare] Tree::insert(\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X],\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // 修改构造器的字段\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // 在这里创建的 `node` 和 `node.left` 之间的循环\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // 树不为空，所以新的树就是原来的树\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals/custom-data-types.md:180
msgid "Tuple Struct"
msgstr "元组结构体"

#: ../../language/fundamentals/custom-data-types.md:182
msgid "MoonBit supports a special kind of struct called tuple struct:"
msgstr "MoonBit 支持一种特殊的结构体称为元组结构体："

#: ../../language/fundamentals/custom-data-types.md:184
msgid ""
"struct UserId(Int)\n"
"\n"
"struct UserInfo(UserId, String)\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:190
msgid ""
"Tuple structs are similar to enum with only one constructor (with the same "
"name as the tuple struct itself). So, you can use the constructor to create "
"values, or use pattern matching to extract the underlying representation:"
msgstr "元组结构体类似于只有一个构造函数的枚举（与元组结构体本身的名称相同）。因此，可以使用构造函数创建或使用模式匹配提取底层表示："

#: ../../language/fundamentals/custom-data-types.md:192
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserInfo = UserInfo(id, \"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserInfo(_, uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:200
#: ../../language/fundamentals/custom-data-types.md:214
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:204
msgid ""
"Besides pattern matching, you can also use index to access the elements "
"similar to tuple:"
msgstr "除了模式匹配之外，还可以使用索引访问元素，类似于元组："

#: ../../language/fundamentals/custom-data-types.md:206
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let info : UserInfo = UserInfo(id, \"John Doe\")\n"
"  let uid : Int = id.0\n"
"  let uname : String = info.1\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:218
msgid "Type alias"
msgstr "类型别名"

#: ../../language/fundamentals/custom-data-types.md:219
msgid "MoonBit supports type alias via the syntax `type NewType = OldType`:"
msgstr "MoonBit 支持使用语法 `type NewType = OldType` 定义类型别名："

#: ../../language/fundamentals/custom-data-types.md:222
msgid "The old syntax `typealias OldType as NewType` may be removed in the future."
msgstr "旧语法 `typealias OldType as NewType` 可能会在将来被移除。"

#: ../../language/fundamentals/custom-data-types.md:225
msgid ""
"pub type Index = Int\n"
"pub type MyIndex = Int\n"
"pub type MyMap = Map[Int, String]\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:231
msgid ""
"Unlike all other kinds of type declaration above, type alias does not define"
" a new type, it is merely a type macro that behaves exactly the same as its "
"definition. So for example one cannot define new methods or implement traits"
" for a type alias."
msgstr "与上面所有其他类型声明不同，类型别名不定义新类型，它只是一个行为与其定义完全相同的类型宏。因此，例如，不能为类型别名定义新方法或实现特征。"

#: ../../language/fundamentals/custom-data-types.md:236
msgid "Type alias can be used to perform incremental code refactor."
msgstr "类型别名可用于执行增量代码重构。"

#: ../../language/fundamentals/custom-data-types.md:238
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you can"
" leave a type alias `type T = @pkgB.T` in `@pkgA`, and **incrementally** "
"port uses of `@pkgA.T` to `@pkgB.T`. The type alias can be removed after all"
" uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr "例如，如果要将类型 `T` 从 `@pkgA` 移动到 `@pkgB`，可以在 `@pkgA` 中留下一个类型别名 `type T = @pkgB.T`，"

#: ../../language/fundamentals/custom-data-types.md:243
msgid "Local types"
msgstr "本地类型"

#: ../../language/fundamentals/custom-data-types.md:245
msgid ""
"MoonBit supports declaring structs/enums at the top of a toplevel function, "
"which are only visible within the current toplevel function. These local "
"types can use the generic parameters of the toplevel function but cannot "
"introduce additional generic parameters themselves. Local types can derive "
"methods using derive, but no additional methods can be defined manually. For"
"  example:"
msgstr ""
"MoonBit "
"支持在顶层函数的顶部声明结构体/枚举，这些类型仅在当前顶层函数中可见。这些本地类型可以使用顶层函数的泛型参数，但不能引入额外的泛型参数。本地类型可以使用"
" derive 派生方法，但不能手动定义额外的方法。例如："

#: ../../language/fundamentals/custom-data-types.md:252
msgid ""
"fn[T : Show] toplevel(x : T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a : (String, T)\n"
"  } derive(Show)\n"
"  struct LocalStructTuple(T) derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/custom-data-types.md:258
msgid "Currently, local types do not support being declared as error types."
msgstr "目前，本地类型不支持声明为错误类型。"

