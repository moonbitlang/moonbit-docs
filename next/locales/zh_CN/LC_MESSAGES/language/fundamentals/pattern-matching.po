# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../language/fundamentals/pattern-matching.md:3
msgid ""
"Pattern matching allows us to match on specific pattern and bind data from "
"data structures."
msgstr "模式匹配允许我们匹配特定模式并从数据结构中绑定数据。"

#: ../../language/fundamentals/pattern-matching.md:5
msgid "Simple Patterns"
msgstr "简单模式"

#: ../../language/fundamentals/pattern-matching.md:7
msgid "We can pattern match expressions against"
msgstr "我们可以将表达式与以下内容进行模式匹配："

#: ../../language/fundamentals/pattern-matching.md:9
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr "字面量，例如布尔值、数字、字符、字符串等"

#: ../../language/fundamentals/pattern-matching.md:10
msgid "constants"
msgstr "常量"

#: ../../language/fundamentals/pattern-matching.md:11
msgid "structs"
msgstr "结构体"

#: ../../language/fundamentals/pattern-matching.md:12
msgid "enums"
msgstr "枚举"

#: ../../language/fundamentals/pattern-matching.md:13
msgid "arrays"
msgstr "数组"

#: ../../language/fundamentals/pattern-matching.md:14
msgid "maps"
msgstr "键值对"

#: ../../language/fundamentals/pattern-matching.md:15
msgid "JSONs"
msgstr "JSON"

#: ../../language/fundamentals/pattern-matching.md:17
msgid ""
"and so on. We can define identifiers to bind the matched values so that they"
" can be used later."
msgstr "等等。我们可以定义标识符来绑定匹配的值，以便稍后使用。"

#: ../../language/fundamentals/pattern-matching.md:19
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:26
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use `..`"
" to ignore remaining fields of struct or enum, or array (see [array pattern"
"](#array-pattern))."
msgstr ""
"我们可以使用 `_` 作为我们不关心的值的通配符，并使用 `..` 忽略结构体或枚举的剩余字段，或数组（参见 [数组模式](#array-"
"pattern））。"

#: ../../language/fundamentals/pattern-matching.md:28
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~ : String, payload~ : T)\n"
"}\n"
"\n"
"fn[T] match_point(p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:35
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to match "
"several cases at once. A variable name can only be bound once in a single "
"pattern, and the same set of variables should be bound on both sides of `|` "
"patterns."
msgstr ""
"我们可以使用 `as` 为某些模式命名，可以使用 `|` 一次匹配多个情况。在单个模式中，变量名只能绑定一次，并且在 `|` "
"模式的两侧应绑定相同的变量集。"

#: ../../language/fundamentals/pattern-matching.md:37
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:44
msgid "Array Pattern"
msgstr "数组模式"

#: ../../language/fundamentals/pattern-matching.md:46
msgid ""
"Array patterns can be used to match on the following types to obtain their "
"corresponding elements or views:"
msgstr "数组模式可以用来匹配以下类型以获取其对应的元素或视图（View）："

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Type"
msgstr "类型"

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Element"
msgstr "元素"

#: ../../language/fundamentals/pattern-matching.md:37
msgid "View"
msgstr "视图"

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Array[T], ArrayView[T], FixedArray[T]"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "T"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "ArrayView[T]"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Bytes, BytesView"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Byte"
msgstr "字节"

#: ../../language/fundamentals/pattern-matching.md:37
msgid "BytesView"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "String, StringView"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:37
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals/pattern-matching.md:37
msgid "StringView"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:56
msgid "Array patterns have the following forms:"
msgstr "数组模式可以有以下形式："

#: ../../language/fundamentals/pattern-matching.md:58
msgid "`[]` : matching for empty array"
msgstr "`[]`：匹配空数组"

#: ../../language/fundamentals/pattern-matching.md:59
msgid ""
"`[pa, pb, pc]` : matching for array of length three, and bind `pa`, `pb`, "
"`pc` to the three elements"
msgstr "`[pa, pb, pc]`：匹配长度为 3 的数组，并将其中的元素分别绑定到 `pa`, `pb`, `pc`"

#: ../../language/fundamentals/pattern-matching.md:61
msgid ""
"`[pa, ..rest, pb]` : matching for array with at least two elements, and bind"
" `pa` to the first element, `pb` to the last element, and `rest` to the "
"remaining elements. the binder `rest` can be omitted if the rest of the "
"elements are not needed. Arbitrary number of elements are allowed preceding "
"and following the `..` part. Because `..` can match uncertain number of "
"elements, it can appear at most once in an array pattern."
msgstr ""
"`[pa, ..rest, pb]`：匹配至少有两个元素的数组，并将第一个元素绑定到`pa`，最后一个元素绑定到 `pb`，其余元素绑定到 "
"`rest`。如果不需要其余元素，可以省略绑定 `rest`。在 `..` 部分前后允许任意数量的元素。由于 `..` "
"可以匹配不确定数量的元素，因此在数组模式中最多只能出现一次。"

#: ../../language/fundamentals/pattern-matching.md:68
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  if ary is [a, b, .. rest] && a == 1 && b == 2 && rest.length() == 2 {\n"
"    inspect(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  } else {\n"
"    fail(\"\")\n"
"  }\n"
"  guard ary is [.., a, b] else { fail(\"\") }\n"
"  inspect(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:74
msgid ""
"Array patterns provide a unicode-safe way to manipulate strings, meaning "
"that it respects the code unit boundaries. For example, we can check if a "
"string is a  palindrome:"
msgstr ""
"数组模式提供了一种 Unicode 安全的方式来操作字符串，这意味着它在访问元素的时候不会跨越代码单元边界。例如，我们可以检查一个包含 Unicode "
"的字符串是否是回文："

#: ../../language/fundamentals/pattern-matching.md:78
msgid ""
"test {\n"
"  fn palindrome(s : String) -> Bool {\n"
"    loop s.view() {\n"
"      [] | [_] => true\n"
"      [a, .. rest, b] => if a == b { continue rest } else { false }\n"
"    }\n"
"  }\n"
"\n"
"  inspect(palindrome(\"abba\"), content=\"true\")\n"
"  inspect(palindrome(\"中b中\"), content=\"true\")\n"
"  inspect(palindrome(\"文bb中\"), content=\"false\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:84
msgid ""
"When there are consecutive char or byte constants in an array pattern, the "
"pattern spread `..` operator can be used to combine them to make the code "
"look cleaner. Note that in this case the `..` followed by string or bytes "
"constant matches exact number of elements so its usage is not limited to "
"once."
msgstr ""
"当数组模式中有连续的字符或字节常量时，可以使用模式展开 `..` 运算符将它们组合起来，使代码看起来更整洁。在这种情况下，`..` "
"后跟字符串或字节常量匹配确切数量的元素，因此它可以在数组模式中多次使用。"

#: ../../language/fundamentals/pattern-matching.md:89
msgid ""
"const NO : Bytes = \"no\"\n"
"\n"
"test {\n"
"  fn match_string(s : String) -> Bool {\n"
"    match s {\n"
"      [.. \"yes\", ..] => true // equivalent to ['y', 'e', 's', ..]\n"
"    }\n"
"  }\n"
"\n"
"  fn match_bytes(b : Bytes) -> Bool {\n"
"    match b {\n"
"      [.. NO, ..] => false // equivalent to ['n', 'o', ..]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:95
msgid "Range Pattern"
msgstr "范围模式"

#: ../../language/fundamentals/pattern-matching.md:96
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the "
"value falls in a specific range."
msgstr "对于内置整数类型和 `Char`，MoonBit 允许匹配值是否落在特定范围内。"

#: ../../language/fundamentals/pattern-matching.md:98
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the upper"
" bound is exclusive, and `..=` means inclusive upper bound. `a` and `b` can "
"be one of:"
msgstr "范围模式的形式为 `a..<b` 或 `a..=b`，其中 `..<` 表示上限是排他的，`..=` 表示包含上限。`a` 和 `b` 可以是以下之一："

#: ../../language/fundamentals/pattern-matching.md:101
msgid "literal"
msgstr "字面量"

#: ../../language/fundamentals/pattern-matching.md:102
msgid "named constant declared with `const`"
msgstr "使用 `const` 声明的常量"

#: ../../language/fundamentals/pattern-matching.md:103
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr "`_`，表示此模式在此侧没有限制"

#: ../../language/fundamentals/pattern-matching.md:105
msgid "Here are some examples:"
msgstr "以下是一些示例："

#: ../../language/fundamentals/pattern-matching.md:107
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:114
msgid "Map Pattern"
msgstr "Map 模式"

#: ../../language/fundamentals/pattern-matching.md:116
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a map"
" pattern, the `key : value` syntax will match if `key` exists in the map, "
"and match the value of `key` with pattern `value`. The `key? : value` syntax"
" will match no matter `key` exists or not, and `value` will be matched "
"against `map[key]` (an optional)."
msgstr ""
"MoonBit 允许在类似 map 的数据结构上方便地进行匹配。在 map 模式内，`key : value` 语法将在 map 中存在 `key` "
"时匹配，并将 `key` 的值与模式 `value` 匹配。`key? : value` 语法将无论 `key` 是否存在都匹配，`value` 将与 "
"`map[key]`（一个可选项）匹配。"

#: ../../language/fundamentals/pattern-matching.md:120
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _, .. } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" exists "
"in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""
"match map {\n"
"  // 仅在 `map` 中存在 \"b\" 时匹配\n"
"  { \"b\": _, .. } => ...\n"
"  // 仅在 `map` 中不存在 \"b\" 且 \"a\" 存在于 `map` 时匹配。\n"
"  // 匹配时，将 `map` 中的 \"a\" 的值绑定到 `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // 编译器报告缺失的情况：{ \"b\"? : None, \"a\"? : None }\n"
"}\n"

#: ../../language/fundamentals/pattern-matching.md:127
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and "
"trait](./methods.md))."
msgstr ""
"要使用 map 模式匹配数据类型 `T`，`T` 必须具有某种类型 `K` 和 `V` 的方法 `op_get(Self, K) -> "
"Option[V]`（请参见 [方法和特征](./methods.md)）。"

#: ../../language/fundamentals/pattern-matching.md:128
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr "目前，map 模式的键部分必须是字面量或常量"

#: ../../language/fundamentals/pattern-matching.md:129
msgid ""
"Map patterns are always open: the unmatched keys are silently ignored, and "
"`..` needs to be added to identify this nature"
msgstr "Map 模式始终是开放的：未匹配的键会被静默忽略，并且需要添加 `..` 以显示这一点"

#: ../../language/fundamentals/pattern-matching.md:130
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched at"
" most once"
msgstr "Map 模式将编译为高效的代码：每个键最多只会被获取一次"

#: ../../language/fundamentals/pattern-matching.md:132
msgid "Json Pattern"
msgstr "Json 模式"

#: ../../language/fundamentals/pattern-matching.md:134
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr "当匹配的值具有类型 `Json` 时，可以直接使用字面量模式，以及构造函数："

#: ../../language/fundamentals/pattern-matching.md:136
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports, .. } => ...\n"
"  { \"version\": Number(i, ..), \"import\": Array(imports), .. } => ...\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:143
msgid "Guard condition"
msgstr "守卫条件"

#: ../../language/fundamentals/pattern-matching.md:145
msgid ""
"Each case in a pattern matching expression can have a guard condition. A "
"guard condition is a boolean expression that must be true for the case to be"
" matched. If the guard condition is false, the case is skipped and the next "
"case is tried. For example:"
msgstr "模式匹配表达式中的每个分支都可以有一个守卫条件。守卫条件是一个布尔表达式，只有当该条件为真时，对应的分支才会被匹配。如果守卫条件为假，则跳过该分支并尝试下一个分支。例如："

#: ../../language/fundamentals/pattern-matching.md:149
msgid ""
"fn guard_cond(x : Int?) -> Int {\n"
"  fn f(x : Int) -> Array[Int] {\n"
"    [x, x + 42]\n"
"  }\n"
"\n"
"  match x {\n"
"    Some(a) if f(a) is [0, b] => a + b\n"
"    Some(b) => b\n"
"    None => -1\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq(guard_cond(None), -1)\n"
"  assert_eq(guard_cond(Some(0)), 42)\n"
"  assert_eq(guard_cond(Some(1)), 1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:156
msgid ""
"Note that the guard conditions will not be considered when checking if all "
"patterns are covered by the match expression. So you will see a warning of "
"partial match for the following case:"
msgstr "注意，在检查所有模式是否都被匹配表达式覆盖时，不会考虑守卫条件。因此，您会看到以下情况的警告："

#: ../../language/fundamentals/pattern-matching.md:160
msgid ""
"fn guard_check(x : Int?) -> Unit {\n"
"  match x {\n"
"    Some(a) if a >= 0 => ()\n"
"    Some(a) if a < 0 => ()\n"
"    None => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/pattern-matching.md:168
msgid ""
"It is not encouraged to call a function that mutates a part of the value "
"being matched inside a guard condition. When such case happens, the part "
"being mutated will not be re-evaluated in the subsequent patterns. Use it "
"with caution."
msgstr "不鼓励在守卫条件中调用可能通过副作用改变被匹配的值的函数。在这种情况下，被改变的部分不会在后续模式中重新求值。请谨慎使用。"

