# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/fundamentals/iterator.md:1
msgid "Iterator"
msgstr "迭代器"

#: ../../language/fundamentals/iterator.md:3
msgid ""
"An iterator is an object that traverse through a sequence while providing "
"access to its elements. Traditional OO languages like Java's `Iterator<T>` "
"use `next()` `hasNext()` to step through the iteration process, whereas "
"functional languages (JavaScript's `forEach`, Lisp's `mapcar`) provides a "
"high-order function which takes an operation and a sequence then consumes "
"the sequence with that operation being applied to the sequence. The former "
"is called _external iterator_ (visible to user) and the latter is called "
"_internal iterator_ (invisible to user)."
msgstr ""
"迭代器是一个对象，它在遍历序列的同时提供对其元素的访问。传统的面向对象语言如 Java 的 `Iterator<T>` 使用 `next()` "
"和`hasNext()` 来遍历迭代过程，而函数式语言（JavaScript 的 `forEach`，Lisp 的 "
"`mapcar`）提供了一个高阶函数，该函数接受一个操作和一个序列，然后使用该操作应用于序列。前者称为外部迭代器（对用户可见），后者称为内部迭代器（对用户不可见）。"

#: ../../language/fundamentals/iterator.md:11
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator implementation. "
"Almost all built-in sequential data structures have implemented `Iter`:"
msgstr "内置类型 `Iter[T]` 是 MoonBit 的内部迭代器实现。几乎所有内置的顺序数据结构都已经实现了 `Iter`："

#: ../../language/fundamentals/iterator.md:14
msgid ""
"///|\n"
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(x => (x & 1) == 0).collect()\n"
"}\n"
"\n"
"///|\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/iterator.md:20
msgid "Commonly used methods include:"
msgstr "常用的方法包括："

#: ../../language/fundamentals/iterator.md:22
msgid ""
"`each`: Iterates over each element in the iterator, applying some function "
"to each element."
msgstr "`each`: 遍历迭代器中的每个元素，对每个元素应用某个函数。"

#: ../../language/fundamentals/iterator.md:23
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr "`fold`: 使用给定的函数，从给定的初始值开始，对迭代器的元素进行“折叠”。"

#: ../../language/fundamentals/iterator.md:24
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr "`collect`: 将迭代器的元素收集到一个数组中。"

#: ../../language/fundamentals/iterator.md:26
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a predicate "
"function."
msgstr "`filter`: （惰性）根据谓词函数过滤迭代器的元素。"

#: ../../language/fundamentals/iterator.md:27
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr "`map`: （惰性）使用映射函数转换迭代器的元素。"

#: ../../language/fundamentals/iterator.md:28
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the elements "
"of the second iterator to the first."
msgstr "`concat`: （惰性）通过将第二个迭代器的元素附加到第一个迭代器，将两个迭代器合并为一个。"

#: ../../language/fundamentals/iterator.md:30
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. Array."
" But what makes `Iter` special is that any method that constructs a new "
"`Iter` is _lazy_ (i.e. iteration doesn't start on call because it's wrapped "
"inside a function), as a result of no allocation for intermediate value. "
"That's what makes `Iter` superior for traversing through sequence: no extra "
"cost. MoonBit encourages user to pass an `Iter` across functions instead of "
"the sequence object itself."
msgstr ""
"像 `filter` `map` 这样的方法在序列对象（例如 Array）上非常常见。但是，`Iter` 的不同之处在于，任何构造新 `Iter` "
"的方法都是**惰性**的（即在调用时不会开始迭代，因为它被包装在一个函数内），因此不会为中间值分配内存。这就是使 `Iter` "
"优于遍历序列的原因：没有额外的成本。MoonBit 鼓励用户将 `Iter` 传递给函数，而不是传递序列对象本身。"

#: ../../language/fundamentals/iterator.md:38
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement `Iter`,"
" namely, a function that returns an `Iter[S]`. Take `Bytes` as an example:"
msgstr ""
"预定义的序列结构如 `Array` 及其迭代器应该足够使用。但是，为了在自定义序列（元素类型为 `S`）中使用这些方法，我们需要实现 "
"`Iter`，即返回 `Iter[S]` 的函数。以 `Bytes` 为例："

#: ../../language/fundamentals/iterator.md:43
msgid ""
"///|\n"
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"    for byte in data {\n"
"      guard visit(byte) is IterContinue else { break IterEnd }\n"
"    } else {\n"
"      IterContinue\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/fundamentals/iterator.md:49
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the only"
" main difference being the code block that actually does the iteration."
msgstr "几乎所有 `Iter` 实现都与 `Bytes` 的实现相同，唯一的主要区别是实际执行迭代的代码块。"

#: ../../language/fundamentals/iterator.md:52
msgid "Implementation details"
msgstr "实现细节"

#: ../../language/fundamentals/iterator.md:54
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration "
"which consists any of the 2 states:"
msgstr ""
"类型 `Iter[T]` 基本上是 `((T) -> IterResult) -> IterResult` "
"的类型别名，它是一个高阶函数，接受一个操作，`IterResult` 是一个枚举对象，用于跟踪当前迭代的状态，包含以下 2 种状态："

#: ../../language/fundamentals/iterator.md:59
msgid "`IterEnd`: marking the end of an iteration"
msgstr "`IterEnd`: 标记迭代结束"

#: ../../language/fundamentals/iterator.md:60
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr "`IterContinue`: 标记迭代结束尚未到达，暗示迭代将在此状态继续"

#: ../../language/fundamentals/iterator.md:62
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use it "
"to transform `Iter[T]` itself to a new state of type `IterResult`. Whether "
"that state being `IterEnd` `IterContinue` depends on the function."
msgstr ""
"简单来说，`Iter[T]` 接受一个函数 `(T) -> IterResult` 并使用它将 `Iter[T]` 本身转换为类型为 "
"`IterResult` 的新状态。"

#: ../../language/fundamentals/iterator.md:66
msgid ""
"Iterator provides a unified way to iterate through data structures, and they"
" can be constructed at basically no cost: as long as `fn(yield)` doesn't "
"execute, the iteration process doesn't start."
msgstr "迭代器提供了一种统一的遍历数据结构的方式，它们基本上可以无成本地构建：只要 `fn(yield)` 不执行，迭代过程就不会开始。"

#: ../../language/fundamentals/iterator.md:70
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all "
"sorts of `Iter` methods might be visually pleasing, but do notice the heavy "
"work underneath the abstraction."
msgstr "`Iter::run()` 在在内部触发迭代。链接各种 `Iter` 方法可能看起来很美观，但请注意抽象层下面的繁重工作。"

#: ../../language/fundamentals/iterator.md:74
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no way "
"to stop unless the end is reached. Methods such as `count()` which counts "
"the number of elements in a iterator looks like an `O(1)` operation but "
"actually has linear time complexity. Carefully use iterators or performance "
"issue might occur."
msgstr ""
"因此，与外部迭代器不同，一旦迭代开始，除非到达末尾，否则无法停止。诸如 `count()` 这样的方法，它计算迭代器中元素的数量看起来像是一个 "
"`O(1)` 操作，但实际上具有线性时间复杂度。请谨慎使用迭代器，否则可能会出现性能问题。"

