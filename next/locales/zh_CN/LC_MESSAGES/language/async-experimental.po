# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/async-experimental.md:1
msgid "Async programming support"
msgstr "异步编程支持"

#: ../../language/async-experimental.md:3
msgid ""
"MoonBit adopts a coroutine based approach to async programming which is "
"similar to [Kotlin](https://kotlinlang.org/docs/coroutines-overview.html). "
"The compiler support and concrete syntax is stable while the async library "
"is still under development and considered experimental."
msgstr ""
"MoonBit 采用类似于 [Kotlin](https://kotlinlang.org/docs/coroutines-overview.html)"
" 的基于协程的异步编程方法。编译器支持和具体语法是稳定的，而异步库仍在开发中，并被视为实验性。"

#: ../../language/async-experimental.md:8
msgid "Async function"
msgstr "异步函数"

#: ../../language/async-experimental.md:9
msgid ""
"Async functions are declared with the `async` keyword.  They implicitly "
"[`raise`](/language/error-handling.md#throwing-errors) errors  and need to "
"declare `noraise` explicitly if otherwise."
msgstr ""
"异步函数用 `async` 关键字定义。他们隐式地 [抛出错误](/language/error-handling.md#throwing-"
"errors) ，而如果不抛出错误则需要显式地声明 `noraise`。"

#: ../../language/async-experimental.md:13
msgid ""
"async fn my_async_function() -> Unit noraise {\n"
"  ...\n"
"}\n"
"\n"
"///| anonymous/local function\n"
"test {\n"
"  let async_lambda = async fn() noraise { ... }\n"
"  async fn local_async_function() noraise {\n"
"    ...\n"
"  }\n"
"\n"
"\n"
"}\n"
msgstr ""
"async fn my_async_function() -> Unit noraise {\n"
"  ...\n"
"}\n"
"\n"
"// 匿名/本地函数\n"
"test {\n"
"  let async_lambda = async fn() noraise { ... }\n"
"  async fn local_async_function() noraise {\n"
"    ...\n"
"  }\n"
"\n"
"\n"
"}\n"

#: ../../language/async-experimental.md:19
msgid ""
"Since MoonBit is a statically typed language, the compiler will track its  "
"asyncness, so you can just call async functions like normal functions, the "
"MoonBit IDE will highlight the async function call with a different style."
msgstr ""
"由于 MoonBit 是一门静态类型语言，编译器会跟踪异步函数的调用，因此你可以像调用普通函数一样调用异步函数。MoonBit IDE "
"会用不同的样式来高亮显示异步函数的调用。"

#: ../../language/async-experimental.md:23
msgid ""
"\n"
"///|\n"
"async fn some_async_function() -> Unit raise {\n"
"  ...\n"
"}\n"
"\n"
"///|\n"
"async fn another_async_function() -> Unit raise {\n"
"  some_async_function() // rendered in italic font\n"
"}\n"
msgstr ""
"\n"
"///|\n"
"async fn some_async_function() -> Unit raise {\n"
"  ...\n"
"}\n"
"\n"
"///|\n"
"async fn another_async_function() -> Unit raise {\n"
"  some_async_function() // 使用斜体渲染\n"
"}\n"

#: ../../language/async-experimental.md:29
msgid "Async functions can only be called inside async functions."
msgstr "异步函数只能在异步函数中调用。"

#: ../../language/async-experimental.md:32
msgid ""
"Currently, async functions  have not be supported in the body of `for .. in`"
" loops yet, this  will be addressed in the future."
msgstr "目前，异步函数还不支持在 `for .. in` 循环体中使用，这将在未来的版本中解决。"

#: ../../language/async-experimental.md:37
msgid "Async primitives for suspension"
msgstr "用于中断异步函数的原语"

#: ../../language/async-experimental.md:38
msgid "MoonBit provides two core primitives for `%async.suspend` and `%async.run`:"
msgstr "MoonBit 提供了两个用于异步编程的原语：`%async.suspend` 和 `%async.run`："

#: ../../language/async-experimental.md:40
msgid ""
"\n"
"///| `run_async` spawn a new coroutine and execute an async function in it\n"
"fn run_async(f : async () -> Unit noraise) -> Unit = \"%async.run\"\n"
"\n"
"///| `suspend` will suspend the execution of the current coroutine.\n"
"/// The suspension will be handled by a callback passed to `suspend`\n"
"async fn[T, E : Error] suspend(\n"
"  // `f` is a callback for handling suspension\n"
"  f : (\n"
"    // the first parameter of `f` is used to resume the execution of the "
"coroutine normally\n"
"    (T) -> Unit,\n"
"    // the second parameter of `f` is used to cancel the execution of the "
"current coroutine\n"
"    // by throwing an error at suspension point\n"
"    (E) -> Unit,\n"
"  ) -> Unit,\n"
") -> T raise E = \"%async.suspend\"\n"
msgstr ""
"\n"
"/// `run_async` 会创建一个新的协程，并在其中运行一个异步函数\n"
"fn run_async(f : async () -> Unit noraise) -> Unit = \"%async.run\"\n"
"\n"
"/// `suspend` 会中断当前协程的运行。\n"
"/// `suspend` 会接受一个回调函数，并让这个回调函数来操作中断的协程\n"
"async fn[T, E : Error] suspend(\n"
"  // `f` 是负责操作中断的协程的回调函数\n"
"  f : (\n"
"    // `f` 的第一个参数用于继续运行被中断的协程\n"
"    (T) -> Unit,\n"
"    // `f` 的第二个参数用于取消被中断的协程。\n"
"    // 取消会被表示为在中断处抛出错误\n"
"    (E) -> Unit,\n"
"  ) -> Unit\n"
") -> T raise E = \"%async.suspend\"\n"

#: ../../language/async-experimental.md:46
msgid ""
"There two primitives are not intended for direct use by end users. However, "
"since MoonBit's standard library for async programming is still under "
"development, currently users need to bind these two primitives manually to "
"do async programming."
msgstr "这两个原语不应该让终端用户直接调用。但由于 MoonBit 的异步标准库仍在开发中，目前，用户需要手动绑定这两个原语，才能编写异步程序。"

#: ../../language/async-experimental.md:50
msgid "There are two ways of reading these primitives:"
msgstr "可以用两种不同的方式来理解这两个原语："

#: ../../language/async-experimental.md:52
msgid ""
"The coroutine reading: `%async.run` spawns a new coroutine, and "
"`%async.suspend` suspends the current coroutine. The main difference with "
"other languages here is: instead of yielding all the way to the caller of "
"`%async.run`, resumption of the coroutine is handled by the callback passed "
"to `%async.suspend`"
msgstr ""
"从协程的角度理解：`%async.run` 创建一个新的协程，`%async.suspend` "
"暂停当前协程。和其他语言的协程的主要区别是：协程暂停后，不是由调用 `%async.run` 的地方来负责恢复执行，而是通过传递给 "
"`%async.suspend` 的回调函数来处理协程的恢复。"

#: ../../language/async-experimental.md:57
msgid ""
"The delimited continuation reading: `%async.run` is the `reset` operator in "
"delimited continuation, and `%async.suspend` is the `shift` operator in "
"delimited continuation"
msgstr ""
"理解为 delimited continuation：`%async.run` 是 delimited continuation 中的 `reset` "
"操作符，`%async.suspend` 是 delimited continuation `shift` 操作符"

#: ../../language/async-experimental.md:61
msgid "Here's an example of how these two primitives work:"
msgstr "以下是使用这两个原语的示例："

#: ../../language/async-experimental.md:63
msgid ""
"\n"
"///|\n"
"suberror MyError derive(Show)\n"
"\n"
"///|\n"
"async fn async_worker(\n"
"  logger~ : &Logger,\n"
"  throw_error~ : Bool,\n"
") -> Unit raise MyError {\n"
"  suspend(fn(resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      logger.write_string(\"the end of the coroutine\\n\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"///|\n"
"test {\n"
"  // when supplying an anonymous function\n"
"  // to a higher order function that expects async parameter,\n"
"  // the `async` keyword can be omitted\n"
"  let logger = StringBuilder::new()\n"
"  fn local_test() {\n"
"    run_async(() => try {\n"
"      async_worker(logger~, throw_error=false)\n"
"      logger.write_string(\"the worker finishes\\n\")\n"
"    } catch {\n"
"      err => logger.write_string(\"caught: \\{err}\\n\")\n"
"    })\n"
"    logger.write_string(\"after the first coroutine finishes\\n\")\n"
"    run_async(() => try {\n"
"      async_worker(logger~, throw_error=true)\n"
"      logger.write_string(\"the worker finishes\\n\")\n"
"    } catch {\n"
"      err => logger.write_string(\"caught: \\{err}\\n\")\n"
"    })\n"
"  }\n"
"\n"
"  local_test()\n"
"  inspect(\n"
"    logger,\n"
"    content=(\n"
"      #|the worker finishes\n"
"      #|the end of the coroutine\n"
"      #|after the first coroutine finishes\n"
"      #|caught: MyError\n"
"      #|\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""
"\n"
"///|\n"
"suberror MyError derive(Show)\n"
"\n"
"///|\n"
"async fn async_worker(\n"
"  logger~ : &Logger,\n"
"  throw_error~ : Bool,\n"
") -> Unit raise MyError {\n"
"  suspend(fn(resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      logger.write_string(\"the end of the coroutine\\n\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"///|\n"
"test {\n"
"  // 当提供匿名函数时\n"
"  // 给一个期望 async 参数的高阶函数，\n"
"  // 可以省略 `async` 关键字 \n"
"  let logger = StringBuilder::new()\n"
"  fn local_test() {\n"
"    run_async(() => try {\n"
"      async_worker(logger~, throw_error=false)\n"
"      logger.write_string(\"the worker finishes\\n\")\n"
"    } catch {\n"
"      err => logger.write_string(\"caught: \\{err}\\n\")\n"
"    })\n"
"    logger.write_string(\"after the first coroutine finishes\\n\")\n"
"    run_async(() => try {\n"
"      async_worker(logger~, throw_error=true)\n"
"      logger.write_string(\"the worker finishes\\n\")\n"
"    } catch {\n"
"      err => logger.write_string(\"caught: \\{err}\\n\")\n"
"    })\n"
"  }\n"
"\n"
"  local_test()\n"
"  inspect(\n"
"    logger,\n"
"    content=(\n"
"      #|the worker finishes\n"
"      #|the end of the coroutine\n"
"      #|after the first coroutine finishes\n"
"      #|caught: MyError\n"
"      #|\n"
"    ),\n"
"  )\n"
"}\n"

#: ../../language/async-experimental.md:69
msgid ""
"In `async_worker`, `suspend` will capture the rest of the current coroutine "
"as two \"continuation\" functions, and pass them to a callback. In the "
"callback, calling `resume_ok` will resume execution at the point of "
"`suspend(...)`, all the way until the `run_async` call that start this "
"coroutine. calling `resume_err` will also resume execution of current "
"coroutine, but it will make `suspend(...)` throw an error instead of "
"returning normally."
msgstr ""
"在 `async_worker` 里，`suspend` 会捕获当前协程剩下的部分，并将它们表示成两个函数，传递给 `suspend` 的参数。在 "
"`suspend` 的参数里，调用 `resume_ok` 会让 `suspend(...)` 正常返回，恢复协程的运行，一直运行到创建这个协程的 "
"`run_async(...)` 为止。调用 `resume_err` 也会恢复协程的运行，但它会在 `suspend(...)` 的位置抛出一个错误。"

#: ../../language/async-experimental.md:75
msgid ""
"Notice that `suspend` type may throw error, even if `suspend` itself never "
"throw an error directly. This design makes coroutines cancellable at every "
"`suspend` call: just call the corresponding `resume_err` callback."
msgstr ""
"`suspend` 的类型表明它可能抛出错误。但 `suspend` "
"自身不会直接产生任何错误。这一设计保证了协程在每一个的中断点都是可以取消的：调用对应的 `resume_err` 函数即可。"

#: ../../language/async-experimental.md:78
msgid "Integrating with JS Promise/callback based API"
msgstr "和 JS 的 Promise/回调 API 整合"

#: ../../language/async-experimental.md:79
msgid ""
"Since MoonBit's standard async library is still under development, so there "
"is no ready-to-use implementation for event loop and IO operations yet. So "
"the easiest way to write some async program is to use MoonBit's Javascript "
"backend, and reuse the event loop and IO operations of Javascript. Here's an"
" example of integrating MoonBit's async programming support with JS's "
"callback based API:"
msgstr ""
"MoonBit 的异步标准库仍在开发中，因此，目前没有直接可用的事件循环和输入输出原语实现。目前，要使用 MoonBit 编写异步程序最简单的办法是使用"
" JS 后端，并复用 JavaScript 的事件循环和输入输出 API。下面是一个整合 MoonBit 的异步编程支持和 JS 的回调 API "
"的例子："

#: ../../language/async-experimental.md:85
msgid ""
"#external\n"
"type JSTimer\n"
"\n"
"///|\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration~ : Int) -> JSTimer "
"=\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"///|\n"
"async fn sleep(duration : Int) -> Unit raise {\n"
"  suspend(fn(resume_ok, _resume_err) {\n"
"    js_set_timeout(duration~, fn() { resume_ok(()) }) |> ignore\n"
"  })\n"
"}\n"
"\n"
"///|\n"
"test {\n"
"  run_async(fn() {\n"
"    try {\n"
"      sleep(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch {\n"
"      _ => panic()\n"
"    }\n"
"  })\n"
"  run_async(fn() {\n"
"    try {\n"
"      sleep(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch {\n"
"      _ => panic()\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/async-experimental.md:91
msgid ""
"Integrating with JS Promise is easy too: just pass `resume_ok` as the "
"`resolve` callback and `resume_err` as the `reject` callback to a JS "
"promise."
msgstr ""
"和 JS Promise 也非常简单：只需要把 `resume_ok` 函数用作 `Promise` 的 `resolve` 把 "
"`resume_err` 用作 Promise 的 `reject` 回调即可。"

