# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/benchmarks.md:1
msgid "Writing Benchmarks"
msgstr "编写基准测试"

#: ../../language/benchmarks.md:3
msgid ""
"Benchmarks are a way to measure the performance of your code. They can be "
"used to compare different implementations or to track performance changes "
"over time."
msgstr "基准是一种衡量代码性能的方法。它们可以用于比较不同的实现质量，或跟踪随时间变化的性能。"

#: ../../language/benchmarks.md:5
msgid "Benchmarking with Test Blocks"
msgstr "使用测试块进行基准测试"

#: ../../language/benchmarks.md:8
msgid ""
"The most simple way to benchmark a function is to use a test block with a  "
"`@bench.T` argument. It has a method `@bench.T::bench` that takes a function"
" of type `() -> Unit` and run it with a suitable number of iterations. The "
"measurements and statistical analysis will be conducted and passed to "
"`moon`, where they will be displayed in the console output."
msgstr ""
"对一个函数进行基准测试的最简单的方法是使用带有 `@bench.T` 参数的测试块。它有一个方法 "
"`@bench.T::bench`，该方法接受一个类型为 `() -> Unit` "
"的函数，并自动确定合适的迭代次数然后运行该函数多次。测量和统计分析将在 `moon` 中进行，并在控制台输出中显示。"

#: ../../language/benchmarks.md:14
msgid ""
"fn fib(n : Int) -> Int {\n"
"  if n < 2 {\n"
"    return n\n"
"  }\n"
"  return fib(n - 1) + fib(n - 2)\n"
"}\n"
"\n"
"test (b : @bench.T) {\n"
"  b.bench(fn() { b.keep(fib(20)) })\n"
"}\n"
msgstr ""
"fn fib(n : Int) -> Int {\n"
"  if n < 2 {\n"
"    return n\n"
"  }\n"
"  return fib(n - 1) + fib(n - 2)\n"
"}\n"
"\n"
"test (b : @bench.T) {\n"
"  b.bench(fn() { b.keep(fib(20)) })\n"
"}\n"

#: ../../language/benchmarks.md:20
msgid "The output is as follows:"
msgstr "输出如下所示（仅供参考）："

#: ../../language/benchmarks.md:22
msgid ""
"time (mean ± σ)         range (min … max) \n"
"  21.67 µs ±   0.54 µs    21.28 µs …  23.14 µs  in 10 ×   4619 runs\n"
msgstr ""
"time (mean ± σ)         range (min … max) \n"
"  21.67 µs ±   0.54 µs    21.28 µs …  23.14 µs  in 10 ×   4619 runs\n"

#: ../../language/benchmarks.md:27
msgid ""
"The function is executed `10 × 4619` times. The second number is "
"automatically detected by benchmark utilities, which increase the number of "
"iterations until the measurement time is long enough for accurate timing. "
"The first number can be adjusted by passing a named parameter `count` to the"
" `@bench.T::bench` argument."
msgstr ""
"该函数执行了 `10 × 4619` 次。第二个数字是由基准工具自动确定的。它会增加迭代次数，直到测量时间足够长，以获得准确的计时。第一个数字可以通过向"
" `@bench.T::bench` 传递命名参数 `count` 来调整。"

#: ../../language/benchmarks.md:31
msgid ""
"test (b : @bench.T) {\n"
"  b.bench(fn() { b.keep(fib(20)) }, count=20)\n"
"}\n"
msgstr ""
"test (b : @bench.T) {\n"
"  b.bench(fn() { b.keep(fib(20)) }, count=20)\n"
"}\n"

#: ../../language/benchmarks.md:37
msgid ""
"`@bench.T::keep` is an important auxiliary function that prevents your "
"calculation from being optimized away and skipped entirely. If you are "
"benchmarking a pure function, make sure to use this function to avoid "
"potential optimizations. However, there is still a possibility that the "
"compiler might pre-calculate and replace the calculation with a constant."
msgstr ""
"`@bench.T::keep` "
"是一个重要的辅助函数，它可以防止你的计算被优化掉并完全跳过。如果你正在基准测试一个纯函数，请确保使用这个函数以避免潜在的优化。然而，编译器仍然有可能提前计算并将计算替换为常量。"

#: ../../language/benchmarks.md:42
msgid "Batch Benchmarking"
msgstr "批量基准测试"

#: ../../language/benchmarks.md:44
msgid ""
"A common scenario of benchmarking is to compare two or more implementations "
"of the same function. In this case, you may want to bench them in a batch "
"within a block for easy comparison. The `name` parameter of the "
"`@bench.T::bench` method can be used to identify the benchmark."
msgstr ""
"基准测试的一个常见场景是比较同一函数的两个或多个实现。在这种情况下，你可能想要在一个块中批量测试它们，以便于比较。`@bench.T::bench` "
"方法的 `name` 参数可以用来标识测试块内的基准测试。"

#: ../../language/benchmarks.md:48
msgid ""
"fn fast_fib(n : Int) -> Int {\n"
"  if n < 2 {\n"
"    return n\n"
"  } else {\n"
"    let mut a = 0\n"
"    let mut b = 1\n"
"    for i = 2; i <= n; i = i + 1 {\n"
"      let t = a + b\n"
"      a = b\n"
"      b = t\n"
"    }\n"
"    b\n"
"  }\n"
"}\n"
"\n"
"test (b : @bench.T) {\n"
"  b.bench(name=\"naive_fib\", fn() { b.keep(fib(20)) })\n"
"  b.bench(name=\"fast_fib\", fn() { b.keep(fast_fib(20)) })\n"
"}\n"
msgstr ""
"fn fast_fib(n : Int) -> Int {\n"
"  if n < 2 {\n"
"    return n\n"
"  } else {\n"
"    let mut a = 0\n"
"    let mut b = 1\n"
"    for i = 2; i <= n; i = i + 1 {\n"
"      let t = a + b\n"
"      a = b\n"
"      b = t\n"
"    }\n"
"    b\n"
"  }\n"
"}\n"
"\n"
"test (b : @bench.T) {\n"
"  b.bench(name=\"naive_fib\", fn() { b.keep(fib(20)) })\n"
"  b.bench(name=\"fast_fib\", fn() { b.keep(fast_fib(20)) })\n"
"}\n"

#: ../../language/benchmarks.md:54
msgid "Now you can evaluate which one is faster by looking at the output:"
msgstr "现在你可以通过查看输出，来评估哪个实现更快："

#: ../../language/benchmarks.md:56
msgid ""
"name      time (mean ± σ)         range (min … max) \n"
"naive_fib   21.01 µs ±   0.21 µs    20.76 µs …  21.32 µs  in 10 ×   4632 "
"runs\n"
"fast_fib     0.02 µs ±   0.00 µs     0.02 µs …   0.02 µs  in 10 × 100000 "
"runs\n"
msgstr ""
"name      time (mean ± σ)         range (min … max) \n"
"naive_fib   21.01 µs ±   0.21 µs    20.76 µs …  21.32 µs  in 10 ×   4632 "
"runs\n"
"fast_fib     0.02 µs ±   0.00 µs     0.02 µs …   0.02 µs  in 10 × 100000 "
"runs\n"

#: ../../language/benchmarks.md:62
msgid "Raw Benchmark Statistics"
msgstr "基准统计的原始数据"

#: ../../language/benchmarks.md:64
msgid ""
"Sometimes users may want to obtain raw benchmark statistics for further "
"analysis. There is a function `@bench.single_bench` that returns an abstract"
" `Summary` type, which can be serialized into JSON format. The stability of "
"the `Summary` type is not guaranteed to be stable."
msgstr ""
"有时用户可能希望获取原始基准统计数据以进行进一步的分析。有一个函数 `@bench.single_bench` 返回一个抽象的 `Summary` "
"类型，用户可以将其序列化为 JSON 格式。我们不保证 `Summary` 类型内部字段的稳定性。"

#: ../../language/benchmarks.md:67
msgid ""
"In this case, users must ensure that the calculation is not optimized away. "
"There is no `keep` function available as a standalone function; it is a "
"method of `@bench.T`."
msgstr ""
"在使用 `@bench.single_bench` 时，用户必须确保计算没有被优化掉。此时没有独立的 `keep` 函数可用；之前介绍过的 `keep`"
" 是 `@bench.T` 的一个方法。"

#: ../../language/benchmarks.md:70
msgid ""
"fn collect_bench() -> Unit {\n"
"  let mut saved = 0\n"
"  let summary : @bench.Summary = @bench.single_bench(name=\"fib\", fn() {\n"
"    saved = fib(20)\n"
"  })\n"
"  println(saved)\n"
"  println(summary.to_json().stringify(escape_slash=true, indent=4))\n"
"}\n"
msgstr ""
"fn collect_bench() -> Unit {\n"
"  let mut saved = 0\n"
"  let summary : @bench.Summary = @bench.single_bench(name=\"fib\", fn() {\n"
"    saved = fib(20)\n"
"  })\n"
"  println(saved)\n"
"  println(summary.to_json().stringify())\n"
"}\n"

#: ../../language/benchmarks.md:76
msgid "The output may look like this:"
msgstr "输出可能如下所示："

#: ../../language/benchmarks.md:78
msgid ""
"6765\n"
"{\n"
"    \"name\": \"fib\",\n"
"    \"sum\": 217.22039973878972,\n"
"    \"min\": 21.62009230518067,\n"
"    \"max\": 21.87286402916848,\n"
"    \"mean\": 21.72203997387897,\n"
"    \"median\": 21.70412048323901,\n"
"    \"var\": 0.007197724461032505,\n"
"    \"std_dev\": 0.08483940394081341,\n"
"    \"std_dev_pct\": 0.39056830777787843,\n"
"    \"median_abs_dev\": 0.08189815918589166,\n"
"    \"median_abs_dev_pct\": 0.3773392211360855,\n"
"    \"quartiles\": [\n"
"        21.669052078798433,\n"
"        21.70412048323901,\n"
"        21.76141434479756\n"
"    ],\n"
"    \"iqr\": 0.09236226599912811,\n"
"    \"batch_size\": 4594,\n"
"    \"runs\": 10\n"
"}\n"
msgstr ""
"6765\n"
"{\n"
"    \"name\": \"fib\",\n"
"    \"sum\": 217.22039973878972,\n"
"    \"min\": 21.62009230518067,\n"
"    \"max\": 21.87286402916848,\n"
"    \"mean\": 21.72203997387897,\n"
"    \"median\": 21.70412048323901,\n"
"    \"var\": 0.007197724461032505,\n"
"    \"std_dev\": 0.08483940394081341,\n"
"    \"std_dev_pct\": 0.39056830777787843,\n"
"    \"median_abs_dev\": 0.08189815918589166,\n"
"    \"median_abs_dev_pct\": 0.3773392211360855,\n"
"    \"quartiles\": [\n"
"        21.669052078798433,\n"
"        21.70412048323901,\n"
"        21.76141434479756\n"
"    ],\n"
"    \"iqr\": 0.09236226599912811,\n"
"    \"batch_size\": 4594,\n"
"    \"runs\": 10\n"
"}\n"

#: ../../language/benchmarks.md:103
msgid "Time units are in microseconds."
msgstr "时间单位均为微秒。"

