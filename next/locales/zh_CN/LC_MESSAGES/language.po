# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-16 15:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/async-experimental.md:1
msgid "Experimental async programming support"
msgstr "实验性的异步编程支持"

#: ../../language/async-experimental.md:3
msgid ""
"MoonBit is providing experimental support for async programming. But the "
"design and API is still highly unstable, and may receive big breaking "
"change in the future. This page documents the current design, and we "
"highly appreciate any feedback or experiment with current design."
msgstr ""
"MoonBit 目前提供了实验性的异步编程支持。但异步相关功能的设计和 API 非常不稳定，未来可能会有大的破坏性改动。本文档页面将介绍 "
"MoonBit 异步编程目前的设计，我们欢迎及感谢任何对目前设计的反馈与使用体验分享。"

#: ../../language/async-experimental.md:7
msgid "Async function"
msgstr "异步函数"

#: ../../language/async-experimental.md:8
msgid "Async functions can be declared with the `async` keyword:"
msgstr "异步函数可以用 `async` 关键字声明："

#: ../../language/async-experimental.md:10
msgid ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// anonymous/local function\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// 匿名/本地函数\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"

#: ../../language/async-experimental.md:16
msgid "Async functions must be called with the `!!` operator:"
msgstr "调用异步函数时，必须用 `!!` 操作符来标记这是一次异步函数调用："

#: ../../language/async-experimental.md:18
msgid ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // error will be rethrowed by `!!`\n"
"  some_async_function!!()\n"
"}\n"
msgstr ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // 异步函数中的错误也会被 `!!` 转发\n"
"  some_async_function!!()\n"
"}\n"

#: ../../language/async-experimental.md:24
msgid "If the async function may throw error, `!!` will also rethrow the error."
msgstr "如果异步函数会抛出错误，`!!` 也会把错误一并转发。"

#: ../../language/async-experimental.md:26
msgid ""
"Async functions can only be called in async functions. Currently, async "
"functions cannot be called in the body of `for .. in` loops."
msgstr "异步函数只能在其他异步函数中被调用。目前，在 `for .. in` 循环中不能使用异步函数。"

#: ../../language/async-experimental.md:28
msgid "Async primitives for suspension"
msgstr "用于中断异步函数的原语"

#: ../../language/async-experimental.md:29
msgid ""
"MoonBit provides two core primitives for `%async.suspend` and "
"`%async.run`:"
msgstr "MoonBit 提供了两个用于异步编程的原语：`%async.suspend` 和 `%async.run`："

#: ../../language/async-experimental.md:31
msgid ""
"\n"
"// `run_async` spawn a new coroutine and execute an async function in it\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` will suspend the execution of the current coroutine.\n"
"// The suspension will be handled by a callback passed to `suspend`\n"
"async fn suspend[T, E : Error](\n"
"  // `f` is a callback for handling suspension\n"
"  f : (\n"
"    // the first parameter of `f` is used to resume the execution of the "
"coroutine normally\n"
"    (T) -> Unit,\n"
"    // the second parameter of `f` is used to cancel the execution of the"
" current coroutine\n"
"    // by throwing an error at suspension point\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"
msgstr ""
"\n"
"// `run_async` 会创建一个新的协程，并在其中运行一个异步函数\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` 会中断当前协程的运行。\n"
"// `suspend` 会接受一个回调函数，并让这个回调函数来操作中断的协程\n"
"async fn suspend[T, E : Error](\n"
"  // `f` 是负责操作中断的协程的回调函数\n"
"  f : (\n"
"    // `f` 的第一个参数用于继续运行被中断的协程\n"
"    (T) -> Unit,\n"
"    // `f` 的第二个参数用于取消被中断的协程。\n"
"    // 取消会被表示为在中断处抛出错误\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"

#: ../../language/async-experimental.md:37
msgid ""
"There two primitives are not intended for direct use by end users. "
"However, since MoonBit's standard library for async programming is still "
"under development, currently users need to bind these two primitives "
"manually to do async programming."
msgstr "这两个原语不应该让终端用户直接调用。但由于 MoonBit 的异步标准库仍在开发中，目前，用户需要手动绑定这两个原语，才能编写异步程序。"

#: ../../language/async-experimental.md:41
msgid "There are two ways of reading these primitives:"
msgstr "可以用两种不同的方式来理解这两个原语："

#: ../../language/async-experimental.md:43
msgid ""
"the coroutine reading: `%async.run` spawn a new coroutine, and "
"`%async.suspend` suspend current coroutine. The main difference with "
"other languages here is: instead of yielding all the way to the caller of"
" `%async.run`, resumption of the coroutine is handled by the callback "
"passed to `%async.suspend`"
msgstr ""
"理解为协程：`%async.run` 创建一个新的协程，`%async.suspend` "
"中断当前协程。和其他语言的协程的主要区别是：中断协程时，不是由创建协程的地方来负责恢复执行，而是在中断的地方通过一个回调函数就地处理中断后的协程"

#: ../../language/async-experimental.md:48
msgid ""
"the delimited continuation reading: `%async.run` is the `reset` operator "
"in delimited continuation, and `%async.suspend` is the `shift` operator "
"in delimited continuation"
msgstr ""
"理解为 delimited continuation：`%async.run` 是 delimited continuation 中的 "
"`reset` 操作符，`%async.suspend` 是 delimited continuation `shift` 操作符"

#: ../../language/async-experimental.md:51
msgid "Here's an example of how these two primitives work:"
msgstr "以下是使用这两个原语的示例："

#: ../../language/async-experimental.md:53
#, fuzzy
msgid ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"the end of the coroutine\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// the program below should print:\n"
"//\n"
"//   the worker finishes\n"
"//   the end of the coroutine\n"
"//   after the first coroutine finishes\n"
"//   caught MyError\n"
"test {\n"
"  // when supplying an anonymous function\n"
"  // to a higher order function that expects async parameter,\n"
"  // the `async` keyword can be omitted\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"after the first coroutine finishes\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"协程结束运行\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// 下面这段程序应当输出：\n"
"//\n"
"//   worker 函数返回了\n"
"//   协程结束运行\n"
"//   协程结束之后\n"
"//   捕获到了 MyError\n"
"test {\n"
"  // 在调用一个需要异步参数的高阶函数时，\n"
"  // 如果参数是一个匿名函数，可以省略 `async` 关键字\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"协程结束之后\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:59
msgid ""
"In `async_worker`, `suspend` will capture the rest of the current "
"coroutine as two \"continuation\" functions, and pass them to a callback."
" In the callback, calling `resume_ok` will resume execution at the point "
"of `suspend!!(...)`, all the way until the `run_async` call that start "
"this coroutine. calling `resume_err` will also resume execution of "
"current coroutine, but it will make `suspend!!(...)` throw an error "
"instead of returning normally."
msgstr ""
"在 `async_worker` 里，`suspend` 会捕获当前协程剩下的部分，并将它们表示成两个函数，传递给 `suspend` 的参数。在"
" `suspend` 的参数里，调用 `resume_ok` 会让 `suspend!!(...)` "
"正常返回，恢复协程的运行，一直运行到创建这个协程的 `run_async(...)` 为止。调用 `resume_err` "
"也会恢复协程的运行，但它会在 `suspend!!(...)` 的位置抛出一个错误。"

#: ../../language/async-experimental.md:65
msgid ""
"Notice that `suspend` type may throw error, even if `suspend` itself "
"never throw an error directly. This design makes coroutines cancellable "
"at every `suspend` call: just call the corresponding `resume_err` "
"callback."
msgstr ""
"`suspend` 的类型表明它可能抛出错误。但 `suspend` "
"自身不会直接产生任何错误。这一设计保证了协程在每一个的中断点都是可以取消的：调用对应的 `resume_err` 函数即可。"

#: ../../language/async-experimental.md:68
msgid "Integrating with JS Promise/callback based API"
msgstr "和 JS 的 Promise/回调 API 整合"

#: ../../language/async-experimental.md:69
msgid ""
"Since MoonBit's standard async library is still under development, so "
"there is no ready-to-use implementation for event loop and IO operations "
"yet. So the easiest way to write some async program is to use MoonBit's "
"Javascript backend, and reuse the event loop and IO operations of "
"Javascript. Here's an example of integrating MoonBit's async programming "
"support with JS's callback based API:"
msgstr ""
"MoonBit 的异步标准库仍在开发中，因此，目前没有直接可用的事件循环和输入输出原语实现。目前，要使用 MoonBit "
"编写异步程序最简单的办法是使用 JS 后端，并复用 JavaScript 的事件循环和输入输出 API。下面是一个整合 MoonBit "
"的异步编程支持和 JS 的回调 API 的例子："

#: ../../language/async-experimental.md:75
msgid ""
"type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"
msgstr ""
"type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:81
msgid ""
"Integrating with JS Promise is easy too: just pass `resume_ok` as the "
"`resolve` callback and `resume_err` as the `reject` callback to a JS "
"promise."
msgstr ""
"和 JS Promise 也非常简单：只需要把 `resume_ok` 函数用作 `Promise` 的 `resolve` 把 "
"`resume_err` 用作 Promise 的 `reject` 回调即可。"

#: ../../language/derive.md:1
msgid "Deriving traits"
msgstr "派生内建特征"

#: ../../language/derive.md:3
msgid ""
"MoonBit supports deriving a number of builtin traits automatically from "
"the type definition."
msgstr "MoonBit 支持从类型定义中自动派生一些内建特征。"

#: ../../language/derive.md:5
msgid ""
"To derive a trait `T`, it is required that all fields used in the type "
"implements `T`. For example, deriving `Show` for a struct `struct A { x: "
"T1; y: T2 }` requires both `T1: Show` and `T2: Show`"
msgstr ""
"要派生特征 `T`，需要类型中使用的所有字段都实现了 `T`。例如，为结构体 `struct A { x: T1; y: T2 }` 派生 "
"`Show` 需要 `T1: Show` 和 `T2: Show`。"

#: ../../language/derive.md:8
msgid "Show"
msgstr "输出"

#: ../../language/derive.md:10
msgid ""
"`derive(Show)` will generate a pretty-printing method for the type. The "
"derived format is similar to how the type can be constructed in code."
msgstr "`derive(Show)` 将为类型生成一个漂亮的打印方法。派生的格式类似于代码中构造类型的方式。"

#: ../../language/derive.md:13
msgid ""
"struct MyStruct {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Show)\n"
"\n"
"test \"derive show struct\" {\n"
"  let p = MyStruct::{ x: 1, y: 2 }\n"
"  assert_eq!(Show::to_string(p), \"{x: 1, y: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:19
msgid ""
"enum MyEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Show)\n"
"\n"
"test \"derive show enum\" {\n"
"  assert_eq!(Show::to_string(MyEnum::Case1(42)), \"Case1(42)\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case2(label=\"hello\")), "
"\"Case2(label=\\\"hello\\\")\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case3), \"Case3\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:25
msgid "Eq and Compare"
msgstr "相等和比较"

#: ../../language/derive.md:27
msgid ""
"`derive(Eq)` and `derive(Compare)` will generate the corresponding method"
" for testing equality and comparison. Fields are compared in the same "
"order as their definitions. For enums, the order between cases ascends in"
" the order of definition."
msgstr ""
"`derive(Eq)` 和 `derive(Compare)` "
"将为测试相等性和比较生成相应的方法。字段按照它们的定义顺序进行比较。对于枚举，构造器的顺序按照定义的顺序升序。"

#: ../../language/derive.md:31
msgid ""
"struct DeriveEqCompare {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare struct\" {\n"
"  let p1 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p2 = DeriveEqCompare::{ x: 2, y: 1 }\n"
"  let p3 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p4 = DeriveEqCompare::{ x: 1, y: 3 }\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"  \n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true)\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true)\n"
"  assert_eq!(p1 > p2, false)\n"
"  assert_eq!(p1 > p3, false)\n"
"  assert_eq!(p1 > p4, false)\n"
"  assert_eq!(p1 <= p2, true)\n"
"  assert_eq!(p1 >= p2, false)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:37
msgid ""
"enum DeriveEqCompareEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare enum\" {\n"
"  let p1 = DeriveEqCompareEnum::Case1(42)\n"
"  let p2 = DeriveEqCompareEnum::Case1(43)\n"
"  let p3 = DeriveEqCompareEnum::Case1(42)\n"
"  let p4 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p5 = DeriveEqCompareEnum::Case2(label=\"world\")\n"
"  let p6 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p7 = DeriveEqCompareEnum::Case3\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"\n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true) // 42 < 43\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true) // Case1 < Case2\n"
"  assert_eq!(p4 < p5, true)\n"
"  assert_eq!(p4 < p6, false)\n"
"  assert_eq!(p4 < p7, true) // Case2 < Case3\n"
"}\n"
msgstr ""

#: ../../language/derive.md:43
msgid "Default"
msgstr "默认值"

#: ../../language/derive.md:45
msgid ""
"`derive(Default)` will generate a method that returns the default value "
"of the type."
msgstr "`derive(Default)` 将生成一个返回类型的默认值的方法。"

#: ../../language/derive.md:47
msgid ""
"For structs, the default value is the struct with all fields set as their"
" default value."
msgstr "对于结构体，默认值是所有字段设置为它们的默认值的结构体。"

#: ../../language/derive.md:49
msgid ""
"struct DeriveDefault {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default struct\" {\n"
"  let p = DeriveDefault::default()\n"
"  assert_eq!(p, DeriveDefault::{ x: 0, y: None })\n"
"}\n"
msgstr ""

#: ../../language/derive.md:55
msgid "For enums, the default value is the only case that has no parameters."
msgstr "对于枚举，默认值是唯一没有参数的构造器。"

#: ../../language/derive.md:57
msgid ""
"enum DeriveDefaultEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default enum\" {\n"
"  assert_eq!(DeriveDefaultEnum::default(), DeriveDefaultEnum::Case3)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:63
msgid ""
"Enums that has no cases or more than one cases without parameters cannot "
"derive `Default`."
msgstr "没有构造器或有多个没有参数的构造器的枚举不能派生 `Default`。"

#: ../../language/derive.md:67
msgid ""
"enum CannotDerive1 {\n"
"    Case1(String)\n"
"    Case2(Int)\n"
"} derive(Default) // cannot find a constant constructor as default\n"
"\n"
"enum CannotDerive2 {\n"
"    Case1\n"
"    Case2\n"
"} derive(Default) // Case1 and Case2 are both candidates as default "
"constructor\n"
msgstr ""

#: ../../language/derive.md:79
msgid "Hash"
msgstr "哈希值"

#: ../../language/derive.md:81
msgid ""
"`derive(Hash)` will generate a hash implementation for the type. This "
"will allow the type to be used in places that expects a `Hash` "
"implementation, for example `HashMap`s and `HashSet`s."
msgstr ""
"`derive(Hash)` 将为类型生成一个哈希实现。这将允许类型在期望 `Hash` 实现的地方使用，例如 `HashMap` 和 "
"`HashSet`。"

#: ../../language/derive.md:85
msgid ""
"struct DeriveHash {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Hash, Eq, Show)\n"
"\n"
"test \"derive hash struct\" {\n"
"  let hs = @hashset.new()\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  assert_eq!(hs.size(), 1)\n"
"  hs.add(DeriveHash::{x: 123, y: Some(\"456\")})\n"
"  assert_eq!(hs.size(), 2)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:91
msgid "Arbitrary"
msgstr "任意值"

#: ../../language/derive.md:93
msgid "`derive(Arbitrary)` will generate random values of the given type."
msgstr "`derive(Arbitrary)` 将生成给定类型的随机值。"

#: ../../language/derive.md:95
msgid "FromJson and ToJson"
msgstr "从/到 Json"

#: ../../language/derive.md:97
msgid ""
"`derive(FromJson)` and `derive(ToJson)` will generate methods that "
"deserializes/serializes the given type from/to JSON files "
"correspondingly."
msgstr "`derive(FromJson)` 和 `derive(ToJson)` 将分别生成从/到 JSON 文件反序列化/序列化给定类型的方法。"

#: ../../language/derive.md:100
msgid ""
"struct JsonTest1 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"enum JsonTest2 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"test \"json basic\"{\n"
"  let input = JsonTest1::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"x\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest2::A(x=123)\n"
"  let expected: Json = { \"$tag\": \"A\", \"x\": 123 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:106
msgid ""
"Both derive directives accept a number of arguments to configure the "
"exact behavior of serialization and deserialization."
msgstr "这两个派生指令都接受一些参数来配置序列化和反序列化的确切行为。"

#: ../../language/derive.md:109
msgid "The actual behavior of JSON serialization arguments is unstable."
msgstr "JSON 序列化参数的实际行为是不稳定的。"

#: ../../language/derive.md:112
msgid ""
"struct JsonTest3 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(\n"
"  FromJson(fields(x(rename = \"renamedX\"))), \n"
"  ToJson(fields(x(rename = \"renamedX\"))),\n"
"  Eq, Show\n"
")\n"
"\n"
"enum JsonTest4 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(\n"
"  FromJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  ToJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  Eq, Show\n"
")\n"
"\n"
"test \"json args\"{\n"
"  let input = JsonTest3::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"renamedX\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest4::A(x=123)\n"
"  let expected: Json = { \"A\": { \"X\": 123 } }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:118
msgid "Enum representations"
msgstr "枚举表示"

#: ../../language/derive.md:120
msgid ""
"Enums can be represented in JSON in a number of styles. There are two "
"aspects of the representation:"
msgstr "枚举表示为 JSON 有多种风格。表示有两个方面："

#: ../../language/derive.md:123
msgid ""
"**Tag position** determines where the name of the enum tag (i.e. case or "
"constructor name) is stored."
msgstr "**标签位置** 决定枚举标签（即构造器名称）的名称存储在哪里。"

#: ../../language/derive.md:124
msgid ""
"**Case representation** determines how to represent the payload of the "
"enum."
msgstr "**构造器表示** 决定如何表示枚举的负载。"

#: ../../language/derive.md:126
msgid "Let's consider the following enum definition:"
msgstr "让我们考虑以下枚举定义："

#: ../../language/derive.md:128
msgid ""
"enum E {\n"
"    Uniform(Int)\n"
"    Axes(x~: Int, y~: Int)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:135
msgid "For tag position, there are 4 variants:"
msgstr "对于标签位置，有 4 个变体："

#: ../../language/derive.md:137
msgid "**Internally tagged** puts the tag alongside the payload values:"
msgstr "**内部标记** 将标签与负载值一起放置："

#: ../../language/derive.md:139
msgid ""
"`{ \"$tag\": \"Uniform\", \"0\": 1 }`, `{ \"$tag\": \"Axes\", \"x\": 2, "
"\"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:141
msgid ""
"**Externally tagged** puts the tag as the JSON object key outside the "
"payload values:"
msgstr "**外部标记** 将标签作为 JSON 对象键放置在负载值之外："

#: ../../language/derive.md:143
msgid "`{ \"Uniform\": { \"0\": 1 } }`, `{ \"Axes\": { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:145
msgid ""
"**Adjacently tagged** puts the tag payload in two adjacent keys in a JSON"
" object:"
msgstr "**相邻标记** 将标签负载放置在 JSON 对象中的两个相邻键中："

#: ../../language/derive.md:147
msgid ""
"`{ \"t\": \"Uniform\", \"c\": { \"0\": 1 } }`, `{ \"t\": \"Axes\", \"c\":"
" { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:149
msgid "**Untagged** has no explicit tag identifying which case the data is:"
msgstr "**无标记** 没有明确的标记标识数据属于哪个构造器："

#: ../../language/derive.md:151
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`."
msgstr ""

#: ../../language/derive.md:153
msgid ""
"The JSON deserializer will try to deserialize each case in order and "
"return the first one succeeding."
msgstr "JSON 反序列化器将尝试按顺序反序列化每个构造器，并返回第一个成功的构造器。"

#: ../../language/derive.md:155
msgid "For case representation, there are 2 variants:"
msgstr "对于构造器表示，有 2 个变体："

#: ../../language/derive.md:157
msgid ""
"**Object-like** representation serializes enum payloads into a JSON "
"object, whose key is either the tag name or the string of the positional "
"index within the struct."
msgstr "**对象式** 表示将枚举负载序列化为 JSON 对象，其键是标签名称或结构体中的位置索引的字符串。"

#: ../../language/derive.md:160
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:162
msgid ""
"**Tuple-like** representation serializes enum payloads into a tuple (jSON"
" array), in the same order as the type declaration. Labels are omitted in"
" tuple-like representations."
msgstr "**元组式** 表示将枚举负载序列化为元组（JSON 数组），顺序与类型声明相同。标签在元组式表示中被省略。"

#: ../../language/derive.md:166
msgid "`[1]`, `[2, 3]`"
msgstr ""

#: ../../language/derive.md:168
msgid ""
"The two aspects can be combined freely, except one case: _internally "
"tagged_ enums cannot use _tuple-like_ representation."
msgstr "这两个方面可以自由组合，除了一个情况：_内部标记_ 枚举不能使用 _元组式_ 表示。"

#: ../../language/derive.md:171
msgid "Container arguments"
msgstr "容器参数"

#: ../../language/derive.md:173
msgid ""
"`repr(...)` configures the representation of the container. This controls"
" the tag position of enums. For structs, the tag is assumed to be the "
"type of the type."
msgstr "`repr(...)` 配置容器的表示。这控制枚举的标签位置。对于结构体，假定标签是类型的类型。"

#: ../../language/derive.md:177
msgid "There are 4 representations available for selection:"
msgstr "有 4 种可供选择的表示："

#: ../../language/derive.md:179
msgid ""
"`repr(tag = \"tag\")` – Use internally tagged representation, with the "
"tag's object key name as specified."
msgstr "`repr(tag = \"tag\")` – 使用内部标记表示，标记的对象键名称如指定。"

#: ../../language/derive.md:182
msgid "`repr(untagged)` – Use untagged representation."
msgstr "`repr(untagged)` – 使用无标记表示。"

#: ../../language/derive.md:184
msgid "`repr(ext_tagged)` – Use externally tagged representation."
msgstr "`repr(ext_tagged)` – 使用外部标记表示。"

#: ../../language/derive.md:186
msgid ""
"`repr(tag = \"tag\", contents = \"contents\")` – Use adjacently tagged "
"representation, with the tag and contents key names as specified."
msgstr "`repr(tag = \"tag\", contents = \"contents\")` – 使用相邻标记表示，标记和内容键名称如指定。"

#: ../../language/derive.md:190
msgid "The default representation for struct is `repr(untagged)`."
msgstr "结构体的默认表示为 `repr(untagged)`。"

#: ../../language/derive.md:192
msgid "The default representation for enums is `repr(tag = \"$tag\")`"
msgstr "枚举的默认表示为 `repr(tag = \"$tag\")`"

#: ../../language/derive.md:194
msgid ""
"`case_repr(...)` (enum only) configures the case representation of the "
"container. This option is only available on enums."
msgstr "`case_repr(...)`（仅枚举）配置容器的构造器表示。此选项仅适用于枚举。"

#: ../../language/derive.md:197
msgid "`case_repr(struct)` – Use struct-like representation of enums."
msgstr "`case_repr(struct)` – 使用结构体式表示的枚举。"

#: ../../language/derive.md:200
msgid "`case_repr(tuple)` – Use tuple-like representation of enums."
msgstr "`case_repr(tuple)` – 使用元组式表示的枚举。"

#: ../../language/derive.md:203
msgid ""
"`rename_fields`, `rename_cases` (enum only), `rename_struct` (struct "
"only), `rename_all` renames fields, case names, struct name and all names"
" correspondingly, into a specific style."
msgstr ""
"`rename_fields`、`rename_cases`（仅枚举）、`rename_struct`（仅结构体）、`rename_all` "
"分别将字段、构造器名称、结构体名称和所有名称重命名为特定风格。"

#: ../../language/derive.md:207
msgid "Available parameters are:"
msgstr "可选的参数有："

#: ../../language/derive.md:209
msgid "`lowercase`"
msgstr ""

#: ../../language/derive.md:210
msgid "`UPPERCASE`"
msgstr ""

#: ../../language/derive.md:211
msgid "`camelCase`"
msgstr ""

#: ../../language/derive.md:212
msgid "`PascalCase`"
msgstr ""

#: ../../language/derive.md:213
msgid "`snake_case`"
msgstr ""

#: ../../language/derive.md:214
msgid "`SCREAMING_SNAKE_CASE`"
msgstr ""

#: ../../language/derive.md:215
msgid "`kebab-case`"
msgstr ""

#: ../../language/derive.md:216
msgid "`SCREAMING-KEBAB-CASE`"
msgstr ""

#: ../../language/derive.md:218
msgid ""
"Example: `rename_fields = \"PascalCase\"` for a field named "
"`my_long_field_name` results in `MyLongFieldName`."
msgstr ""
"例如：`rename_fields = \"PascalCase\"` 用于名为 `my_long_field_name` 的字段将得到 "
"`MyLongFieldName`。"

#: ../../language/derive.md:222
msgid ""
"Renaming assumes the name of fields in `snake_case` and the name of "
"structs/enum cases in `PascalCase`."
msgstr "重命名假定字段的名称为 `snake_case`，结构体/枚举构造器的名称为 `PascalCase`。"

#: ../../language/derive.md:225
msgid "`cases(...)` (enum only) controls the layout of enum cases."
msgstr "`cases(...)`（仅枚举）控制枚举构造器的布局。"

#: ../../language/derive.md:227
msgid "For example, for an enum"
msgstr "例如，对于一个枚举"

#: ../../language/derive.md:229
msgid ""
"enum E {\n"
"  A(...)\n"
"  B(...)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:236
msgid "you are able to control each case using `cases(A(...), B(...))`."
msgstr "您可以使用 `cases(A(...), B(...))` 控制每个构造器。"

#: ../../language/derive.md:238
msgid "See [Case arguments](#case-arguments) below for details."
msgstr "有关详细信息，请参见下面的[构造器参数](#case-arguments)。"

#: ../../language/derive.md:240
msgid "`fields(...)` (struct only) controls the layout of struct fields."
msgstr "`fields(...)`（仅结构体）控制结构体字段的布局。"

#: ../../language/derive.md:242
msgid "For example, for a struct"
msgstr "例如，对于一个结构体"

#: ../../language/derive.md:244
msgid ""
"struct S {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/derive.md:251
msgid "you are able to control each field using `fields(x(...), y(...))`"
msgstr "您可以使用 `fields(x(...), y(...))` 控制每个字段。"

#: ../../language/derive.md:253 ../../language/derive.md:263
msgid "See [Field arguments](#field-arguments) below for details."
msgstr "有关详细信息，请参见下面的[字段参数](#field-arguments)。"

#: ../../language/derive.md:255
msgid "Case arguments"
msgstr "构造器参数"

#: ../../language/derive.md:257
msgid ""
"`rename = \"...\"` renames this specific case, overriding existing "
"container-wide rename directive if any."
msgstr "`rename = \"...\"` 重命名此特定构造器，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/derive.md:260
msgid ""
"`fields(...)` controls the layout of the payload of this case. Note that "
"renaming positional fields are not possible currently."
msgstr "`fields(...)` 控制此构造器的负载布局。请注意，目前无法重命名位置字段。"

#: ../../language/derive.md:265
msgid "Field arguments"
msgstr "字段参数"

#: ../../language/derive.md:267
msgid ""
"`rename = \"...\"` renames this specific field, overriding existing "
"container-wide rename directives if any."
msgstr "`rename = \"...\"` 重命名此特定字段，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/docs.md:1
msgid "Documentation"
msgstr "文档"

#: ../../language/docs.md:3
msgid "Doc Comments"
msgstr "文档注释"

#: ../../language/docs.md:5
msgid ""
"Doc comments are comments prefix with `///` in each line in the leading "
"of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc "
"comments contains a markdown text and several pragmas."
msgstr ""
"文档注释是在顶层结构（如 `fn`、`let`、`enum`、`struct`、`type`）的每一行前面加上 `///` "
"的注释。文档注释包含一个 markdown 文本和几个注解。"

#: ../../language/docs.md:7
msgid ""
"/// Return a new array with reversed elements.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"
msgstr ""
"/// 返回一个新数组，其中元素被反转。\n"
"///\n"
"/// # 示例\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"

#: ../../language/docs.md:13
msgid "Pragmas"
msgstr "注解"

#: ../../language/docs.md:15
msgid ""
"Pragmas are annotations inside doc comments. They all take the form `/// "
"@word ...`. The _word_ indicates the type of pragma and is followed "
"optionally by several _word_ or string literals. Pragmas do not normally "
"affect the meaning of programs. Unrecognized pragmas will be reported as "
"warnings."
msgstr ""
"注解是文档注释中的标记。它们都采用 `/// @word ...` 的形式。_word_ 表示注解的类型，后面可以跟几个 _word_ "
"或字符串文字。注解通常不会影响程序的含义。未识别的注解将被报告为警告。"

#: ../../language/docs.md:17
msgid "Alert Pragmas"
msgstr "警告注解"

#: ../../language/docs.md:19
msgid ""
"Alert pragmas in doc comments of functions will be reported when those "
"functions are referenced. This mechanism is a generalized way to mark "
"functions as `deprecated` or `unsafe`."
msgstr "函数文档注释中的警告注解将在引用这些函数时报告。这种机制是一种通用的方法，用于将函数标记为 `deprecated` 或 `unsafe`。"

#: ../../language/docs.md:21
msgid "It takes the form `@alert category \"alert message...\"`."
msgstr "它采用 `@alert category \"alert message...\"` 的形式。"

#: ../../language/docs.md:23
msgid ""
"The category can be an arbitrary identifier. It allows configuration to "
"decide which alerts are enabled or turned into errors."
msgstr "类别可以是任意标识符。它允许配置决定哪些警告是启用的或转换为错误。"

#: ../../language/docs.md:26
msgid ""
"/// @alert deprecated \"Use foo2 instead\"\n"
"pub fn foo() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"/// @alert unsafe \"Div will cause an error when y is zero\"\n"
"pub fn div(x : Int, y : Int) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"test {\n"
"  // Warning (Alert deprecated): Use foo2 instead\n"
"  foo()\n"
"  // Warning (Alert unsafe): Div will cause an error when y is zero\n"
"  div(1, 2) |> ignore\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:1
msgid "Error handling"
msgstr "错误处理"

#: ../../language/error-handling.md:3
msgid ""
"Error handling has always been at core of our language design. In the "
"following we'll be explaining how error handling is done in MoonBit. We "
"assume you have some prior knowledge of MoonBit, if not, please checkout "
"[A tour of MoonBit](../tutorial/tour.md)."
msgstr ""
"错误处理一直是我们语言设计的核心。接下来我们将解释 MoonBit 中的错误处理。我们假设您对 MoonBit 有一些了解，如果没有，请查看 "
"[MoonBit 之旅](../tutorial/tour.md)。"

#: ../../language/error-handling.md:7
msgid "Error types"
msgstr "错误类型"

#: ../../language/error-handling.md:9
msgid ""
"The error values used in MoonBit must have an error type. An error type "
"can be defined in the following forms:"
msgstr "MoonBit 中使用的错误值必须具有错误类型。错误类型可以用以下形式定义："

#: ../../language/error-handling.md:12
msgid ""
"type! E1 Int // error type E1 has one constructor E1 with an Int payload\n"
"\n"
"type! E2  // error type E2 has one constructor E2 with no payload\n"
"\n"
"type! E3 { // error type E3 has three constructors like a normal enum "
"type\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"
msgstr ""
"type! E1 Int  // 错误类型 E1 具有一个构造器 E1，并带有一个 Int 负载\n"
"type! E2      // 错误类型 E2 具有一个没有负载的构造器 E2\n"
"type! E3 {    // 错误类型 E3 类似于普通的枚举类型，有三个构造器\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"

#: ../../language/error-handling.md:19
msgid ""
"The return type of a function can include an error type to indicate that "
"the function might return an error. For example, the following function "
"`div` might return an error of type `DivError`:"
msgstr "函数的返回类型可以包含错误类型，以表明函数可能返回一个错误。例如，以下函数 `div` 可能返回一个类型为 `DivError` 的错误："

#: ../../language/error-handling.md:23
msgid ""
"type! DivError String\n"
"\n"
"fn div(x : Int, y : Int) -> Int!DivError {\n"
"  if y == 0 {\n"
"    raise DivError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:30
msgid ""
"Here, the keyword `raise` is used to interrupt the function execution and"
" return an error."
msgstr "这里使用了关键字 `raise` 来中断函数执行并返回一个错误。"

#: ../../language/error-handling.md:33
msgid "The Default Error Type"
msgstr "默认错误类型"

#: ../../language/error-handling.md:35
msgid ""
"MoonBit provides a default error type `Error` that can be used when the "
"concrete error type is not important. For convenience, you can annotate "
"the function name or the return type with the suffix `!` to indicate that"
" the `Error` type is used. For example, the following function signatures"
" are equivalent:"
msgstr ""
"MoonBit 提供了一个默认错误类型 `Error`，当具体的错误类型不重要时可以使用它。为了方便起见，您可以在函数名或返回类型后面加上后缀 "
"`!`，以表示使用了 `Error` 类型。例如，以下函数签名是等价的："

#: ../../language/error-handling.md:40
msgid ""
"fn f() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"fn g!() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn h() -> Unit!Error {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:47
msgid ""
"For anonymous function and matrix function, you can annotate the keyword "
"`fn` with the `!` suffix to achieve that. For example,"
msgstr "对于匿名函数和矩阵函数，您可以在关键字 `fn` 后面加上 `!` 后缀来实现这一点。例如："

#: ../../language/error-handling.md:50
msgid ""
"type! IntError Int\n"
"\n"
"fn h(f : (Int) -> Int!, x : Int) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Unit {\n"
"  let _ = h(fn! { x => raise IntError(x) }, 0)\n"
"  let _ = h(fn!(x) { raise IntError(x) }, 0)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:56
msgid ""
"As shown in the above example, the error types defined by `type!` can be "
"used as value of the type `Error` when the error is raised."
msgstr "如上例所示，`type!` 定义的错误类型可以在引发错误时作为 `Error` 类型的值使用。"

#: ../../language/error-handling.md:59
msgid ""
"Note that only error types or the type `Error` can be used as errors. For"
" functions that are generic in the error type, you can use the `Error` "
"bound to do that. For example,"
msgstr "请注意，只有错误类型或 `Error` 类型可以用作错误。对于在错误类型上是泛型的函数，您可以使用 `Error` 约束来实现。例如："

#: ../../language/error-handling.md:63
msgid ""
"// Result::unwrap_or_error\n"
"fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {\n"
"  match result {\n"
"    Ok(x) => x\n"
"    Err(e) => raise e\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:69
msgid ""
"Since the type `Error` can include multiple error types, pattern matching"
" on the `Error` type must use the wildcard `_` to match all error types. "
"For example,"
msgstr "由于 `Error` 类型可以包含多个错误类型，对 `Error` 类型进行模式匹配必须使用通配符 `_` 来匹配所有错误类型。例如："

#: ../../language/error-handling.md:72
msgid ""
"type! E4\n"
"\n"
"type! E5\n"
"\n"
"fn f(e : Error) -> Unit {\n"
"  match e {\n"
"    E4 => println(\"E1\")\n"
"    E5 => println(\"E2\")\n"
"    _ => println(\"unknown error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:78
msgid "Handling Errors"
msgstr "处理错误"

#: ../../language/error-handling.md:80
msgid "There are three ways to handle errors:"
msgstr "有三种方式可以处理错误："

#: ../../language/error-handling.md:82
msgid ""
"Append `!` after the function name in a function application to rethrow "
"the error directly in case of an error, for example:"
msgstr "在函数应用中的函数名后面附加 `!`，以便在出现错误时直接重新抛出错误，例如："

#: ../../language/error-handling.md:85
msgid ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // Rethrow the error if `div` raised an error\n"
"}\n"
msgstr ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // 如果 `div` 引发错误，则重新抛出错误\n"
"}\n"

#: ../../language/error-handling.md:91
msgid ""
"Append `?` after the function name to convert the result into a first-"
"class value of the `Result` type, for example:"
msgstr "在函数名后面附加 `?`，将结果转换为 `Result` 类型的值，例如："

#: ../../language/error-handling.md:94
msgid ""
"test {\n"
"  let res = div?(6, 3)\n"
"  inspect!(res, content=\"Ok(2)\")\n"
"  let res = div?(6, 0)\n"
"  inspect!(\n"
"    res,\n"
"    content=\n"
"      #|Err(\"division by zero\")\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:100
msgid "Use `try` and `catch` to catch and handle errors, for example:"
msgstr ""

#: ../../language/error-handling.md:102
msgid ""
"fn main {\n"
"try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  DivError(s) => println(s)\n"
"} else {\n"
"  v => println(v)\n"
"}\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:111 ../../language/fundamentals.md:117
#: ../../language/fundamentals.md:149 ../../language/fundamentals.md:176
#: ../../language/fundamentals.md:200 ../../language/fundamentals.md:592
#: ../../language/fundamentals.md:606 ../../language/fundamentals.md:620
#: ../../language/fundamentals.md:634 ../../language/fundamentals.md:646
#: ../../language/fundamentals.md:663 ../../language/fundamentals.md:701
#: ../../language/fundamentals.md:748 ../../language/fundamentals.md:762
#: ../../language/fundamentals.md:896 ../../language/fundamentals.md:932
#: ../../language/fundamentals.md:963 ../../language/fundamentals.md:990
#: ../../language/fundamentals.md:1019 ../../language/fundamentals.md:1039
#: ../../language/fundamentals.md:1073 ../../language/fundamentals.md:1087
#: ../../language/methods.md:91
msgid "Output"
msgstr "输出"

#: ../../language/error-handling.md:111
msgid "division by zero\n"
msgstr "除零"

#: ../../language/error-handling.md:115
msgid ""
"Here, `try` is used to call a function that might throw an error, and "
"`catch` is used to match and handle the caught error. If no error is "
"caught, the catch block will not be executed and the `else` block will be"
" executed instead."
msgstr ""
"这里，`try` 用于调用可能引发错误的函数，`catch` 用于匹配和处理捕获的错误。如果没有捕获到错误，`catch` 块将不会执行，而是执行"
" `else` 块。"

#: ../../language/error-handling.md:119
msgid ""
"The `else` block can be omitted if no action is needed when no error is "
"caught. For example:"
msgstr "如果不需要在没有捕获到错误时执行任何操作，则可以省略 `else` 块。例如："

#: ../../language/error-handling.md:122
msgid ""
"try {\n"
"  println(div!(42, 0))\n"
"} catch {\n"
"  _ => println(\"Error\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:129
msgid ""
"The `catch` keyword is optional, and when the body of `try` is a simple "
"expression, the curly braces can be omitted. For example:"
msgstr "`catch` 关键字是可选的，当 `try` 的主体是一个简单表达式时，大括号可以省略。例如："

#: ../../language/error-handling.md:132
msgid ""
"let a = try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  _ => 0\n"
"}\n"
"println(a)\n"
msgstr ""

#: ../../language/error-handling.md:139
msgid ""
"The `!` and `?` attributes can also be used on method invocation and pipe"
" operator. For example:"
msgstr "`!` 和 `?` 符号也可以用于方法调用和管道运算符。例如："

#: ../../language/error-handling.md:142
msgid ""
"type T Int\n"
"\n"
"type! E Int derive(Show)\n"
"\n"
"fn k(self : T) -> Unit!E {\n"
"  ...\n"
"}\n"
"\n"
"fn l() -> Unit!E {\n"
"  let x = T(42)\n"
"  k!(x)\n"
"  x.k!()\n"
"  x |> k!()\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:148
msgid ""
"However for infix operators such as `+` `*` that may raise an error, the "
"original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`."
msgstr "然而对于可能引发错误的中缀运算符，如 `+` `*`，必须使用原始形式，例如 `x.op_add!(y)`，`x.op_mul!(y)`。"

#: ../../language/error-handling.md:151
msgid ""
"Additionally, if the return type of a function includes an error type, "
"the function call must use `!` or `?` for error handling, otherwise the "
"compiler will report an error."
msgstr "此外，如果函数的返回类型包含错误类型，则函数调用必须使用 `!` 或 `?` 进行错误处理，否则编译器将报告错误。"

#: ../../language/error-handling.md:155
msgid "Error Inference"
msgstr "错误推导"

#: ../../language/error-handling.md:157
msgid ""
"Within a `try` block, several different kinds of errors can be raised. "
"When that happens, the compiler will use the type `Error` as the common "
"error type. Accordingly, the handler must use the wildcard `_` to make "
"sure all errors are caught. For example,"
msgstr ""
"在 `try` 块中，可能引发多种不同类型的错误。当发生这种情况时，编译器将使用 `Error` "
"类型作为通用错误类型。因此，处理程序必须使用通配符 `_` 来确保捕获所有错误。例如："

#: ../../language/error-handling.md:162
msgid ""
"fn f1() -> Unit!E1 {\n"
"  ...\n"
"}\n"
"\n"
"fn f2() -> Unit!E2 {\n"
"  ...\n"
"}\n"
"\n"
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch {\n"
"  E1(_) => ...\n"
"  E2 => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:169
msgid ""
"You can also use `catch!` to rethrow the uncaught errors for convenience."
" This is useful when you only want to handle a specific error and rethrow"
" others. For example,"
msgstr "您还可以使用 `catch!` 来重新抛出未捕获的错误，以方便处理。当您只想处理特定错误并重新抛出其他错误时，这很有用。例如："

#: ../../language/error-handling.md:173
msgid ""
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch! {\n"
"  E1(_) => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:180
msgid "Example: Division by Zero"
msgstr "示例：除零"

#: ../../language/error-handling.md:182
msgid ""
"We'll write a small example to demonstrate the basics of MoonBit's error "
"handling system. Consider the following `div` function which'll raise an "
"error on division by zero:"
msgstr "我们将编写一个小例子来演示 MoonBit 错误处理系统的基础知识。考虑以下 `div` 函数，它将在除零时引发错误："

#: ../../language/error-handling.md:186
msgid ""
"type! DivisionByZeroError String\n"
"fn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  if y == 0 {\n"
"    raise DivisionByZeroError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:196
msgid ""
"In before, we would typically use `type` to define a wrapper type which "
"wraps around some existing foreign type. Here however, we append `type` "
"with `!` to define a error type `DivisionByZeroError` which wraps around "
"`String`."
msgstr ""
"在以前，我们通常使用 `type` 来定义一个包装器类型，该类型包装了某些现有的外部类型。然而，在这里，我们使用 `!` 将 `type` 附加到"
" `DivisionByZeroError`，以定义一个错误类型，该类型包装了 `String`。"

#: ../../language/error-handling.md:200
msgid "`type! E S` construct a error type `E` from `S`"
msgstr "`type! E S` 从 `S` 构造一个错误类型 `E`"

#: ../../language/error-handling.md:202
msgid ""
"Just like `type`, `type!` may have a payload like the above "
"`DivisionByZeroError`, or may not, or may even have multiple constructors"
" like a normal `enum`:"
msgstr ""
"就像 `type` 一样，`type!` 可能有一个像上面的 `DivisionByZeroError` 那样的数据，也可能没有，甚至可能像普通的"
" `enum` 一样有多个构造器："

#: ../../language/error-handling.md:204
msgid ""
"type! ConnectionError {\n"
"  BrokenPipe(Int,String)\n"
"  ConnectionReset\n"
"  ConnectionAbort\n"
"  ConnectionRefused\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:213
msgid ""
"To utilize `DivisionByZeroError` type, we would usually define a function"
" which may raise error by denoting its return type like `T ! E` in the "
"signature, with `T` being the actual return type and `E` being the error "
"type. In this case, it's `Int!DivisionByZeroError`. The error can be "
"thrown using `raise e` where `e` is an instance of `E` which can be "
"constructed using the default constructor of `S`."
msgstr ""
"要使用 `DivisionByZeroError` 类型，我们通常会定义一个函数，该函数通过在签名中定义返回类型为 `T ! E` "
"来表示它会引发错误，其中 `T` 是实际的返回类型，`E` 是错误类型。在这个例子中，它是 "
"`Int!DivisionByZeroError`。错误可以使用 `raise e` 抛出，其中 `e` 是 `E` 的实例，可以使用 `S` "
"的默认构造器构造。"

#: ../../language/error-handling.md:220
msgid ""
"Any instance of an error is a second class object. Meaning it may only "
"appear in the return value. And if it does appear, the function signature"
" has to be adjusted to match with the return type."
msgstr "任何错误的实例都是一个二等公民对象。这意味着它只能出现在返回值中。如果返回值包含错误，函数签名必须调整以匹配返回类型。"

#: ../../language/error-handling.md:224
msgid ""
"The `test` block in MoonBit may also be seen as a function, with a return"
" type of Unit!Error."
msgstr "MoonBit 中的 `test` 块也可以看作是一个函数，返回类型为 Unit!Error。"

#: ../../language/error-handling.md:227
msgid "Calling an error-able function"
msgstr "调用一个可出错的函数"

#: ../../language/error-handling.md:229
msgid ""
"an error-able function is usually called in 2 manners: `f!(...)` and "
"`f?(...)`."
msgstr "一个可出错的函数通常有两种调用方式：`f!(...)` 和 `f?(...)`。"

#: ../../language/error-handling.md:231
msgid "As-is calling"
msgstr "直接调用"

#: ../../language/error-handling.md:233
msgid ""
"`f!(...)` calls the function directly. The possible error must be dealt "
"in the function that calls `f`. We can either re-raising it without "
"actually dealing with the error:"
msgstr "`f!(...)` 直接调用函数。可能的错误必须在调用 `f` 的函数中处理。我们可以重新抛出它，而不实际处理错误："

#: ../../language/error-handling.md:237
msgid ""
"// We have to match the error type of `div2` with `div`\n"
"fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  div!(x,y)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:244
msgid "or use `try...catch` block like in many other languages:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error-handling.md:246
msgid ""
"fn div3(x : Int, y : Int) -> Unit {\n"
"  try {\n"
"    div!(x, y)\n"
"  } catch { // `catch` and `except` works the same.\n"
"    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n"
"  } else {\n"
"    v => println(v)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:258
msgid ""
"The `catch...` clause has similar semantics like pattern matching. We can"
" unwrap the error to retrieve the underlying `String` and print it. "
"Additionally, there's an `else` clause to handle the value of `try...` "
"block."
msgstr ""
"`catch...` 子句的语义类似于模式匹配。我们可以解包错误以检索底层的 `String` 并打印它。此外，还有一个 `else` 子句来处理"
" `try...` 块的值。"

#: ../../language/error-handling.md:262
msgid ""
"fn test_try() -> Result[Int, Error] {\n"
"  // compiler can figure out the type of a local error-able function.\n"
"  fn f() -> _!_ {\n"
"    raise Failure(\"err\")\n"
"  }\n"
"\n"
"  try Ok(f!()) { err => Err(err) }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:273
msgid ""
"Curly braces may be omitted if the body of try is a one-liner "
"(expression). The `catch` keyword can also be omitted as well. In the "
"case where a `try` body would raise different errors, the special "
"`catch!` can be used to catch some of the errors, while re-raising other "
"uncaught errors:"
msgstr ""
"如果 `try` 的主体是一行代码（表达式），则大括号可以省略。`catch` 关键字也可以省略。在 `try` "
"主体可能引发不同错误的情况下，可以使用特殊的 `catch!` 来捕获一些错误，同时重新抛出其他未捕获的错误："

#: ../../language/error-handling.md:277
msgid ""
"type! E1\n"
"type! E2\n"
"fn f1() -> Unit!E1 { raise E1 }\n"
"fn f2() -> Unit!E2 { raise E2 }\n"
"fn f() -> Unit! {\n"
"  try {\n"
"    f1!()\n"
"    f2!()\n"
"  } catch! {\n"
"    E1 => println(\"E1\")\n"
"    // E2 gets re-raised.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:293
msgid "Convert to Result"
msgstr "转换为 Result"

#: ../../language/error-handling.md:295
msgid "Extracting values"
msgstr "提取值"

#: ../../language/error-handling.md:297
msgid ""
"A object of type `Result` is a first class value in MoonBit. `Result` has"
" 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first"
" class object and the latter accept a error object."
msgstr ""
"`Result` 类型的对象是 MoonBit 中的一等公民。`Result` 有 2 个构造器：`Ok(...)` 和 "
"`Err(...)`，前者接受一个一等公民对象，后者接受一个错误对象。"

#: ../../language/error-handling.md:299
msgid ""
"With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We "
"may use pattern matching to extract value from it:"
msgstr "使用 `f?(...)`，返回类型 `T!E` 被转换为 `Result[T,E]`。我们可以使用模式匹配从中提取值："

#: ../../language/error-handling.md:301
msgid ""
"let res = div?(10, 0)\n"
"match res {\n"
"  Ok(x) => println(x)\n"
"  Err(DivisionByZeroError(e)) => println(e)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:309
msgid "the `f?()` is basically a syntactic sugar for"
msgstr "`f?()` 基本上是一个语法糖，等价于"

#: ../../language/error-handling.md:311
msgid ""
"let res = try {\n"
"  Ok(div!(10, 0))\n"
"} catch {\n"
"  s => Err(s)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:319
msgid ""
"Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is"
" equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able "
"function `f`."
msgstr ""
"注意 `T?` 和 `f?(...)` 之间的区别：`T` 是一个类型，`T?` 等价于 `Option[T]`，而 `f?(...)` "
"是对可出错函数 `f` 的调用。"

#: ../../language/error-handling.md:323
msgid ""
"Besides pattern matching, `Result` provides some useful methods to deal "
"with possible error:"
msgstr "除了模式匹配，`Result` 还提供了一些有用的方法来处理可能的错误："

#: ../../language/error-handling.md:325
msgid ""
"let res1: Result[Int, String] = Err(\"error\")\n"
"let value = res1.or(0) // 0\n"
"\n"
"let res2: Result[Int, String] = Ok(42)\n"
"let value = res2.unwrap() // 42\n"
msgstr ""

#: ../../language/error-handling.md:333
msgid ""
"`or` returns the value if the result is `Ok` or a default value if it is "
"`Err`"
msgstr "`or` 如果结果是 `Ok`，则返回值，如果是 `Err`，则返回默认值"

#: ../../language/error-handling.md:334
msgid "`unwrap` panics if the result is `Err` and return the value if it is `Ok`"
msgstr "`unwrap` 如果结果是 `Err`，则会崩溃，如果是 `Ok`，则返回值"

#: ../../language/error-handling.md:336
msgid "Mapping values"
msgstr "映射值"

#: ../../language/error-handling.md:338
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n"
msgstr ""

#: ../../language/error-handling.md:346
msgid ""
"`map` applies a function to the value within, except it doesn't nothing "
"if result is `Err`."
msgstr "`map` 将函数应用于内部的值；如果结果是 `Err`，则不执行任何操作。"

#: ../../language/error-handling.md:347
msgid "`map_error` does the opposite."
msgstr "`map_error` 则相反。"

#: ../../language/error-handling.md:349
msgid ""
"Unlike some languages, MoonBit treats error-able and nullable value "
"differently. Although one might treat them analogously, as an `Err` "
"result contains no value, only the error, which is like `null`. MoonBit "
"knows that."
msgstr ""
"与一些语言不同，MoonBit 对可出错值和可空值进行了区分。尽管有些人可能将它们类比对待，因为一个不包含值的 `Err` 对象就像 "
"`null`。MoonBit 知道这一点。"

#: ../../language/error-handling.md:351
msgid "`to_option` converts a `Result` to `Option`."
msgstr "`to_option` 将 `Result` 转换为 `Option`。"

#: ../../language/error-handling.md:353
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let option = res1.to_option() // Some(42)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let option1 = res2.to_option() // None\n"
msgstr ""

#: ../../language/error-handling.md:361
msgid "Built-in error type and functions"
msgstr "内置错误类型和相关函数"

#: ../../language/error-handling.md:363
msgid "In MoonBit, `Error` is a generalized error type:"
msgstr "在 MoonBit 中，`Error` 是一个通用的错误类型："

#: ../../language/error-handling.md:365
msgid ""
"// These signatures are equivalent. They all raise Error.\n"
"fn f() -> Unit! { .. }\n"
"fn f!() -> Unit { .. }\n"
"fn f() -> Unit!Error { .. }\n"
"\n"
"fn test_error() -> Result[Int, Error] {\n"
"  fn f() -> _!_ {\n"
"    raise DivisionByZeroError(\"err\")\n"
"  }\n"
"\n"
"  try {\n"
"    Ok(f!())\n"
"  } catch {\n"
"    err => Err(err)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:384
msgid ""
"Although the constructor `Err` expects a type of `Error`, we may still "
"pass an error of type `DivisionByZeroError` to it."
msgstr "尽管构造器 `Err` 期望一个 `Error` 类型，我们仍然可以将 `DivisionByZeroError` 类型的错误传递给它。"

#: ../../language/error-handling.md:387
msgid ""
"But `Error` can't be constructed directly. It's meant to be passed "
"around, not used directly:"
msgstr "但是 `Error` 不能直接构造。它是用来传递的，而不是直接使用："

#: ../../language/error-handling.md:389
msgid ""
"type! ArithmeticError\n"
"\n"
"fn what_error_is_this(e : Error) -> Unit {\n"
"  match e {\n"
"    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n"
"    ArithmeticError => println(\"ArithmeticError\")\n"
"    ... => println(\"...\")\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:402
msgid ""
"`Error` is typically used where concrete error type is not needed, or "
"simply act as a catch-all for all kinds of sub-errors."
msgstr "`Error` 通常用于不需要具体错误类型的情况，或者简单地用来捕获所有的子错误。"

#: ../../language/error-handling.md:405
msgid ""
"As `Error` includes multiple error types, partial matching is not allowed"
" here. We have to do exhaustive matching by providing a catch-"
"all/wildcard case `_`."
msgstr "由于 `Error` 包含多种错误类型，这里不允许部分匹配。我们必须通过提供一个通配符 `_` 来进行兜底匹配。"

#: ../../language/error-handling.md:407
msgid ""
"We usually use the builtin `Failure` error type for a generalized error, "
"and by generalized we mean using it for trivial errors that doesn't need "
"a new error type."
msgstr "我们通常使用内置的 `Failure` 错误类型来表示通用错误：通用意味着它用于不值得单独定义类型的错误。"

#: ../../language/error-handling.md:410
msgid ""
"fn div_trivial(x : Int, y : Int) -> Int!Failure {\n"
"  if y == 0 {\n"
"    raise Failure(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:419
msgid ""
"Besides using the constructor directly, the function `fail!` provides a "
"shorthand to construct a `Failure`. And if we take a look at the source "
"code:"
msgstr "除了直接使用构造器，函数 `fail!` 提供了一个快捷方式来构造 `Failure`。如果我们查看源代码："

#: ../../language/error-handling.md:422
msgid ""
"pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n"
"  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:428
msgid ""
"We can see that `fail` is merely a constructor with a pre-defined output "
"template for showing both the error and the source location. In practice,"
" `fail!` is always preferred over `Failure`."
msgstr "我们可以看到 `fail` 只是一个带有预定义输出模板的构造函数，用于显示错误和源位置。在实践中，`fail!` 总是比 `Failure`更常用。"

#: ../../language/error-handling.md:432
msgid ""
"Other functions used to break control flow are `abort` and `panic`. They "
"are equivalent. An `panic` at any place will manually crash the program "
"at that place, and prints out stack trace."
msgstr ""
"其他用于打破控制流的函数有 `abort` 和 `panic`。它们是等效的。在任何地方的 `panic` "
"都会手动在那个地方崩溃程序，并打印出堆栈跟踪。"

#: ../../language/ffi-and-wasm-host.md:1
msgid "Foreign Function Interface(FFI)"
msgstr "外部函数接口(FFI)"

#: ../../language/ffi-and-wasm-host.md:3
msgid ""
"What we've introduced is about describing pure computation. In reality, "
"you'll need to interact with the real world. However, the \"world\" is "
"different for each backend (C, JS, Wasm, WasmGC) and is sometimes based "
"on runtime ([Wasmtime](https://wasmtime.dev/), Deno, Browser, etc.)."
msgstr "我们已经介绍的是纯粹的计算。在现实中，需要与真实世界互动。然而，对于每个后端（C、JS、Wasm、WasmGC），“世界”是不同的，并且基于运行时（[Wasmtime](https://wasmtime.dev/)、Deno、浏览器等）。"

#: ../../language/ffi-and-wasm-host.md:7
msgid ""
"You can use foreign function in MoonBit through FFI to interact with the "
"hosting runtime when embedded inside the browser or command line "
"applications through [Wasmtime](https://wasmtime.dev/) or similar "
"projects."
msgstr ""
"当嵌入到浏览器，或通过 [Wasmtime](https://wasmtime.dev/) "
"嵌入到命令行应用程序中时，可以通过外部函数接口(FFI)在 MoonBit 中使用外部函数与宿主运行时进行交互。"

#: ../../language/ffi-and-wasm-host.md:9
msgid "Init function"
msgstr "`init` 函数"

#: ../../language/ffi-and-wasm-host.md:11
msgid ""
"For WebAssembly backend, it is compiled as [start "
"function](https://webassembly.github.io/spec/core/syntax/modules.html"
"#start-function), meaning that it will be executed **before** the "
"instance is available, and the FFIs that relies on the instance's "
"exportations can not be used at this stage; for JavaScript backend, it "
"means that it will be executed during the importation stage."
msgstr ""
"对于 WebAssembly 后端，它被编译为 [start "
"函数](https://webassembly.github.io/spec/core/syntax/modules.html#start-"
"function)，这意味着它将在实例可用之前执行，并且依赖于实例的导出的外部函数接口(FFI)在这个阶段不能使用；对于 JavaScript "
"后端，这意味着它将在导入阶段执行。"

#: ../../language/ffi-and-wasm-host.md:14
msgid "Declare Foreign Reference"
msgstr "声明外部引用"

#: ../../language/ffi-and-wasm-host.md:16
msgid "You can declare a foreign reference type like this:"
msgstr "您可以像这样声明一个外部引用类型："

#: ../../language/ffi-and-wasm-host.md:18
msgid "type Canvas_ctx\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:22
msgid ""
"This will be a type that represents a reference to a foreign object, a "
"`CanvasRenderingContext2D` object held by the hosting JavaScript runtime "
"in this example."
msgstr ""
"这将是一个表示对外部对象的引用的类型，在这个例子中，它是由宿主 JavaScript 运行时持有的 "
"`CanvasRenderingContext2D` 对象。"

#: ../../language/ffi-and-wasm-host.md:24
msgid "Declare Foreign Function"
msgstr "声明外部函数"

#: ../../language/ffi-and-wasm-host.md:26
msgid ""
"You can either import a function with module name and function name or "
"writing an inline function."
msgstr "您可以通过模块名和函数名导入一个函数，也可以编写一个内联函数。"

#: ../../language/ffi-and-wasm-host.md:28
msgid "Import function"
msgstr "导入函数"

#: ../../language/ffi-and-wasm-host.md:30
msgid "You can declare a foreign function like this:"
msgstr "您可以像这样声明一个外部函数："

#: ../../language/ffi-and-wasm-host.md:32
msgid "fn cos(d : Double) -> Double = \"Math\" \"cos\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:36
msgid ""
"It's similar to a normal function definition except that the function "
"body is replaced with two strings."
msgstr "它与普通函数定义类似，只是函数体被替换为两个字符串。"

#: ../../language/ffi-and-wasm-host.md:38
msgid ""
"For Wasm(GC) backend, these two strings are used to identify the specific"
" function from a Wasm import object, the first string is the module name,"
" and the second string is the function name."
msgstr "对于 Wasm(GC) 后端，这两个字符串用于从 Wasm 导入对象中识别特定函数，第一个字符串是模块名，第二个字符串是函数名。"

#: ../../language/ffi-and-wasm-host.md:40
msgid ""
"For JS backend, these two strings are used to call a static function in "
"the global namespace. The example above becomes similar to `const cos = "
"(d) => Math.cos(d)`."
msgstr "对于 JS 后端，这两个字符串用于调用全局命名空间中的静态函数。上面的例子类似于 `const cos = (d) => Math.cos(d)`。"

#: ../../language/ffi-and-wasm-host.md:42
msgid "Inline function"
msgstr "内联函数"

#: ../../language/ffi-and-wasm-host.md:44
msgid ""
"You can also declare inline functions where the function body is replaced"
" with one string."
msgstr "您还可以声明内联函数，其中函数体被替换为一个字符串。"

#: ../../language/ffi-and-wasm-host.md:46
msgid ""
"For Wasm(GC) backend, you may declare it as a Wasm function without name "
"(which will be generated afterwards):"
msgstr "对于 Wasm(GC) 后端，您可以将其声明为一个没有名称的 Wasm 函数（稍后将生成名称）："

#: ../../language/ffi-and-wasm-host.md:48
msgid ""
"extern \"wasm\" fn abs(d : Double) -> Double =\n"
"  #|(func (param f64) (result f64))\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:53
msgid "and for JS backend, you may declare it as a lambda expression:"
msgstr "对于 JS 后端，您可以将其声明为一个 lambda 表达式："

#: ../../language/ffi-and-wasm-host.md:55
msgid ""
"extern \"js\" fn abs(d : Double) -> Double =\n"
"  #|(d) => Math.abs(d)\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:60
msgid "After declaration, you can use foreign functions like regular functions."
msgstr "声明后，您可以像普通函数一样使用外部函数。"

#: ../../language/ffi-and-wasm-host.md:62
msgid ""
"For multi-backend project, you may implement backend specific code in the"
" files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`. Check out"
" [link options](</toolchain/moon/package.md#link-options>) for details."
msgstr ""
"对于多后端项目，您可以在以 `.wasm.mbt` `.wasm-gc.mbt` 和 `.js.mbt` "
"结尾的文件中实现特定于后端的代码。有关详细信息，请查看[链接选项](</toolchain/moon/package.md#link-"
"options>)。"

#: ../../language/ffi-and-wasm-host.md:64
msgid ""
"You may also declare a foreign function that will be invoked upon a "
"foreign object by using the foreign reference type like this:"
msgstr "您还可以声明一个外部函数，该函数将通过使用外部引用类型在外部对象上调用，如下所示："

#: ../../language/ffi-and-wasm-host.md:66
msgid "fn begin_path(self: Canvas_ctx) = \"canvas\" \"begin_path\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:70
msgid ""
"and apply it to a previously owned reference normally such as "
"`context.begin_path()`."
msgstr "然后将其应用于以前拥有的引用，例如 `context.begin_path()`。"

#: ../../language/ffi-and-wasm-host.md:72
msgid "Export functions"
msgstr "导出函数"

#: ../../language/ffi-and-wasm-host.md:74
msgid ""
"Functions that are not methods nor polymorphic functions can be exported "
"if they are public and if the link configuration appears in the "
"`moon.pkg.json` of the package:"
msgstr "如果函数既不是方法也不是多态函数，则可以导出它们，前提是它们是公共的，并且链接配置出现在包的 `moon.pkg.json` 中："

#: ../../language/ffi-and-wasm-host.md:76
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"js\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ],\n"
"      \"format\": \"esm\"\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:93
msgid ""
"Each backend has a separate definition. For JS backend, a `format` option"
" is used to specify whether the generated JavaScript file should be "
"released as an ES Module (`esm`), a CommonJS module (`cjs`), or an "
"immediately invoked function expression (`iife`)."
msgstr ""
"每个后端都有单独的定义。对于 JS 后端，`format` 选项用于指定生成的 JavaScript 文件是作为 ES 模块 "
"(`esm`)、CommonJS 模块 (`cjs`) 还是立即调用的函数表达式 (`iife`) 发布。"

#: ../../language/ffi-and-wasm-host.md:95
msgid ""
"The example above will export function `add` and `fib`, and the function "
"`fib` will be exported with the name of `test`."
msgstr "上面的例子将导出函数 `add` 和 `fib`，函数 `fib` 将以 `test` 的名称导出。"

#: ../../language/ffi-and-wasm-host.md:97
msgid "Use compiled Wasm"
msgstr "使用编译后的 Wasm"

#: ../../language/ffi-and-wasm-host.md:99
msgid ""
"To use the compiled Wasm, you need to initialize the Wasm module with the"
" host functions so as to meet the needs of the foreign functions, and "
"then use the exported functions provided by the Wasm module."
msgstr "要使用编译后的 Wasm，您需要使用宿主函数初始化 Wasm 模块，以满足外部函数的需求，然后使用 Wasm 模块提供的导出函数。"

#: ../../language/ffi-and-wasm-host.md:101
msgid "Provide host functions"
msgstr "提供宿主函数"

#: ../../language/ffi-and-wasm-host.md:103
msgid ""
"To use the compiled Wasm, you must provide **All** declared foreign "
"functions in Wasm import object."
msgstr "要使用编译后的 Wasm，您必须在 Wasm 导入对象中提供**所有**声明的外部函数。"

#: ../../language/ffi-and-wasm-host.md:105
msgid "For example, to use wasm compiled from above code snippet in JavaScript:"
msgstr "例如，在 JavaScript 中使用上面代码片段编译的 wasm："

#: ../../language/ffi-and-wasm-host.md:107
msgid ""
"WebAssembly.instantiateStreaming(fetch(\"xxx.wasm\"), {\n"
"  Math: {\n"
"    cos: (d) => Math.cos(d),\n"
"  },\n"
"});\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:115
msgid ""
"Check out the documentation such as [MDN](https://developer.mozilla.org"
"/en-US/docs/WebAssembly) or the manual of runtime that you're using to "
"embed the Wasm."
msgstr ""
"查看文档，例如 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) "
"或您用于嵌入 Wasm 的运行时的手册。"

#: ../../language/ffi-and-wasm-host.md:117
msgid "Example: Smiling face"
msgstr "示例：笑脸"

#: ../../language/ffi-and-wasm-host.md:119
msgid ""
"Let's walk through a full example to draw a smiling face using Canvas API"
" in MoonBit. Suppose you created a new project with `moon new draw`"
msgstr ""
"让我们通过一个完整的示例来使用 Canvas API 在 MoonBit 中绘制一个笑脸。假设您使用 `moon new draw` "
"创建了一个新项目"

#: ../../language/ffi-and-wasm-host.md:121
msgid ""
"// We first declare a type representing the context of canvas\n"
"type Canvas_ctx\n"
"\n"
"// We then declare the foreign function interfaces\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// We then apply these functions to define the drawing function upon the "
"context\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// We also demonstrate the `println` functionality here\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"
msgstr ""
"// 首先声明一个表示 canvas 上下文的类型\n"
"type Canvas_ctx\n"

#: ../../language/ffi-and-wasm-host.md:154
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:167
msgid ""
"Build the project using `moon build`. We recommend using Wasm with GC "
"integration whenever possible (which is the default). If the environment "
"does not support the GC feature, use the `--target wasm` option instead."
msgstr ""
"使用 `moon build` 构建项目。我们建议尽可能使用 Wasm GC（这是默认值）。如果环境不支持 GC 特性，请改用 `--target"
" wasm` 选项。"

#: ../../language/ffi-and-wasm-host.md:169
msgid "We now can use it from JavaScript."
msgstr "现在我们可以从 JavaScript 中使用它。"

#: ../../language/ffi-and-wasm-host.md:171
msgid ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // import object for defining the FFI\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // Pass the JS object as parameter to draw the smiling face\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // Display the value of PI\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"
msgstr ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // 用于定义 FFI 的导入对象\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // 将 JS 对象作为参数传递以绘制笑脸\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // 显示 PI 的值\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"

#: ../../language/ffi-and-wasm-host.md:198
msgid ""
"For import object, we need to provide all the FFI used in the previously "
"defined program: the canvas rendering API, the math API and finally, an "
"API for printing to the console used by the `println` or `print` "
"function."
msgstr ""
"对于导入对象，我们需要提供先前定义的程序中使用的所有 FFI：canvas 渲染 API、math API 和最后，用于 `println` 或 "
"`print` 函数的打印到控制台的 API。"

#: ../../language/ffi-and-wasm-host.md:200
msgid ""
"As of the canvas rendering API and the math API, we can use the following"
" code to convert the methods of objects into function calls that accept "
"the object as the first parameter, and convert the constant properties of"
" objects into functions that returns the value:"
msgstr ""
"至于 canvas 渲染 API 和 math "
"API，我们可以使用以下代码将对象的方法转换为接受对象作为第一个参数的函数调用，并将对象的常量属性转换为返回值的函数："

#: ../../language/ffi-and-wasm-host.md:202
msgid ""
"function prototype_to_ffi(prototype) {\n"
"  return Object.fromEntries(\n"
"    Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"      .filter(([_key, value]) => value.value)\n"
"      .map(([key, value]) => {\n"
"        if (typeof value.value == 'function')\n"
"          return [key, Function.prototype.call.bind(value.value)]\n"
"        // TODO: it is also possible to convert properties into getters "
"and setters\n"
"        else\n"
"          return [key, () => value.value]\n"
"      })\n"
"  );\n"
"}\n"
"\n"
"const importObject = {\n"
"  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"  math: prototype_to_ffi(Math),\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:224
msgid ""
"As of the printing service, we can provide the following closure so that "
"it buffers the bytes of string until it needs to be logged to the "
"console:"
msgstr "至于打印服务，我们可以提供以下闭包，以便它缓冲字符串的字节，直到需要将其记录到控制台："

#: ../../language/ffi-and-wasm-host.md:226
msgid ""
"const [log, flush] = (() => {\n"
"  var buffer = [];\n"
"  function flush() {\n"
"    if (buffer.length > 0) {\n"
"      console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"      buffer = [];\n"
"    }\n"
"  }\n"
"  function log(ch) {\n"
"    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"    else { buffer.push(ch); }\n"
"  }\n"
"  return [log, flush]\n"
"})();\n"
"\n"
"const importObject = {\n"
"  // ...\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"}\n"
"\n"
"// ...\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    // ...\n"
"    flush()\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:259
msgid "Now, we put them together, so this is our final complete `index.html`:"
msgstr "现在，我们将它们放在一起，这是我们最终的完整 `index.html`："

#: ../../language/ffi-and-wasm-host.md:261
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"\n"
"<head></head>\n"
"\n"
"<body>\n"
"  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  <script>\n"
"    function prototype_to_ffi(prototype) {\n"
"      return Object.fromEntries(\n"
"        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"          .filter(([_key, value]) => value.value)\n"
"          .map(([key, value]) => {\n"
"            if (typeof value.value == 'function')\n"
"              return [key, Function.prototype.call.bind(value.value)]\n"
"            else\n"
"              return [key, () => value.value]\n"
"          })\n"
"      );\n"
"    }\n"
"\n"
"    const [log, flush] = (() => {\n"
"      var buffer = [];\n"
"      function flush() {\n"
"        if (buffer.length > 0) {\n"
"          console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"          buffer = [];\n"
"        }\n"
"      }\n"
"      function log(ch) {\n"
"        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"        else { buffer.push(ch); }\n"
"      }\n"
"      return [log, flush]\n"
"    })();\n"
"\n"
"\n"
"\n"
"    const importObject = {\n"
"      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"      math: prototype_to_ffi(Math),\n"
"      spectest: {\n"
"        print_char: log\n"
"      },\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"          flush()\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</body>\n"
"\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:326
msgid ""
"Make sure that `draw.wasm` and `index.html` are in the same folder, then "
"start a http server at this folder. For example, using Python:"
msgstr "确保 `draw.wasm` 和 `index.html` 在同一个文件夹中，然后在此文件夹中启动一个 http 服务器。例如，使用 Python："

#: ../../language/ffi-and-wasm-host.md:328
msgid "python3 -m http.server 8080\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:332
msgid ""
"Goto [http://localhost:8080](http://localhost:8080) in your browser, "
"there should be a smile face on the screen and an output on the console:"
msgstr ""
"在浏览器中转到 "
"[http://localhost:8080](http://localhost:8080)，屏幕上应该有一个笑脸，控制台上应该有一个输出："

#: ../../language/ffi-and-wasm-host.md:334
msgid ""
"![A smile face webpage with browser devtools "
"open](../imgs/smile_face_with_log.png)"
msgstr "![带有笑脸的浏览器开发工具的网页](../imgs/smile_face_with_log.png)"

#: ../../language/ffi-and-wasm-host.md:334
msgid "A smile face webpage with browser devtools open"
msgstr "带有笑脸的浏览器开发工具的网页"

#: ../../language/fundamentals.md:1
msgid "Fundamentals"
msgstr "基础"

#: ../../language/fundamentals.md:3
msgid "Built-in Data Structures"
msgstr "内置数据结构"

#: ../../language/fundamentals.md:5
msgid "Boolean"
msgstr "布尔值"

#: ../../language/fundamentals.md:7
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr "MoonBit 有一个内置的布尔类型，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。"

#: ../../language/fundamentals.md:9
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/fundamentals.md:16
msgid "Number"
msgstr "数字"

#: ../../language/fundamentals.md:18
msgid "MoonBit have integer type and floating point type:"
msgstr "MoonBit 有整数类型和浮点类型："

#: ../../language/fundamentals.md:9
msgid "type"
msgstr "类型"

#: ../../language/fundamentals.md:9 ../../language/fundamentals.md:117
msgid "description"
msgstr "描述"

#: ../../language/fundamentals.md:9
msgid "example"
msgstr "示例"

#: ../../language/fundamentals.md:9
msgid "`Int16`"
msgstr ""

#: ../../language/fundamentals.md:9
#, fuzzy
msgid "16-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`(42 : Int16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit signed integer"
msgstr "32 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`42`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`1000L`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt16`"
msgstr ""

#: ../../language/fundamentals.md:9
#, fuzzy
msgid "16-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`(14 : UInt16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit unsigned integer"
msgstr "32 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14U`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14UL`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Double`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit floating point, defined by IEEE754"
msgstr "64 位浮点数，由 IEEE754 定义"

#: ../../language/fundamentals.md:9
msgid "`3.14`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Float`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit floating point"
msgstr "32 位浮点数"

#: ../../language/fundamentals.md:9
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "represents numeric values larger than other types"
msgstr "表示比其他类型更大的数值"

#: ../../language/fundamentals.md:9
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/fundamentals.md:32
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal,"
" and hexadecimal numbers."
msgstr "MoonBit 还支持数字字面量，包括十进制、二进制、八进制和十六进制数字。"

#: ../../language/fundamentals.md:34
msgid ""
"To improve readability, you may place underscores in the middle of "
"numeric literals such as `1_000_000`. Note that underscores can be placed"
" anywhere within a number, not just every three digits."
msgstr "为了提高可读性，您可以在数字字面量中间放置下划线，例如 `1_000_000`。请注意，下划线可以放在数字中的任何位置，而不仅仅是每三位数字。"

#: ../../language/fundamentals.md:36
msgid "Decimal numbers can have underscore between the numbers."
msgstr "十进制数之间可以有下划线。"

#: ../../language/fundamentals.md:38
msgid ""
"By default, an int literal is signed 32-bit number. For unsigned numbers,"
" a postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed."
msgstr "默认情况下，整数字面量是有符号的 32 位数字。对于无符号数字，需要后缀 `U`；对于 64 位数字，需要后缀 `L`。"

#: ../../language/fundamentals.md:40
msgid ""
"let a = 1234\n"
"let b : Int = 1_000_000 + a\n"
"let unsigned_num       : UInt   = 4_294_967_295U\n"
"let large_num          : Int64  = 9_223_372_036_854_775_807L\n"
"let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/fundamentals.md:47
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr "二进制数有一个前导零，后跟字母 \"B\"，即 `0b`/`0B`。请注意，`0b`/`0B` 后的数字必须是 `0` 或 `1`。"

#: ../../language/fundamentals.md:50
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/fundamentals.md:57
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from"
" `0` through `7`:"
msgstr "八进制数有一个前导零，后跟字母 \"O\"，即 `0o`/`0O`。请注意，`0o`/`0O` 后的数字必须在 `0` 到 `7` 的范围内："

#: ../../language/fundamentals.md:60
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/fundamentals.md:67
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""
"十六进制数有一个前导零，后跟字母 \"X\"，即 `0x`/`0X`。请注意，`0x`/`0X` 后的数字必须在 "
"`0123456789ABCDEF` 范围内。"

#: ../../language/fundamentals.md:70
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA_B_C\n"
msgstr ""

#: ../../language/fundamentals.md:77
msgid ""
"A floating-point number literal is 64-bit floating-point number. To "
"define a float, type annotation is needed."
msgstr "浮点数字面量是 64 位浮点数。要定义一个浮点数，需要类型注释。"

#: ../../language/fundamentals.md:79
msgid ""
"let double = 3.14 // Double\n"
"let float : Float = 3.14\n"
"let float2 = (3.14 : Float)\n"
msgstr ""

#: ../../language/fundamentals.md:86
msgid ""
"A 64-bit floating-point number can also be defined using hexadecimal "
"format:"
msgstr "64 位浮点数也可以使用十六进制格式定义："

#: ../../language/fundamentals.md:88
msgid "let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9\n"
msgstr ""

#: ../../language/fundamentals.md:95
msgid "Overloaded literal"
msgstr "重载字面量"

#: ../../language/fundamentals.md:97
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"literal, and there is no need to specify the type of number via letter "
"postfix:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型："

#: ../../language/fundamentals.md:99
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/fundamentals.md:106
msgid "String"
msgstr "字符串"

#: ../../language/fundamentals.md:108
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes"
" to create a string, or use `#|` to write a multi-line string."
msgstr "`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。"

#: ../../language/fundamentals.md:110
msgid ""
"let a = \"兔rabbit\"\n"
"println(a[0])\n"
"println(a[1])\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/fundamentals.md:117
msgid ""
"'兔'\n"
"'r'\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/fundamentals.md:121
msgid ""
"In double quotes string, a backslash followed by certain special "
"characters forms an escape sequence:"
msgstr "在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列："

#: ../../language/fundamentals.md:117
msgid "escape sequences"
msgstr "转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\n`,`\\r`,`\\t`,`\\b`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr "换行，回车，水平制表符，退格"

#: ../../language/fundamentals.md:117
msgid "`\\\\`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Backslash"
msgstr "反斜杠"

#: ../../language/fundamentals.md:117
msgid "`\\x41`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Hexadecimal escape sequence"
msgstr "十六进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\o102`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Octal escape sequence"
msgstr "八进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\u5154`,`\\u{1F600}`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Unicode escape sequence"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:131
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the "
"process of constructing dynamic strings by directly embedding variable "
"values into the text. Variables used for string interpolation must "
"support the `to_string` method."
msgstr ""
"MoonBit "
"支持字符串插值。它允许您在插值字符串中替换变量。此功能通过直接将变量值嵌入文本来简化构建动态字符串的过程。用于字符串插值的变量必须支持 "
"`to_string` 方法。"

#: ../../language/fundamentals.md:133
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/fundamentals.md:140
msgid ""
"Multi-line strings do not support interpolation by default, but you can "
"enable interpolation for a specific line by changing the leading `#|` to "
"`$|`:"
msgstr "多行字符串默认不支持插值，但您可以通过将前导 `#|` 更改为 `$|` 来为特定行启用插值："

#: ../../language/fundamentals.md:142
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/fundamentals.md:149
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/fundamentals.md:153
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals.md:155
msgid "`Char` represents a Unicode code point."
msgstr "`Char` 表示一个 Unicode 码点。"

#: ../../language/fundamentals.md:157
msgid ""
"let a : Char = 'A'\n"
"let b = '\\x41'\n"
"let c = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/fundamentals.md:164
msgid "Byte(s)"
msgstr "字节"

#: ../../language/fundamentals.md:166
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape enclosed in single quotes `'`, and preceded by the character `b`. "
"Byte literals are of type `Byte`. For example:"
msgstr ""
"MoonBit 中的字节字面量是一个 ASCII 字符或一个转义字符，用单引号 `'` 括起来，并在前面加上字符 `b`。字节字面量的类型是 "
"`Byte`。例如："

#: ../../language/fundamentals.md:168
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:176
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/fundamentals.md:180
msgid ""
"A `Bytes` is a sequence of bytes. Similar to byte, bytes literals have "
"the form of `b\"...\"`. For example:"
msgstr "`Bytes` 是一系列字节。与字节类似，字节字面量的形式是 `b\"...\"`。例如："

#: ../../language/fundamentals.md:182
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq!(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:188
msgid "Tuple"
msgstr "元组"

#: ../../language/fundamentals.md:190
msgid ""
"A tuple is a collection of finite values constructed using round brackets"
" `()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. "
"Here's an example:"
msgstr ""
"元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要；例如，`(1,true)` 和 `(true,1)`"
" 有不同的类型。以下是一个示例："

#: ../../language/fundamentals.md:192
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:200
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/fundamentals.md:204
msgid "Tuples can be accessed via pattern matching or index:"
msgstr "元组可以通过模式匹配或索引访问："

#: ../../language/fundamentals.md:206
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq!(x1, x2)\n"
"  assert_eq!(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:212
msgid "Ref"
msgstr ""

#: ../../language/fundamentals.md:214
msgid "A `Ref[T]` is a mutable reference containing a value `val` of type `T`."
msgstr "`Ref[T]` 是一个包含类型 `T` 的值 `val` 的可变引用。"

#: ../../language/fundamentals.md:216
msgid ""
"It can be constructed using `{ val : x }`, and can be accessed using "
"`ref.val`. See [struct](#struct) for detailed explanation."
msgstr "可以使用 `{ val : x }` 构造它，并可以使用 `ref.val` 访问它。有关详细说明，请参见[结构体](#struct)。"

#: ../../language/fundamentals.md:218
msgid ""
"let a : Ref[Int] = { val : 100 }\n"
"\n"
"test {\n"
"  a.val = 200\n"
"  assert_eq!(a.val, 200)\n"
"  a.val += 1\n"
"  assert_eq!(a.val, 201)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:224
msgid "Option and Result"
msgstr "Option 和 Result"

#: ../../language/fundamentals.md:226
msgid ""
"`Option` and `Result` are the most common types to represent a possible "
"error or failure in MoonBit."
msgstr "`Option` 和 `Result` 是 MoonBit 中表示可能的错误或失败的最常见类型。"

#: ../../language/fundamentals.md:228
msgid ""
"`Option[T]` represents a possibly missing value of type `T`. It can be "
"abbreviated as `T?`."
msgstr "`Option[T]` 表示可能缺失的类型 `T` 的值。它可以缩写为 `T?`。"

#: ../../language/fundamentals.md:229
msgid ""
"`Result[T, E]` represents either a value of type `T` or an error of type "
"`E`."
msgstr "`Result[T, E]` 表示类型 `T` 的值或类型 `E` 的错误。"

#: ../../language/fundamentals.md:231
msgid "See [enum](#enum) for detailed explanation."
msgstr "有关详细说明，请参见[枚举](#enum)。"

#: ../../language/fundamentals.md:233
msgid ""
"test {\n"
"  let a : Option[Int] = None\n"
"  let b : Option[Int] = Some(42)\n"
"  let c : Result[Int, String] = Ok(42)\n"
"  let d : Result[Int, String] = Err(\"error\")\n"
"  match a {\n"
"    Some(_) => assert_true!(false)\n"
"    None => assert_true!(true)\n"
"  }\n"
"  match d {\n"
"    Ok(_) => assert_true!(false)\n"
"    Err(_) => assert_true!(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:239
msgid "Array"
msgstr "数组"

#: ../../language/fundamentals.md:241
msgid ""
"An array is a finite sequence of values constructed using square brackets"
" `[]`, with elements separated by commas `,`. For example:"
msgstr "数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。例如："

#: ../../language/fundamentals.md:243
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/fundamentals.md:250
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts "
"from zero."
msgstr "您可以使用 `numbers[x]` 来引用第 x 个元素。索引从零开始。"

#: ../../language/fundamentals.md:252
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq!(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:259
msgid "There are `Array[T]` and `FixedArray[T]`:"
msgstr "有 `Array[T]` 和 `FixedArray[T]`："

#: ../../language/fundamentals.md:261
msgid "`Array[T]` can grow in size, while"
msgstr "`Array[T]` 可以增长，而"

#: ../../language/fundamentals.md:262
msgid ""
"`FixedArray[T]` has a fixed size, thus it needs to be created with "
"initial value."
msgstr "`FixedArray[T]` 有固定的大小，因此需要使用初始值创建。"

#: ../../language/fundamentals.md:265
msgid "A common pitfall is creating `FixedArray` with the same initial value:"
msgstr "一个常见的陷阱是使用相同的初始值创建 `FixedArray`："

#: ../../language/fundamentals.md:267
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))"
"\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:274
msgid ""
"This is because all the cells reference to the same object (the "
"`FixedArray[Int]` in this case). One should use `FixedArray::makei()` "
"instead which creates an object for each index."
msgstr ""
"这是因为所有单元格引用相同的对象（在这种情况下是 `FixedArray[Int]`）。应该使用 "
"`FixedArray::makei()`，它为每个索引创建一个对象。"

#: ../../language/fundamentals.md:276
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::makei(\n"
"    10, \n"
"    fn (_i) { FixedArray::make(10, 0) }\n"
"  )\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:284
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"array, otherwise `Array[T]` is created:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载数组，否则将创建 `Array[T]`："

#: ../../language/fundamentals.md:287
msgid ""
"let fixed_array_1 : FixedArray[Int] = [1, 2, 3]\n"
"let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])\n"
"let array_3 = [1, 2, 3] // Array[Int]\n"
msgstr ""

#: ../../language/fundamentals.md:293
msgid "ArrayView"
msgstr ""

#: ../../language/fundamentals.md:295
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create "
"a view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""
"类似于其他语言中的 `slice`，视图是对集合的特定段的引用。您可以使用 `data[start:end]` 创建数组 `data` "
"的视图，引用从 `start` 到 `end`（不包括）的元素。`start` 和 `end` 索引都可以省略。"

#: ../../language/fundamentals.md:300
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect!(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect!(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect!(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect!(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:306
msgid "Map"
msgstr "Map"

#: ../../language/fundamentals.md:308
msgid ""
"MoonBit provides a hash map data structure that preserves insertion order"
" called `Map` in its standard library. `Map`s can be created via a "
"convenient literal syntax:"
msgstr "MoonBit 在其标准库中提供了一个保留插入顺序的哈希映射数据结构，称为 `Map`。`Map` 可以通过方便的字面量语法创建："

#: ../../language/fundamentals.md:311
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/fundamentals.md:317
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be"
" destructed elegantly with pattern matching, see [Map Pattern](#map-"
"pattern)."
msgstr "目前，映射字面量语法中的键必须是常量。`Map` 也可以通过模式匹配优雅地解构，参见 [Map 模式](#map-pattern)。"

#: ../../language/fundamentals.md:319
msgid "Json literal"
msgstr "Json 字面量"

#: ../../language/fundamentals.md:321
msgid ""
"MoonBit supports convenient json handling by overloading literals. When "
"the expected type of an expression is `Json`, number, string, array and "
"map literals can be directly used to create json data:"
msgstr ""
"MoonBit 通过重载字面量支持方便的 json 处理。当表达式的期望类型是 `Json` 时，数字、字符串、数组和映射字面量可以直接用于创建 "
"json 数据："

#: ../../language/fundamentals.md:324
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", "
"\"moonbitlang/core/coverage\"],\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:330
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr "Json 值也可以进行模式匹配，参见 [Json 模式](#json-pattern)。"

#: ../../language/fundamentals.md:332
msgid "Functions"
msgstr "函数"

#: ../../language/fundamentals.md:334
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values"
" of other functions. MoonBit's naming convention requires that function "
"names should not begin with uppercase letters (A-Z). Compare for "
"constructors in the `enum` section below."
msgstr ""
"函数接受参数并产生结果。在 MoonBit 中，函数是一等公民，这意味着函数可以是其他函数的参数或返回值。MoonBit "
"的命名约定要求函数名不应以大写字母（A-Z）开头。请参见下面的 `enum` 部分中的构造器。"

#: ../../language/fundamentals.md:336
msgid "Top-Level Functions"
msgstr "顶层函数"

#: ../../language/fundamentals.md:338
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` "
"keyword to define a top-level function that sums three integers and "
"returns the result, as follows:"
msgstr "函数可以定义为顶级或局部。我们可以使用 `fn` 关键字定义一个顶级函数，它将三个整数相加并返回结果，如下所示："

#: ../../language/fundamentals.md:340
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:346
msgid ""
"Note that the arguments and return value of top-level functions require "
"**explicit** type annotations."
msgstr "请注意，顶级函数的参数和返回值需要**显式**类型注释。"

#: ../../language/fundamentals.md:348
msgid "Local Functions"
msgstr "局部函数"

#: ../../language/fundamentals.md:350
msgid ""
"Local functions can be named or anonymous. Type annotations can be "
"omitted for local function definitions: they can be automatically "
"inferred in most cases. For example:"
msgstr "局部函数可以是命名的或匿名的。局部函数定义可以省略类型注释：在大多数情况下，它们可以自动推断。例如："

#: ../../language/fundamentals.md:352
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly applied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"
msgstr ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // 命名为 `inc`\n"
"    x + 1\n"
"  }\n"
"  // 匿名，立即应用于整数字面量 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"

#: ../../language/fundamentals.md:358
msgid ""
"There's also a form called **matrix function** that make use of [pattern "
"matching](#pattern-matching):"
msgstr "还有一种称为**矩阵函数**的形式，它使用[模式匹配](#pattern-matching)："

#: ../../language/fundamentals.md:360
msgid ""
"let extract : (Int?, Int) -> Int = fn {\n"
"  Some(x), _ => x\n"
"  None, default => default\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:366
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr "函数，无论是命名的还是匿名的，都是 _词法闭包_：没有局部绑定的任何标识符必须引用来自周围词法范围的绑定。例如："

#: ../../language/fundamentals.md:368
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:374
msgid "Function Applications"
msgstr "函数应用"

#: ../../language/fundamentals.md:376
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr "函数可以应用于括号中的参数列表："

#: ../../language/fundamentals.md:378
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/fundamentals.md:382
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown "
"below:"
msgstr "无论 `add3` 是一个使用名称定义的函数（如前面的示例）还是绑定到函数值的变量，都可以工作，如下所示："

#: ../../language/fundamentals.md:384
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq!(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:390
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that "
"evaluates to a function value is applicable:"
msgstr "表达式 `add3(1, 2, 7)` 返回 `10`。任何求值为函数值的表达式都是可应用的："

#: ../../language/fundamentals.md:392
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq!(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:399
msgid "Labelled arguments"
msgstr "带标签的参数"

#: ../../language/fundamentals.md:401
msgid ""
"**Top-level** functions can declare labelled argument with the syntax "
"`label~ : Type`. `label` will also serve as parameter name inside "
"function body:"
msgstr "**顶层**函数可以使用语法 `label~ : Type` 声明带标签的参数。`label` 也将作为函数体内的参数名："

#: ../../language/fundamentals.md:403
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:409
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. "
"`label=label` can be abbreviated as `label~`:"
msgstr "可以通过语法 `label=arg` 提供带标签的参数。`label=label` 可以缩写为 `label~`："

#: ../../language/fundamentals.md:411
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq!(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:417
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr "带标签的函数可以以任何顺序提供。参数的求值顺序与函数声明中参数的顺序相同。"

#: ../../language/fundamentals.md:419
msgid "Optional arguments"
msgstr "可选参数"

#: ../../language/fundamentals.md:421
msgid ""
"A labelled argument can be made optional by supplying a default "
"expression with the syntax `label~ : Type = default_expr`. If this "
"argument is not supplied at call site, the default expression will be "
"used:"
msgstr ""
"可以通过语法 `label~ : Type = default_expr` "
"提供默认值，使带标签的参数可以省略。如果在调用时未提供此参数，则将使用默认表达式："

#: ../../language/fundamentals.md:423
msgid ""
"fn optional(opt~ : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(optional(), 42)\n"
"  assert_eq!(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:429
msgid ""
"The default expression will be evaluated every time it is used. And the "
"side effect in the default expression, if any, will also be triggered. "
"For example:"
msgstr "默认表达式每次使用时都会被求值。并且默认表达式中的副作用（如果有）也会被触发。例如："

#: ../../language/fundamentals.md:431
msgid ""
"fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect!(incr(counter~), content=\"{val: 1}\")\n"
"  inspect!(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:437
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr "如果要在不同的函数调用之间共享默认表达式的结果，可以将默认表达式提升到顶层 `let` 声明："

#: ../../language/fundamentals.md:439
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(incr_2(), 1)\n"
"  assert_eq!(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:445
msgid ""
"Default expression can depend on the value of previous arguments. For "
"example:"
msgstr "默认表达式可以依赖于先前参数的值。例如："

#: ../../language/fundamentals.md:447
msgid ""
"fn sub_array[X](\n"
"  xs : Array[X],\n"
"  offset~ : Int,\n"
"  len~ : Int = xs.length() - offset\n"
") -> Array[X] {\n"
"  xs[offset:offset + len].iter().to_array()\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:454
msgid "Automatically insert `Some` when supplying optional arguments"
msgstr "在提供可选参数时自动插入 `Some`"

#: ../../language/fundamentals.md:456
msgid ""
"It is quite often optional arguments have type `T?` with `None` as "
"default value. In this case, passing the argument explicitly requires "
"wrapping a `Some`, which is ugly:"
msgstr "通常可选参数的类型为 `T?`，默认值为 `None`。在这种情况下，显式传递参数需要包装一个 `Some`，这很丑："

#: ../../language/fundamentals.md:460
msgid ""
"fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image"
" {\n"
"  ...\n"
"}\n"
"\n"
"let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))\n"
msgstr ""

#: ../../language/fundamentals.md:466
msgid ""
"Fortunately, MoonBit provides a special kind of optional arguments to "
"solve this problem. Optional arguments declared with `label? : T` has "
"type `T?` and `None` as default value. When supplying this kind of "
"optional argument directly, MoonBit will automatically insert a `Some`:"
msgstr ""
"幸运的是，MoonBit 提供了一种特殊类型的可选参数来解决这个问题。使用 `label? : T` 声明的可选参数的类型为 `T?`，默认值为 "
"`None`。在直接提供这种可选参数时，MoonBit 将自动插入 `Some`："

#: ../../language/fundamentals.md:470
msgid ""
"fn nice_constructor(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = nice_constructor(width=1920, height=1080)\n"
msgstr ""

#: ../../language/fundamentals.md:476
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""
"有时，直接传递类型为 `T?` 的值也很有用，例如在转发可选参数时。MoonBit 为此提供了一个语法 `label?=value`，并且 "
"`label?` 是 `label?=label` 的缩写："

#: ../../language/fundamentals.md:480
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:486
msgid "Autofill arguments"
msgstr "自动填充参数"

#: ../../language/fundamentals.md:488
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare an optional argument with "
"`_` as default value. Now if the argument is not explicitly supplied, "
"MoonBit will automatically fill it at the call site."
msgstr ""
"MoonBit 支持在调用时自动填充特定类型的参数，例如函数调用的源位置。要声明一个自动填充参数，只需将一个可选参数声明为 `_` "
"作为默认值。现在，如果未显式提供参数，MoonBit 将在调用时自动填充它。"

#: ../../language/fundamentals.md:492
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is a array containing the source location of each argument, if any:"
msgstr ""
"目前 MoonBit 支持两种类型的自动填充参数，`SourceLoc`，它是整个函数调用的源位置，以及 "
"`ArgsLoc`，它是一个数组，包含每个参数的源位置（如果有）："

#: ../../language/fundamentals.md:495
msgid ""
"fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {"
"\n"
"  $|loc of whole function call: \\{loc}\n"
"  $|loc of arguments: \\{args_loc}\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), "
"Some(<filename>:7:8-7:9), None, None]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:501
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr "自动填充参数非常有用，用于编写调试和测试工具。"

#: ../../language/fundamentals.md:503
msgid "Control Structures"
msgstr "控制结构"

#: ../../language/fundamentals.md:505
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../language/fundamentals.md:507
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr "条件表达式由条件、结果和可选的 `else` 子句或 `else if` 子句组成。"

#: ../../language/fundamentals.md:509
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:516
msgid "The curly brackets around the consequent are required."
msgstr "结果周围的大括号是必需的。"

#: ../../language/fundamentals.md:518
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and"
" the return values of the consequent and the else clause must be of the "
"same type. Here is an example:"
msgstr "请注意，条件表达式在 MoonBit 中始终返回一个值，结果和 else 子句的返回值必须是相同的类型。以下是一个示例："

#: ../../language/fundamentals.md:520
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals.md:527
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr "`else` 子句只有在返回值的类型为 `Unit`的时候省略。"

#: ../../language/fundamentals.md:529
msgid "Match Expression"
msgstr "匹配表达式"

#: ../../language/fundamentals.md:531
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](#pattern-matching) to decide which consequent to "
"evaluate and extracting variables at the same time."
msgstr "`match` 表达式类似于条件表达式，但它使用[模式匹配](#pattern-matching)来决定要评估哪个结果，并同时提取变量。"

#: ../../language/fundamentals.md:533
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:540
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, "
"and the program will terminate if that case were reached."
msgstr "如果省略了可能的条件，编译器将发出警告；如果真的出现该情况，程序将终止。"

#: ../../language/fundamentals.md:542
msgid "Guard Statement"
msgstr "卫语句"

#: ../../language/fundamentals.md:544
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing "
"the subsequent statements and returns. If the condition is not satisfied "
"(i.e., false), the code in the `else` block is executed and its "
"evaluation result is returned (the subsequent statements are skipped)."
msgstr ""
"`guard` 语句用于检查指定的不变量。如果不变量的条件得到满足，程序将继续执行后续语句。如果条件不满足（即为假），则执行 `else` "
"块中的代码且返回其值（并跳过后续语句）。"

#: ../../language/fundamentals.md:549
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect!(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:556
msgid "Guarded Let"
msgstr "卫语句与赋值绑定"

#: ../../language/fundamentals.md:558
msgid ""
"The `let` statement can be used with [pattern matching](#pattern-"
"matching). However, `let` statement can only handle one case. And `guard "
"let` can solve this issue."
msgstr ""
"`let` 语句可以与[模式匹配](#pattern-matching)一起使用。但是，`let` 语句只能处理一种情况。`guard let` "
"可以解决这个问题。"

#: ../../language/fundamentals.md:560
msgid ""
"In the following example, `getProcessedText` assumes that the input "
"`path` points to resources that are all plain text, and it uses the "
"`guard` statement to ensure this invariant. Compared to using a `match` "
"statement, the subsequent processing of `text` can have one less level of"
" indentation."
msgstr ""
"在以下示例中，`getProcessedText` 假设输入的 `path` 指向的资源都是纯文本，并使用 `guard` "
"语句来确保这个不变量。与使用 `match` 语句相比，`text` 的后续处理可以少一级缩进。"

#: ../../language/fundamentals.md:564
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String\n"
") -> String!Error {\n"
"  guard let Some(PlainText(text)) = resources[path] else {\n"
"    None => fail!(\"\\{path} not found\")\n"
"    Some(Folder(_)) => fail!(\"\\{path} is a folder\")\n"
"    Some(JsonConfig(_)) => fail!(\"\\{path} is a json config\")\n"
"  }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:570
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr "如果省略了 `else` 部分，程序将在 `guard` 语句中指定的条件不为真或无法匹配时终止。"

#: ../../language/fundamentals.md:573
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard let Some(x) = expr\n"
"// <=> guard let Some(x) = expr else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals.md:580
msgid "While loop"
msgstr "While 循环"

#: ../../language/fundamentals.md:582
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code "
"repeatedly as long as a condition is true. The condition is evaluated "
"before executing the block of code. The `while` loop is defined using the"
" `while` keyword, followed by a condition and the loop body. The loop "
"body is a sequence of statements. The loop body is executed as long as "
"the condition is true."
msgstr ""
"在 MoonBit 中，`while` 循环可用于在条件为真时重复执行一段代码块。在执行代码块之前，将评估条件。使用 `while` 关键字定义 "
"`while` 循环，后跟条件和循环体。循环体是一系列语句。只要条件为真，就会执行循环体。"

#: ../../language/fundamentals.md:584
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:592
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals.md:596
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you "
"to exit the current loop, while using `continue` skips the remaining part"
" of the current iteration and proceeds to the next iteration."
msgstr ""
"循环体支持 `break` 和 `continue`。使用 `break` 可以退出当前循环，而使用 `continue` "
"则跳过当前迭代的剩余部分并继续下一次迭代。"

#: ../../language/fundamentals.md:598
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:606
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals.md:610
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the"
" loop will end."
msgstr "`while` 循环还支持可选的 `else` 子句。当循环条件变为假时，将执行 `else` 子句，然后循环将结束。"

#: ../../language/fundamentals.md:612
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:620
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:624
msgid ""
"When there is an `else` clause, the `while` loop can also return a value."
" The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value"
" of the `else` clause."
msgstr ""
"当有 `else` 子句时，`while` 循环还可以返回一个值。返回值是 `else` 子句的评估结果。在这种情况下，如果使用 `break` "
"退出循环，需要在 `break` 后提供一个返回值，该返回值应与 `else` 子句的返回值类型相同。"

#: ../../language/fundamentals.md:626
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:634
msgid "5\n"
msgstr ""

#: ../../language/fundamentals.md:638
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:646
msgid "7\n"
msgstr ""

#: ../../language/fundamentals.md:650
msgid "For Loop"
msgstr "For 循环"

#: ../../language/fundamentals.md:652
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by"
" variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. "
"For example, the code below creates a new variable binding `i`, which has"
" a scope throughout the entire loop and is immutable. This makes it "
"easier to write clear code and reason about it:"
msgstr ""
"MoonBit 还支持 C 风格的 For 循环。关键字 `for` "
"后跟由分号分隔的变量初始化子句、循环条件和更新子句。它们不需要用括号括起来。例如，下面的代码创建了一个新的变量绑定 "
"`i`，它在整个循环中都有作用域且是不可变的。这使得编写清晰的代码并对其进行推理更容易："

#: ../../language/fundamentals.md:655
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:663
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals.md:667
msgid "The variable initialization clause can create multiple bindings:"
msgstr "变量初始化子句可以创建多个绑定："

#: ../../language/fundamentals.md:669
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:676
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In "
"other words, in the example above, the update clause does not execute `i "
"= i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at "
"the same time. Therefore, when reading the values of the binding "
"variables in the update clause, you will always get the values updated in"
" the previous iteration."
msgstr ""
"应该注意，在更新子句中，当有多个绑定变量时，语义是同时更新它们。换句话说，在上面的示例中，更新子句不会按顺序执行 `i = i + 1`，`j ="
" j + 1`，而是同时递增 `i` 和 `j`。因此，在更新子句中读取绑定变量的值时，总是会得到上一次迭代中更新的值。"

#: ../../language/fundamentals.md:678
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are "
"all optional. For example, the following two are infinite loops:"
msgstr "变量初始化子句、循环条件和更新子句都是可选的。例如，以下两个是无限循环："

#: ../../language/fundamentals.md:680
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:687
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. "
"Like the `while` loop, the `for` loop can also return a value using the "
"`break` and `else` clauses."
msgstr ""
"`for` 循环还支持 `continue`、`break` 和 `else` 子句。与 `while` 循环一样，`for` 循环也可以使用 "
"`break` 和 `else` 子句返回一个值。"

#: ../../language/fundamentals.md:689
msgid ""
"The `continue` statement skips the remaining part of the current "
"iteration of the `for` loop (including the update clause) and proceeds to"
" the next iteration. The `continue` statement can also update the binding"
" variables of the `for` loop, as long as it is followed by expressions "
"that match the number of binding variables, separated by commas."
msgstr ""
"`continue` 语句跳过当前 `for` 循环的剩余部分（包括更新子句）并继续下一次迭代。`continue` 语句还可以更新 `for` "
"循环的绑定变量，只要后面跟着与绑定变量数量匹配的表达式，用逗号分隔。"

#: ../../language/fundamentals.md:691
msgid ""
"For example, the following program calculates the sum of even numbers "
"from 1 to 6:"
msgstr "例如，以下程序计算从 1 到 6 的偶数之和："

#: ../../language/fundamentals.md:693
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:701
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals.md:705
msgid "`for .. in` loop"
msgstr "`for .. in` 循环"

#: ../../language/fundamentals.md:707
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr "MoonBit 支持通过 `for .. in` 循环语法遍历不同数据结构和序列的元素："

#: ../../language/fundamentals.md:709
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:716
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard"
" library. Any type with a method `.iter() : Iter[T]` can be traversed "
"using `for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""
"`for .. in` 循环被转换为在 MoonBit 标准库中使用 `Iter`。任何具有方法 `.iter() : Iter[T]` "
"的类型都可以使用 `for .. in` 进行遍历。有关 `Iter` 类型的更多信息，请参见下面的[迭代器](#iterator)。"

#: ../../language/fundamentals.md:719
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr "`for .. in` 循环还支持遍历整数序列，例如："

#: ../../language/fundamentals.md:721
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq!(i, 45)\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq!(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:728
msgid ""
"In addition to sequences of a single value, MoonBit also supports "
"traversing sequences of two values, such as `Map`, via the `Iter2` type "
"in MoonBit's standard library. Any type with method `.iter2() : Iter2[A, "
"B]` can be traversed using `for .. in` with two loop variables:"
msgstr ""
"除了单个值的序列外，MoonBit 还支持通过 MoonBit 标准库中的 `Iter2` 类型遍历两个值的序列，例如 `Map`。任何具有方法 "
"`.iter2() : Iter2[A, B]` 的类型都可以使用两个循环变量的 `for .. in` 进行遍历："

#: ../../language/fundamentals.md:731
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:738
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr "另一个使用两个循环变量的 `for .. in` 的示例是在遍历数组时跟踪数组索引："

#: ../../language/fundamentals.md:740
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:748
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals.md:752
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr "`for .. in` 循环的主体支持诸如 `return`、`break` 和错误处理等控制流操作："

#: ../../language/fundamentals.md:754
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:762
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals.md:766
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr "如果循环变量未使用，可以使用 `_` 忽略它。"

#: ../../language/fundamentals.md:768
msgid "Functional loop"
msgstr "函数式循环"

#: ../../language/fundamentals.md:770
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to "
"write loops in a functional style."
msgstr "函数式循环是 MoonBit 中的一个强大功能，它使您可以以函数式风格编写循环。"

#: ../../language/fundamentals.md:772
msgid ""
"A functional loop consumes arguments and returns a value. It is defined "
"using the `loop` keyword, followed by its arguments and the loop body. "
"The loop body is a sequence of clauses, each of which consists of a "
"pattern and an expression. The clause whose pattern matches the input "
"will be executed, and the loop will return the value of the expression. "
"If no pattern matches, the loop will panic. Use the `continue` keyword "
"with arguments to start the next iteration of the loop. Use the `break` "
"keyword with arguments to return a value from the loop. The `break` "
"keyword can be omitted if the value is the last expression in the loop "
"body."
msgstr ""
"函数式循环接收参数并返回一个值。它使用 `loop` "
"关键字定义，后跟其参数和循环体。循环体是一系列子句，每个子句由模式和表达式组成。与输入匹配的模式的子句将会被执行，并且循环将返回表达式的值。如果没有对应的模式，程序会中止。使用"
" `continue` 关键字和参数进入循环的下一次迭代。使用 `break` "
"关键字和参数从循环中返回一个值。如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。"

#: ../../language/fundamentals.md:774
msgid ""
"test {\n"
"  fn sum(xs : @immut/list.T[Int]) -> Int {\n"
"    loop xs, 0 {\n"
"      Nil, acc => break acc // <=> Nil, acc => acc\n"
"      Cons(x, rest), acc => continue rest, x + acc\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:781
msgid ""
"Currently in `loop exprs { ... }`, `exprs` is nonempty list, while `for {"
" ... }` is accepted for infinite loop."
msgstr "目前在 `loop exprs { ... }` 中，`exprs` 是非空列表，而 `for { ... }` 用于无限循环。"

#: ../../language/fundamentals.md:784
msgid "Labelled Continue/Break"
msgstr ""

#: ../../language/fundamentals.md:786
msgid ""
"When a loop is labelled, it can be referenced from a `break` or "
"`continue` from within a nested loop. For example:"
msgstr ""

#: ../../language/fundamentals.md:789
msgid ""
"test \"break label\" {\n"
"  let mut count = 0\n"
"  let xs = [1, 2, 3]\n"
"  let ys = [4, 5, 6]\n"
"  let res = outer~: for i in xs {\n"
"    for j in ys {\n"
"      count = count + i\n"
"      break outer~ j\n"
"    }\n"
"  } else {\n"
"    -1\n"
"  }\n"
"  assert_eq!(res, 4)\n"
"  assert_eq!(count, 1)\n"
"}\n"
"\n"
"test \"continue label\" {\n"
"  let mut count = 0\n"
"  let init = 10\n"
"  let res =outer~: loop init {\n"
"    0 => 42\n"
"    i => {\n"
"      for {\n"
"        count = count + 1\n"
"        continue outer~ i - 1\n"
"      }\n"
"    }\n"
"  }\n"
"  assert_eq!(res, 42)\n"
"  assert_eq!(count, 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:795
msgid "Iterator"
msgstr "迭代器"

#: ../../language/fundamentals.md:797
msgid ""
"An iterator is an object that traverse through a sequence while providing"
" access to its elements. Traditional OO languages like Java's "
"`Iterator<T>` use `next()` `hasNext()` to step through the iteration "
"process, whereas functional languages (JavaScript's `forEach`, Lisp's "
"`mapcar`) provides a high-order function which takes an operation and a "
"sequence then consumes the sequence with that operation being applied to "
"the sequence. The former is called _external iterator_ (visible to user) "
"and the latter is called _internal iterator_ (invisible to user)."
msgstr ""
"迭代器是一个对象，它在遍历序列的同时提供对其元素的访问。传统的面向对象语言如 Java 的 `Iterator<T>` 使用 `next()` "
"`hasNext()` 来遍历迭代过程，而函数式语言（JavaScript 的 `forEach`，Lisp 的 "
"`mapcar`）提供了一个高阶函数，该函数接受一个操作和一个序列，然后使用该操作应用于序列。前者称为_外部迭代器_（对用户可见），后者称为_内部迭代器_（对用户不可见）。"

#: ../../language/fundamentals.md:805
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator "
"implementation. Almost all built-in sequential data structures have "
"implemented `Iter`:"
msgstr "内置类型 `Iter[T]` 是 MoonBit 的内部迭代器实现。几乎所有内置的顺序数据结构都已经实现了 `Iter`："

#: ../../language/fundamentals.md:808
msgid ""
"///|\n"
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(fn { x => (x & 1) == 0 }).collect()\n"
"}\n"
"\n"
"///|\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::op_mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:814
msgid "Commonly used methods include:"
msgstr "常用的方法包括："

#: ../../language/fundamentals.md:816
msgid ""
"`each`: Iterates over each element in the iterator, applying some "
"function to each element."
msgstr "`each`: 遍历迭代器中的每个元素，对每个元素应用某个函数。"

#: ../../language/fundamentals.md:817
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr "`fold`: 使用给定的函数，从给定的初始值开始，对迭代器的元素进行“折叠”。"

#: ../../language/fundamentals.md:818
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr "`collect`: 将迭代器的元素收集到一个数组中。"

#: ../../language/fundamentals.md:820
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a "
"predicate function."
msgstr "`filter`: （惰性）根据谓词函数过滤迭代器的元素。"

#: ../../language/fundamentals.md:821
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr "`map`: （惰性）使用映射函数转换迭代器的元素。"

#: ../../language/fundamentals.md:822
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the "
"elements of the second iterator to the first."
msgstr "`concat`: （惰性）通过将第二个迭代器的元素附加到第一个迭代器，将两个迭代器合并为一个。"

#: ../../language/fundamentals.md:824
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. "
"Array. But what makes `Iter` special is that any method that constructs a"
" new `Iter` is _lazy_ (i.e. iteration doesn't start on call because it's "
"wrapped inside a function), as a result of no allocation for intermediate"
" value. That's what makes `Iter` superior for traversing through "
"sequence: no extra cost. MoonBit encourages user to pass an `Iter` across"
" functions instead of the sequence object itself."
msgstr ""
"像 `filter` `map` 这样的方法在序列对象（例如 Array）上非常常见。但是，`Iter` 的不同之处在于，任何构造新 `Iter`"
" 的方法都是**惰性**的（即在调用时不会开始迭代，因为它被包装在一个函数内），因此不会为中间值分配内存。这就是使 `Iter` "
"优于遍历序列的原因：没有额外的成本。MoonBit 鼓励用户将 `Iter` 传递给函数，而不是传递序列对象本身。"

#: ../../language/fundamentals.md:832
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement "
"`Iter`, namely, a function that returns an `Iter[S]`. Take `Bytes` as an "
"example:"
msgstr ""
"预定义的序列结构如 `Array` 及其迭代器应该足够使用。但是，为了在自定义序列（元素类型为 `S`）中使用这些方法，我们需要实现 "
"`Iter`，即返回 `Iter[S]` 的函数。以 `Bytes` 为例："

#: ../../language/fundamentals.md:837
msgid ""
"///|\n"
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"    for byte in data {\n"
"      guard let IterContinue = visit(byte) else { x => break x }\n"
"\n"
"    } else {\n"
"      IterContinue\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:843
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the "
"only main difference being the code block that actually does the "
"iteration."
msgstr "几乎所有 `Iter` 实现都与 `Bytes` 的实现相同，唯一的主要区别是实际执行迭代的代码块。"

#: ../../language/fundamentals.md:846
msgid "Implementation details"
msgstr "实现细节"

#: ../../language/fundamentals.md:848
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration"
" which consists any of the 2 states:"
msgstr ""
"类型 `Iter[T]` 基本上是 `((T) -> IterResult) -> IterResult` "
"的类型别名，它是一个高阶函数，接受一个操作，`IterResult` 是一个枚举对象，用于跟踪当前迭代的状态，包含以下 2 种状态："

#: ../../language/fundamentals.md:853
msgid "`IterEnd`: marking the end of an iteration"
msgstr "`IterEnd`: 标记迭代结束"

#: ../../language/fundamentals.md:854
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr "`IterContinue`: 标记迭代结束尚未到达，暗示迭代将在此状态继续。"

#: ../../language/fundamentals.md:856
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use "
"it to transform `Iter[T]` itself to a new state of type `IterResult`. "
"Whether that state being `IterEnd` `IterContinue` depends on the "
"function."
msgstr ""
"简单来说，`Iter[T]` 接受一个函数 `(T) -> IterResult` 并使用它将 `Iter[T]` 本身转换为类型为 "
"`IterResult` 的新状态。"

#: ../../language/fundamentals.md:860
msgid ""
"Iterator provides a unified way to iterate through data structures, and "
"they can be constructed at basically no cost: as long as `fn(yield)` "
"doesn't execute, the iteration process doesn't start."
msgstr "迭代器提供了一种统一的遍历数据结构的方式，它们基本上可以无成本地构建：只要 `fn(yield)` 不执行，迭代过程就不会开始。"

#: ../../language/fundamentals.md:864
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all"
" sorts of `Iter` methods might be visually pleasing, but do notice the "
"heavy work underneath the abstraction."
msgstr "`Iter::run()` 在在内部触发迭代。链接各种 `Iter` 方法可能看起来很美观，但请注意抽象层下面的繁重工作。"

#: ../../language/fundamentals.md:868
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no "
"way to stop unless the end is reached. Methods such as `count()` which "
"counts the number of elements in a iterator looks like an `O(1)` "
"operation but actually has linear time complexity. Carefully use "
"iterators or performance issue might occur."
msgstr ""
"因此，与外部迭代器不同，一旦迭代开始，除非到达末尾，否则无法停止。诸如 `count()` 这样的方法，它计算迭代器中元素的数量看起来像是一个 "
"`O(1)` 操作，但实际上具有线性时间复杂度。请谨慎使用迭代器，否则可能会出现性能问题。"

#: ../../language/fundamentals.md:874
msgid "Custom Data Types"
msgstr "自定义数据类型"

#: ../../language/fundamentals.md:876
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr "创建新数据类型有两种方法：`struct` 和 `enum`。"

#: ../../language/fundamentals.md:878
msgid "Struct"
msgstr "结构体"

#: ../../language/fundamentals.md:880
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed "
"by field names. A struct can be constructed using a struct literal, which"
" is composed of a set of labeled values and delimited with curly "
"brackets. The type of a struct literal can be automatically inferred if "
"its fields exactly match the type definition. A field can be accessed "
"using the dot syntax `s.f`. If a field is marked as mutable using the "
"keyword `mut`, it can be assigned a new value."
msgstr ""
"在 MoonBit "
"中，结构体类似于元组，但其字段由字段名称索引。可以使用结构体字面量构造结构体，结构体字面量由一组带标签的值组成，并用大括号括起来。如果结构体的字段与类型定义完全匹配，那么结构体字面量的类型可以自动推断。可以使用点语法"
" `s.f` 访问字段。如果使用关键字 `mut` 标记字段为可变的，则可以为其分配新值。"

#: ../../language/fundamentals.md:882
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:888
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:896
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals.md:900
msgid "Constructing Struct with Shorthand"
msgstr "使用简写构造结构体"

#: ../../language/fundamentals.md:902
msgid ""
"If you already have some variable like `name` and `email`, it's redundant"
" to repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr "如果已经有一些变量，如 `name` 和 `email`，在构造结构体时重复这些名称是多余的。可以使用简写，它的行为完全相同："

#: ../../language/fundamentals.md:904
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:911
msgid ""
"If there's no other struct that has the same fields, it's redundant to "
"add the struct's name when constructing it:"
msgstr "如果没有其他具有相同字段的结构体，在构造结构体时添加结构体的名称是多余的："

#: ../../language/fundamentals.md:913
msgid "let u2 = { id : 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:920
msgid "Struct Update Syntax"
msgstr "结构体更新语法"

#: ../../language/fundamentals.md:922
msgid ""
"It's useful to create a new struct based on an existing one, but with "
"some fields updated."
msgstr "可以用这个语法来根据现有结构体创建一个新的结构体，但只更新部分字段。"

#: ../../language/fundamentals.md:924
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"    $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:932
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals.md:936
msgid "Enum"
msgstr "枚举"

#: ../../language/fundamentals.md:938
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr "枚举类型类似于函数式语言中的代数数据类型。熟悉 C/C++ 的用户可能更喜欢称其为标记联合。"

#: ../../language/fundamentals.md:940
msgid ""
"An enum can have a set of cases (constructors). Constructor names must "
"start with capitalized letter. You can use these names to construct "
"corresponding cases of an enum, or checking which branch an enum value "
"belongs to in pattern matching:"
msgstr "枚举可以有一组情况（构造函数）。构造函数的名称必须以大写字母开头。可以使用这些名称来构造枚举的相应情况，或在模式匹配中检查枚举值属于哪个分支："

#: ../../language/fundamentals.md:942
msgid ""
"/// An enum type that represents the ordering relation between two "
"values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""
"/// 一个枚举类型，表示两个值之间的顺序关系，\n"
"/// 有三种情况 \"Smaller\"、\"Greater\" 和 \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"

#: ../../language/fundamentals.md:948
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""
"/// 比较两个整数之间的顺序关系\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // 当创建一个枚举时，如果目标类型已知，\n"
"    // 可以直接写构造函数名称\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // 但是当目标类型未知时，\n"
"    // 你总是可以使用 `TypeName::Constructor` 来创建一个枚举\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// 输出一个类型为 `Relation` 的值\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // 使用模式匹配来决定 `r` 属于哪种情况\n"
"  match r {\n"
"    // 在模式匹配期间，如果类型已知，\n"
"    // 写构造函数的名称就足够了\n"
"    Smaller => println(\"smaller!\")\n"
"    // 但是你也可以在模式匹配中使用 `TypeName::Constructor` 语法\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:955
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:963
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals.md:967
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr "枚举情况也可以携带额外数据。以下是使用枚举定义整数列表类型的示例："

#: ../../language/fundamentals.md:969
msgid ""
"enum List {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of "
"the list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, List)\n"
"}\n"
msgstr ""
"enum List {\n"
"  Nil\n"
"  // 构造函数 `Cons` 携带额外的数据：列表的第一个元素，\n"
"  // 和列表的其余部分\n"
"  Cons(Int, List)\n"
"}\n"

#: ../../language/fundamentals.md:975
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 除了将额外数据绑定到变量之外，\n"
"// 你还可以继续匹配构造函数内部的额外数据。\n"
"// 以下是一个函数，用于判断列表是否只包含一个元素\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // 此分支仅匹配形状为 `Cons(_, Nil)` 的值，\n"
"    // 即长度为 1 的列表\n"
"    Cons(_, Nil) => true\n"
"    // 使用 `_` 匹配其他所有情况\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // 在模式匹配带有额外数据的枚举时，\n"
"  // 除了决定值属于哪种情况\n"
"  // 你还可以提取该情况内部的额外数据\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // 这里 `x` 和 `xs` 定义了新变量\n"
"    // 而不是引用现有变量，\n"
"    // 如果 `l` 是一个 `Cons`，那么 `Cons` 的额外数据\n"
"    // （第一个元素和列表的其余部分）\n"
"    // 将绑定到 `x` 和 `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:982
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""
"fn main {\n"
"  // 使用 `Cons` 创建值时，必须提供 `Cons` 的额外数据\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"

#: ../../language/fundamentals.md:990
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals.md:994
msgid "Constructor with labelled arguments"
msgstr "构造器与带标签参数"

#: ../../language/fundamentals.md:996
msgid "Enum constructors can have labelled argument:"
msgstr "枚举构造器可以有带标签的参数："

#: ../../language/fundamentals.md:998
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""
"enum E {\n"
"  // `x` 和 `y` 是有标签参数\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"

#: ../../language/fundamentals.md:1004
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""
"// 使用有标签参数的构造函数进行模式匹配\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` 是 `x=x` 的缩写\n"
"    // 未匹配的有标签参数可以通过 `..` 省略\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1011
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1019
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:1023
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr "也可以像在模式匹配中访问结构体字段一样访问构造函数的有标签参数："

#: ../../language/fundamentals.md:1025
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc."
"\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // 对于通过 `Point(..) as p` 定义的变量，\n"
"    // 编译器知道它必须是构造函数 `Point`，\n"
"    // 因此可以通过 `p.x`、`p.y` 等直接访问 `Point` 的字段。\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
"\n"

#: ../../language/fundamentals.md:1031
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with!(p2))\n"
"    println(p1.distance_with!(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1039
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals.md:1043
msgid "Constructor with mutable fields"
msgstr "构造器与可变字段"

#: ../../language/fundamentals.md:1045
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr "也可以为构造器定义可变字段。这对于定义命令式数据结构特别有用："

#: ../../language/fundamentals.md:1047
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree"
"\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 使用可变二叉搜索树实现的集合。\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// 带有亲指针的可变二叉搜索树\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // 只有带标签的参数可以是可变的\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// 将一个新元素插入到二叉搜索树中。\n"
"// 返回新的树\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // 修改构造器的字段\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // 在这里创建的 `node` 和 `node.left` 之间的循环\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // 树不为空，所以新的树就是原来的树\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1053
msgid "Newtype"
msgstr "Newtype"

#: ../../language/fundamentals.md:1055
msgid "MoonBit supports a special kind of enum called newtype:"
msgstr "MoonBit 支持一种特殊的枚举称为 newtype："

#: ../../language/fundamentals.md:1057
msgid ""
"// `UserId` is a fresh new type different from `Int`, \n"
"// and you can define new methods for `UserId`, etc.\n"
"// But at the same time, the internal representation of `UserId` \n"
"// is exactly the same as `Int`\n"
"type UserId Int\n"
"\n"
"type UserName String\n"
msgstr ""
"// `UserId` 是一个与 `Int` 不同的全新类型，\n"
"// 你可以为 `UserId` 定义新方法等。\n"
"// 但与此同时，`UserId` 的内部表示\n"
"// 与 `Int` 完全相同\n"
"type UserId Int\n"
"\n"
"type UserName String\n"

#: ../../language/fundamentals.md:1063
msgid ""
"Newtypes are similar to enums with only one constructor (with the same "
"name as the newtype itself). So, you can use the constructor to create "
"values of newtype, or use pattern matching to extract the underlying "
"representation of a newtype:"
msgstr ""
"Newtype 类似于只有一个构造函数的枚举（与 newtype 本身的名称相同）。因此，可以使用构造函数创建 newtype "
"的值，或使用模式匹配提取 newtype 的底层表示："

#: ../../language/fundamentals.md:1065
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserName = UserName(\"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserName(uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1073
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals.md:1077
msgid ""
"Besides pattern matching, you can also use `._` to extract the internal "
"representation of newtypes:"
msgstr "除了模式匹配，还可以使用 `._` 提取 newtype 的内部表示："

#: ../../language/fundamentals.md:1079
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let uid : Int = id._\n"
"  println(uid)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1087
msgid "1\n"
msgstr ""

#: ../../language/fundamentals.md:1091
msgid "Type alias"
msgstr "类型别名"

#: ../../language/fundamentals.md:1092
msgid "MoonBit supports type alias via the syntax `typealias Name = TargetType`:"
msgstr "MoonBit 支持使用语法 `typealias Name = TargetType` 定义类型别名："

#: ../../language/fundamentals.md:1094
msgid ""
"pub typealias Index = Int\n"
"\n"
"// type alias are private by default\n"
"typealias MapString[X] = Map[String, X]\n"
msgstr ""
"pub typealias Index = Int\n"
"\n"
"// 类型别名默认为私有\n"
"typealias MapString[X] = Map[String, X]\n"

#: ../../language/fundamentals.md:1100
msgid ""
"Unlike all other kinds of type declaration above, type alias does not "
"define a new type, it is merely a type macro that behaves exactly the "
"same as its definition. So for example one cannot define new methods or "
"implement traits for a type alias."
msgstr "与上面所有其他类型声明不同，类型别名不定义新类型，它只是一个行为与其定义完全相同的类型宏。因此，例如，不能为类型别名定义新方法或实现特征。"

#: ../../language/fundamentals.md:1105
msgid "Type alias can be used to perform incremental code refactor."
msgstr "类型别名可用于执行增量代码重构。"

#: ../../language/fundamentals.md:1107
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you "
"can leave a type alias `typealias T = @pkgB.T` in `@pkgA`, and "
"**incrementally** port uses of `@pkgA.T` to `@pkgB.T`. The type alias can"
" be removed after all uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr ""
"例如，如果要将类型 `T` 从 `@pkgA` 移动到 `@pkgB`，可以在 `@pkgA` 中留下一个类型别名 `typealias T = "
"@pkgB.T`，"

#: ../../language/fundamentals.md:1112
msgid "Local types"
msgstr "本地类型"

#: ../../language/fundamentals.md:1114
msgid ""
"Moonbit supports declaring structs/enums/newtypes at the top of a "
"toplevel function, which are only visible within the current toplevel "
"function. These local types can use the generic parameters of the "
"toplevel function but cannot introduce additional generic parameters "
"themselves. Local types can derive methods using derive, but no "
"additional methods can be defined manually. For  example:"
msgstr ""
"Moonbit "
"支持在顶层函数的顶部声明结构体/枚举/newtype，这些类型仅在当前顶层函数中可见。这些本地类型可以使用顶层函数的泛型参数，但不能引入额外的泛型参数。本地类型可以使用"
" derive 派生方法，但不能手动定义额外的方法。例如："

#: ../../language/fundamentals.md:1121
msgid ""
"fn toplevel[T: Show](x: T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a: (String, T)\n"
"  } derive(Show)\n"
"  type LocalNewtype T derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1127
msgid "Currently, local types do not support being declared as error types."
msgstr "目前，本地类型不支持声明为错误类型。"

#: ../../language/fundamentals.md:1129
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../language/fundamentals.md:1131
msgid ""
"Pattern matching allows us to match on specific pattern and bind data "
"from data structures."
msgstr "模式匹配允许我们匹配特定模式并从数据结构中绑定数据。"

#: ../../language/fundamentals.md:1133
msgid "Simple Patterns"
msgstr "简单模式"

#: ../../language/fundamentals.md:1135
msgid "We can pattern match expressions against"
msgstr "我们可以将表达式与以下内容进行模式匹配："

#: ../../language/fundamentals.md:1137
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr "字面量，例如布尔值、数字、字符、字符串等"

#: ../../language/fundamentals.md:1138
msgid "constants"
msgstr "常量"

#: ../../language/fundamentals.md:1139
msgid "structs"
msgstr "结构体"

#: ../../language/fundamentals.md:1140
msgid "enums"
msgstr "枚举"

#: ../../language/fundamentals.md:1141
msgid "arrays"
msgstr "数组"

#: ../../language/fundamentals.md:1142
msgid "maps"
msgstr "键值对"

#: ../../language/fundamentals.md:1143
msgid "JSONs"
msgstr "JSON"

#: ../../language/fundamentals.md:1145
msgid ""
"and so on. We can define identifiers to bind the matched values so that "
"they can be used later."
msgstr "等等。我们可以定义标识符来绑定匹配的值，以便稍后使用。"

#: ../../language/fundamentals.md:1147
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1154
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use "
"`..` to ignore remaining fields of struct or enum, or array (see [array "
"pattern](#array-pattern))."
msgstr ""
"我们可以使用 `_` 作为我们不关心的值的通配符，并使用 `..` 忽略结构体或枚举的剩余字段，或数组（参见 [数组模式](#array-"
"pattern)）。"

#: ../../language/fundamentals.md:1156
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~: String, payload~ : T)\n"
"}\n"
"\n"
"fn match_point[T](p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1163
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to "
"match several cases at once. A variable name can only be bound once in a "
"single pattern, and the same set of variables should be bound on both "
"sides of `|` patterns."
msgstr ""
"我们可以使用 `as` 为某些模式命名，可以使用 `|` 一次匹配多个情况。在单个模式中，变量名只能绑定一次，并且在 `|` "
"模式的两侧应绑定相同的变量集。"

#: ../../language/fundamentals.md:1165
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1172
msgid "Array Pattern"
msgstr "数组模式"

#: ../../language/fundamentals.md:1174
msgid ""
"For `Array`, `FixedArray` and `ArrayView`, MoonBit allows using array "
"pattern."
msgstr "对于 `Array`、`FixedArray` 和 `ArrayView`，MoonBit 允许使用数组模式。"

#: ../../language/fundamentals.md:1176
msgid "Array pattern have the following forms:"
msgstr "数组模式有以下形式："

#: ../../language/fundamentals.md:1178
msgid "`[]` : matching for an empty data structure"
msgstr "`[]`：匹配空数据结构"

#: ../../language/fundamentals.md:1179
msgid "`[pa, pb, pc]` : matching for known number of elements, 3 in this example"
msgstr "`[pa, pb, pc]`：匹配已知数量的元素，在此示例中为 3 个"

#: ../../language/fundamentals.md:1180
msgid ""
"`[pa, ..]` : matching for known number of elements, followed by unknown "
"number of elements"
msgstr "`[pa, ..]`：匹配已知数量的元素，后跟未知数量的元素"

#: ../../language/fundamentals.md:1181
msgid ""
"`[.., pa]` : matching for known number of elements, preceded by unknown "
"number of elements"
msgstr "`[.., pa]`：匹配已知数量的元素，前面是未知数量的元素"

#: ../../language/fundamentals.md:1183
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  let [a, b, ..] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  let [.., a, b] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1189
msgid "Range Pattern"
msgstr "范围模式"

#: ../../language/fundamentals.md:1190
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the"
" value falls in a specific range."
msgstr "对于内置整数类型和 `Char`，MoonBit 允许匹配值是否落在特定范围内。"

#: ../../language/fundamentals.md:1192
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the "
"upper bound is exclusive, and `..=` means inclusive upper bound. `a` and "
"`b` can be one of:"
msgstr ""
"范围模式的形式为 `a..<b` 或 `a..=b`，其中 `..<` 表示上限是排他的，`..=` 表示包含上限。`a` 和 `b` "
"可以是以下之一："

#: ../../language/fundamentals.md:1195
msgid "literal"
msgstr "字面量"

#: ../../language/fundamentals.md:1196
msgid "named constant declared with `const`"
msgstr "使用 `const` 声明的常量"

#: ../../language/fundamentals.md:1197
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr "`_`，表示此模式在此侧没有限制"

#: ../../language/fundamentals.md:1199
msgid "Here are some examples:"
msgstr "以下是一些示例："

#: ../../language/fundamentals.md:1201
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1208
msgid "Map Pattern"
msgstr "Map 模式"

#: ../../language/fundamentals.md:1210
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a "
"map pattern, the `key : value` syntax will match if `key` exists in the "
"map, and match the value of `key` with pattern `value`. The `key? : "
"value` syntax will match no matter `key` exists or not, and `value` will "
"be matched against `map[key]` (an optional)."
msgstr ""
"MoonBit 允许在类似 map 的数据结构上方便地进行匹配。在 map 模式内，`key : value` 语法将在 map 中存在 "
"`key` 时匹配，并将 `key` 的值与模式 `value` 匹配。`key? : value` 语法将无论 `key` "
"是否存在都匹配，`value` 将与 `map[key]`（一个可选项）匹配。"

#: ../../language/fundamentals.md:1214
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _ } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" "
"exists in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""
"match map {\n"
"  // 仅在 `map` 中存在 \"b\" 时匹配\n"
"  { \"b\": _ } => ...\n"
"  // 仅在 `map` 中不存在 \"b\" 且 \"a\" 存在于 `map` 时匹配。\n"
"  // 匹配时，将 `map` 中的 \"a\" 的值绑定到 `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // 编译器报告缺失的情况：{ \"b\"? : None, \"a\"? : None }\n"
"}\n"

#: ../../language/fundamentals.md:1221
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and"
" trait](./methods.md))."
msgstr ""
"要使用 map 模式匹配数据类型 `T`，`T` 必须具有某种类型 `K` 和 `V` 的方法 `op_get(Self, K) -> "
"Option[V]`（请参见 [方法和特征](./methods.md)）。"

#: ../../language/fundamentals.md:1222
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr "目前，map 模式的键部分必须是字面量或常量"

#: ../../language/fundamentals.md:1223
msgid "Map patterns are always open: unmatched keys are silently ignored"
msgstr "Map 模式始终是开放的：未匹配的键会被静默忽略"

#: ../../language/fundamentals.md:1224
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched"
" at most once"
msgstr "Map 模式将编译为高效的代码：每个键最多只会被获取一次"

#: ../../language/fundamentals.md:1226
msgid "Json Pattern"
msgstr "Json 模式"

#: ../../language/fundamentals.md:1228
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr "当匹配的值具有类型 `Json` 时，可以直接使用字面量模式，以及构造函数："

#: ../../language/fundamentals.md:1230
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports } => ...\n"
"  { \"version\": Number(i), \"import\": Array(imports)} => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1237
msgid "Generics"
msgstr "泛型"

#: ../../language/fundamentals.md:1239
msgid ""
"Generics are supported in top-level function and data type definitions. "
"Type parameters can be introduced within square brackets. We can rewrite "
"the aforementioned data type `List` to add a type parameter `T` to obtain"
" a generic version of lists. We can then define generic functions over "
"lists like `map` and `reduce`."
msgstr ""
"泛型在顶层函数和数据类型定义中受支持。可以在方括号内引入类型参数。我们可以重写上述数据类型 `List`，添加类型参数 `T` "
"以获得列表的通用版本。然后，我们可以定义列表上的通用函数，如 `map` 和 `reduce`。"

#: ../../language/fundamentals.md:1241
msgid ""
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1245
msgid "Special Syntax"
msgstr "特殊语法"

#: ../../language/fundamentals.md:1247
msgid "Pipe operator"
msgstr "管道运算符"

#: ../../language/fundamentals.md:1249
msgid ""
"MoonBit provides a convenient pipe operator `|>`, which can be used to "
"chain regular function calls:"
msgstr "moonbit提供了一个方便的管道运算符`|>`，可以用于链接常规函数调用："

#: ../../language/fundamentals.md:1251
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> push(5) // <=> push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals.md:1258
msgid "Cascade Operator"
msgstr "级联运算符"

#: ../../language/fundamentals.md:1260
msgid ""
"The cascade operator `..` is used to perform a series of mutable "
"operations on the same value consecutively. The syntax is as follows:"
msgstr "级联运算符`..`用于连续对同一值执行一系列可变操作。 语法如下："

#: ../../language/fundamentals.md:1263
msgid "x..f()\n"
msgstr ""

#: ../../language/fundamentals.md:1270
msgid "`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`."
msgstr "`x..f()..g()` 等价于 `{x.f(); x.g(); x}`。"

#: ../../language/fundamentals.md:1272
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has "
"methods like `write_string`, `write_char`, `write_object`, etc., we often"
" need to perform a series of operations on the same `StringBuilder` "
"value:"
msgstr "考虑以下情况：对于具有诸如`write_string`，`write_char`，`write_object`等方法的`StringBuilder`类型，我们经常需要对同一`StringBuilder`值执行一系列操作："

#: ../../language/fundamentals.md:1276
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1283
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed "
"to return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used"
" for consecutive operations without the need to modify the return type of"
" the methods."
msgstr ""
"为了避免重复输入`builder`，其方法通常设计为返回`self`本身，允许使用`.`运算符链接操作。 "
"为了区分不可变和可变操作，在MoonBit中，对于所有返回`Unit`的方法，可以使用级联运算符进行连续操作，而无需修改方法的返回类型。"

#: ../../language/fundamentals.md:1289
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1296
msgid "TODO syntax"
msgstr "TODO 语法"

#: ../../language/fundamentals.md:1298
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of"
" code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr "`todo`语法(`...`)是一种特殊构造，用于标记尚未实现或用于未来功能的占位符代码段。 例如："

#: ../../language/fundamentals.md:1300
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/index.md:1
msgid "MoonBit Language"
msgstr "MoonBit（月兔）编程语言"

#: ../../language/index.md:3
msgid ""
"MoonBit is an end-to-end programming language toolchain for cloud and "
"edge computing using WebAssembly. The IDE environment is available at "
"[https://try.moonbitlang.com](https://try.moonbitlang.com) without any "
"installation; it does not rely on any server either."
msgstr ""
"MoonBit是一个用于云和边缘计算的 WebAssembly 端到端编程语言工具链。无需安装即可在 "
"[https://try.moonbitlang.cn](https://try.moonbitlang.cn) 上使用 IDE "
"环境；它也不依赖任何服务器。"

#: ../../language/index.md:5
msgid "**Status and aimed timeline**"
msgstr "**状态**"

#: ../../language/index.md:7
msgid "MoonBit is currently in beta-preview. We expect to reach 1.0 in 2025."
msgstr "MoonBit 目前处于 beta-preview 阶段。我们预计在 2025 年达到 1.0 版本。"

#: ../../language/index.md:9
msgid ""
"When MoonBit reaches beta, it means any backwards-incompatible changes "
"will be seriously evaluated and MoonBit _can_ be used in production(very "
"rare compiler bugs). MoonBit is developed by a talented full time team "
"who had extensive experience in building language toolchains, so we will "
"grow much faster than the typical language ecosystem, you won't wait long"
" to use MoonBit in your production."
msgstr ""
"当 MoonBit 达到 beta 阶段后，任何不兼容的更改将受到严格评估，MoonBit "
"将可以用于生产（只有非常罕见的编译器错误）。MoonBit "
"由一支才华横溢的全职团队开发，他们在构建语言工具链方面拥有丰富的经验，因此我们将比典型的语言生态系统发展得更快，您不必等太久就可以在生产中使用 "
"MoonBit。"

#: ../../language/index.md:11
msgid "**Main advantages**"
msgstr "**主要优势**"

#: ../../language/index.md:13
msgid "Generate significantly smaller WASM output than any existing solutions."
msgstr "生成比现有解决方案明显更小的 Wasm 文件。"

#: ../../language/index.md:14
msgid "Much faster runtime performance."
msgstr "更高的运行时性能。"

#: ../../language/index.md:15
msgid "State of the art compile-time performance."
msgstr "先进的编译时性能。"

#: ../../language/index.md:16
msgid "Simple but practical, data-oriented language design."
msgstr "简单且实用的数据导向语言设计。"

#: ../../language/index.md:18
msgid "[Download this section in Markdown](path:/download/language/summary.md)"
msgstr "[下载本章节的 Markdown 版本](path:/download/language/summary.md)"

#: ../../language/introduction.md:1
msgid "Introduction"
msgstr "概述"

#: ../../language/introduction.md:3
msgid "A MoonBit program consists of top-level definitions including:"
msgstr "一个 MoonBit 程序由顶层定义组成，包括："

#: ../../language/introduction.md:5
msgid "type definitions"
msgstr "类型定义"

#: ../../language/introduction.md:6
msgid "function definitions"
msgstr "函数定义"

#: ../../language/introduction.md:7
msgid "constant definitions and variable bindings"
msgstr "常数定义和变量绑定"

#: ../../language/introduction.md:8
msgid "`init` functions, `main` function and/or `test` blocks."
msgstr "`init` 函数，`main` 函数和/或 `test` 块。"

#: ../../language/introduction.md:10
msgid "Expressions and Statements"
msgstr "表达式和语句"

#: ../../language/introduction.md:12
msgid ""
"MoonBit distinguishes between statements and expressions. In a function "
"body, only the last clause should be an expression, which serves as a "
"return value. For example:"
msgstr "MoonBit 区分语句和表达式。在函数体中，只有最后一个子句应该是一个表达式，它作为返回值。例如："

#: ../../language/introduction.md:14
msgid ""
"fn foo() -> Int {\n"
"  let x = 1\n"
"  x + 1\n"
"}\n"
"\n"
"fn bar() -> Int {\n"
"  let x = 1\n"
"  //! x + 1\n"
"  x + 2\n"
"}"
msgstr ""

#: ../../language/introduction.md:28
msgid "Expressions include:"
msgstr "表达式包括："

#: ../../language/introduction.md:30
msgid ""
"Value literals (e.g. Boolean values, numbers, characters, strings, "
"arrays, tuples, structs)"
msgstr "值字面量（例如布尔值、数字、字符、字符串、数组、元组、结构体）"

#: ../../language/introduction.md:31
msgid "Arithmetical, logical, or comparison operations"
msgstr "算术、逻辑或比较操作"

#: ../../language/introduction.md:32
msgid ""
"Accesses to array elements (e.g. `a[0]`), struct fields (e.g `r.x`), "
"tuple components (e.g. `t.0`), etc."
msgstr "访问数组元素（例如 `a[0]`），结构体字段（例如 `r.x`），元组组件（例如 `t.0`）等。"

#: ../../language/introduction.md:33
msgid "Variables and (capitalized) enum constructors"
msgstr "变量和枚举构造器"

#: ../../language/introduction.md:34
msgid "Anonymous local function definitions"
msgstr "匿名本地函数定义"

#: ../../language/introduction.md:35
msgid "`match`, `if`, `loop` expressions, etc."
msgstr "`match`，`if`，`loop` 表达式等。"

#: ../../language/introduction.md:37
msgid "Statements include:"
msgstr "语句包括："

#: ../../language/introduction.md:39
msgid "Named local function definitions"
msgstr "命名本地函数定义"

#: ../../language/introduction.md:40
msgid "Local variable bindings"
msgstr "本地变量绑定"

#: ../../language/introduction.md:41
msgid "Assignments"
msgstr "赋值"

#: ../../language/introduction.md:42
msgid "`return` statements"
msgstr "`return` 语句"

#: ../../language/introduction.md:43
msgid "Any expression whose return type is `Unit`, (e.g. `ignore`)"
msgstr "任何返回类型为 `Unit` 的表达式（例如 `ignore`）"

#: ../../language/introduction.md:45
msgid ""
"A code block can contain multiple statements and one expression, and the "
"value of the expression is the value of the code block."
msgstr "代码块可以包含多个语句和一个表达式，表达式的值是代码块的值。"

#: ../../language/introduction.md:47
msgid "Variable Binding"
msgstr "变量绑定"

#: ../../language/introduction.md:49
msgid ""
"A variable can be declared as mutable or immutable using `let mut` or "
"`let`, respectively. A mutable variable can be reassigned to a new value,"
" while an immutable one cannot."
msgstr "变量可以使用 `let mut` 或 `let` 声明为可变或不可变。可变变量可以重新赋值为新值，而不可变变量则不能。"

#: ../../language/introduction.md:51
msgid "A constant can only be declared at top level and cannot be changed."
msgstr "常量只能在顶层声明，不能更改。"

#: ../../language/introduction.md:53
msgid ""
"let zero = 0\n"
"\n"
"const ZERO = 0\n"
"\n"
"fn main {\n"
"  //! const ZERO = 0 \n"
"  let mut i = 10\n"
"  i = 20\n"
"  println(i + zero + ZERO)\n"
"}"
msgstr ""

#: ../../language/introduction.md:68
msgid "A top level variable binding"
msgstr "顶层变量绑定"

#: ../../language/introduction.md:69
msgid ""
"requires **explicit** type annotation (unless defined using literals such"
" as string, byte or numbers)"
msgstr "需要 **显式** 类型注释（除非使用字符串、字节或数字等字面量定义）"

#: ../../language/introduction.md:70
msgid "can't be mutable (use `Ref` instead)"
msgstr "不能是可变的（使用 `Ref` 代替）"

#: ../../language/introduction.md:74
msgid "Naming conventions"
msgstr "命名约定"

#: ../../language/introduction.md:76
msgid ""
"Variables, functions should start with lowercase letters `a-z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with snake_case."
msgstr ""
"变量、函数应以小写字母 `a-z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 snake_case"
" 命名。"

#: ../../language/introduction.md:79
msgid ""
"Constants, types should start with uppercase letters `A-Z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with PascalCase or SCREAMING_SNAKE_CASE."
msgstr ""
"常量、类型应以大写字母 `A-Z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 PascalCase"
" 或 SCREAMING_SNAKE_CASE 命名。"

#: ../../language/introduction.md:82
msgid "Program entrance"
msgstr "程序入口"

#: ../../language/introduction.md:84
msgid "`init` and `main`"
msgstr "`init` 和 `main`"

#: ../../language/introduction.md:85
msgid ""
"There is a specialized function called `init` function. The `init` "
"function is special:"
msgstr "有一个专门的函数称为 `init` 函数。`init` 函数是特殊的："

#: ../../language/introduction.md:87
msgid "It has no parameter list nor return type."
msgstr "它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:88
msgid "There can be multiple `init` functions in the same package."
msgstr "同一个包中可以有多个 `init` 函数。"

#: ../../language/introduction.md:89
msgid ""
"An `init` function can't be explicitly called or referred to by other "
"functions.  Instead, all `init` functions will be implicitly called when "
"initializing a package. Therefore, `init` functions should only consist "
"of statements."
msgstr "`init` 函数不能被显式调用或被其他函数引用。相反，所有 `init` 函数将在初始化包时隐式调用。因此，`init` 函数应该只包含语句。"

#: ../../language/introduction.md:92
msgid ""
"fn init {\n"
"  let x = 1\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:100
msgid ""
"There is another specialized function called `main` function. The `main` "
"function is the main entrance of the program, and it will be executed "
"after the initialization stage."
msgstr "还有另一个专门的函数称为 `main` 函数。`main` 函数是程序的主入口，它将在初始化阶段之后执行。"

#: ../../language/introduction.md:102
msgid "Same as the `init` function, it has no parameter list nor return type."
msgstr "与 `init` 函数相同，它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:104
msgid ""
"fn main {\n"
"  let x = 2\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:112
msgid "The previous two code snippets will print the following at runtime:"
msgstr "前两个代码片段将在运行时打印以下内容："

#: ../../language/introduction.md:114
msgid ""
"1\n"
"2\n"
msgstr ""

#: ../../language/introduction.md:119
msgid ""
"Only packages that are `main` packages can define such `main` function. "
"Check out [build system tutorial](/toolchain/moon/tutorial) for detail."
msgstr "只有 `main` 包的包才能定义这样的 `main` 函数。查看[构建系统教程](/toolchain/moon/tutorial)了解详情。"

#: ../../language/introduction.md:121
msgid "moon.pkg.json"
msgstr ""

#: ../../language/introduction.md:121
msgid ""
"{\n"
"  \"is-main\": true\n"
"}"
msgstr ""

#: ../../language/introduction.md:126
msgid "`test`"
msgstr ""

#: ../../language/introduction.md:128
msgid ""
"There's also a top-level structure called `test` block. A `test` block "
"defines inline tests, such as:"
msgstr "还有一个称为 `test` 块的顶级结构。`test` 块定义内联测试，例如："

#: ../../language/introduction.md:130 ../../language/tests.md:11
msgid ""
"test \"test_name\" {\n"
"  assert_eq!(1 + 1, 2)\n"
"  assert_eq!(2 + 2, 4)\n"
"  inspect!([1, 2, 3], content=\"[1, 2, 3]\")\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:136
msgid ""
"The following contents will use `test` block and `main` function to "
"demonstrate the execution result, and we assume that all the `test` "
"blocks pass unless stated otherwise."
msgstr "以下内容将使用 `test` 块和 `main` 函数来演示执行结果。我们假设所有 `test` 块都通过测试，除非另有说明。"

#: ../../language/methods.md:1
msgid "Method and Trait"
msgstr "方法和特征"

#: ../../language/methods.md:3
msgid "Method system"
msgstr "方法系统"

#: ../../language/methods.md:5
msgid ""
"MoonBit supports methods in a different way from traditional object-"
"oriented languages. A method in MoonBit is just a toplevel function "
"associated with a type constructor. Methods can be defined using the "
"syntax `fn TypeName::method_name(...) -> ...`:"
msgstr ""
"MoonBit 支持方法的方式与传统的面向对象语言不同。MoonBit 中的方法只是与类型构造器关联的顶级函数。可以使用语法 `fn "
"TypeName::method_name(...) -> ...` 定义方法："

#: ../../language/methods.md:7
msgid ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn List::concat[X](xs : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:13
msgid ""
"As a convenient shorthand, when the first parameter of a function is "
"named `self`, MoonBit automatically defines the function as a method of "
"the type of `self`:"
msgstr "一个简写是，当函数的第一个参数命名为 `self` 时，MoonBit 会自动将该函数定义为 `self` 类型的方法："

#: ../../language/methods.md:15
msgid ""
"fn List::map[X, Y](xs : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:21
msgid "is equivalent to:"
msgstr "等价于"

#: ../../language/methods.md:23
msgid ""
"fn map[X, Y](self : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:29
msgid ""
"Methods are just regular functions owned by a type constructor. So when "
"there is no ambiguity, methods can be called using regular function call "
"syntax directly:"
msgstr "方法只是由类型构造器拥有的常规函数。因此，当没有歧义时，可以直接使用常规函数调用语法调用方法："

#: ../../language/methods.md:31
msgid ""
"let xs : List[List[_]] = { ... }\n"
"let ys = concat(xs)\n"
msgstr ""

#: ../../language/methods.md:38
msgid ""
"Unlike regular functions, methods support overloading: different types "
"can define methods of the same name. If there are multiple methods of the"
" same name (but for different types) in scope, one can still call them by"
" explicitly adding a `TypeName::` prefix:"
msgstr ""
"与常规函数不同，方法支持重载：不同类型可以定义相同名称的方法。如果作用域中有多个相同名称的方法（但是针对不同类型），仍然可以通过显式添加 "
"`TypeName::` 前缀来调用它们："

#: ../../language/methods.md:40
msgid ""
"struct T1 {\n"
"  x1 : Int\n"
"}\n"
"\n"
"fn T1::default() -> T1 {\n"
"  { x1: 0 }\n"
"}\n"
"\n"
"struct T2 {\n"
"  x2 : Int\n"
"}\n"
"\n"
"fn T2::default() -> T2 {\n"
"  { x2: 0 }\n"
"}\n"
"\n"
"test {\n"
"  // default() : T1::default() ? T2::default()?\n"
"  let t1 = T1::default()\n"
"  let t2 = T2::default()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:47
msgid ""
"When the first parameter of a method is also the type it belongs to, "
"methods can be called using dot syntax `x.method(...)`. MoonBit "
"automatically finds the correct method based on the type of `x`, there is"
" no need to write the type name and even the package name of the method:"
msgstr ""
"当方法的第一个参数也是它所属的类型时，可以使用点语法 `x.method(...)` 调用方法。MoonBit 根据 `x` "
"的类型自动找到正确的方法，无需编写方法的类型名称甚至包名称："

#: ../../language/methods.md:49
msgid ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn List::concat[X](xs : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:55
msgid "using package with alias list"
msgstr "以别名 list 使用包"

#: ../../language/methods.md:55
msgid ""
"fn f() -> Unit {\n"
"  let xs : @list.List[@list.List[Unit]] = Nil\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:63
msgid ""
"The highlighted line is only possible when there is no ambiguity in "
"`@list`."
msgstr "只有在 `@list` 中没有歧义时，才能像高亮显示的行那样书写。"

#: ../../language/methods.md:65
msgid "Operator Overloading"
msgstr "运算符重载"

#: ../../language/methods.md:67
msgid ""
"MoonBit supports operator overloading of builtin operators via methods. "
"The method name corresponding to a operator `<op>` is `op_<op>`. For "
"example:"
msgstr "MoonBit 支持通过方法对内置运算符进行运算符重载。与运算符 `<op>` 对应的方法名是 `op_<op>`。例如："

#: ../../language/methods.md:69
msgid ""
"struct T {\n"
"  x : Int\n"
"}\n"
"\n"
"fn op_add(self : T, other : T) -> T {\n"
"  { x: self.x + other.x }\n"
"}\n"
"\n"
"test {\n"
"  let a = { x: 0 }\n"
"  let b = { x: 2 }\n"
"  assert_eq!((a + b).x, 2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:75
msgid "Another example about `op_get` and `op_set`:"
msgstr "关于 `op_get` 和 `op_set` 的另一个例子："

#: ../../language/methods.md:77
msgid ""
"struct Coord {\n"
"  mut x : Int\n"
"  mut y : Int\n"
"} derive(Show)\n"
"\n"
"fn op_get(self : Coord, key : String) -> Int {\n"
"  match key {\n"
"    \"x\" => self.x\n"
"    \"y\" => self.y\n"
"  }\n"
"}\n"
"\n"
"fn op_set(self : Coord, key : String, val : Int) -> Unit {\n"
"  match key {\n"
"    \"x\" => self.x = val\n"
"    \"y\" => self.y = val\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/methods.md:83
msgid ""
"fn main {\n"
"  let c = { x: 1, y: 2 }\n"
"  println(c)\n"
"  println(c[\"y\"])\n"
"  c[\"x\"] = 23\n"
"  println(c)\n"
"  println(c[\"x\"])\n"
"}\n"
msgstr ""

#: ../../language/methods.md:91
msgid ""
"{x: 1, y: 2}\n"
"2\n"
"{x: 23, y: 2}\n"
"23\n"
msgstr ""

#: ../../language/methods.md:95
msgid "Currently, the following operators can be overloaded:"
msgstr "目前，可以重载以下运算符："

#: ../../language/methods.md:91
msgid "Operator Name"
msgstr "运算符名称"

#: ../../language/methods.md:91
msgid "Method Name"
msgstr "方法名称"

#: ../../language/methods.md:91
msgid "`+`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_add`"
msgstr ""

#: ../../language/methods.md:91
msgid "`-`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_sub`"
msgstr ""

#: ../../language/methods.md:91
msgid "`*`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_mul`"
msgstr ""

#: ../../language/methods.md:91
msgid "`/`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_div`"
msgstr ""

#: ../../language/methods.md:91
msgid "`%`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_mod`"
msgstr ""

#: ../../language/methods.md:91
msgid "`=`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_equal`"
msgstr ""

#: ../../language/methods.md:91
msgid "`<<`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_shl`"
msgstr ""

#: ../../language/methods.md:91
msgid "`>>`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_shr`"
msgstr ""

#: ../../language/methods.md:91
msgid "`-` (unary)"
msgstr "`-`（一元）"

#: ../../language/methods.md:91
msgid "`op_neg`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_]` (get item)"
msgstr "`_[_]`（获取项）"

#: ../../language/methods.md:91
msgid "`op_get`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_] = _` (set item)"
msgstr "`_[_] = _`（设置项）"

#: ../../language/methods.md:91
msgid "`op_set`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_:_]` (view)"
msgstr "`_[_:_]`（视图）"

#: ../../language/methods.md:91
msgid "`op_as_view`"
msgstr ""

#: ../../language/methods.md:91
msgid "`&`"
msgstr ""

#: ../../language/methods.md:91
msgid "`land`"
msgstr ""

#: ../../language/methods.md:91
msgid "`|`"
msgstr ""

#: ../../language/methods.md:91
msgid "`lor`"
msgstr ""

#: ../../language/methods.md:91
msgid "`^`"
msgstr ""

#: ../../language/methods.md:91
msgid "`lxor`"
msgstr ""

#: ../../language/methods.md:118
msgid ""
"By implementing `op_as_view` method, you can create a view for a user-"
"defined type. Here is an example:"
msgstr "通过实现 `op_as_view` 方法，可以为用户定义的类型创建视图。以下是一个例子："

#: ../../language/methods.md:120
msgid ""
"type DataView String\n"
"\n"
"struct Data {}\n"
"\n"
"fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> "
"DataView {\n"
"  \"[\\{start}, \\{end.or(100)})\"\n"
"}\n"
"\n"
"test {\n"
"  let data = Data::{  }\n"
"  inspect!(data[:]._, content=\"[0, 100)\")\n"
"  inspect!(data[2:]._, content=\"[2, 100)\")\n"
"  inspect!(data[:5]._, content=\"[0, 5)\")\n"
"  inspect!(data[2:5]._, content=\"[2, 5)\")\n"
"}\n"
msgstr ""

#: ../../language/methods.md:126
msgid "Trait system"
msgstr "Trait（特征）系统"

#: ../../language/methods.md:128
msgid ""
"MoonBit features a structural trait system for overloading/ad-hoc "
"polymorphism. Traits declare a list of operations, which must be supplied"
" when a type wants to implement the trait. Traits can be declared as "
"follows:"
msgstr "MoonBit 具有用于重载/特殊多态的结构特征系统。特征声明一系列操作，当类型想要实现特征时，必须提供这些操作。特征可以如下声明："

#: ../../language/methods.md:130
msgid ""
"trait I {\n"
"  method_(Int) -> Int\n"
"  method_with_label(Int, label~: Int) -> Int\n"
"  //! method_with_label(Int, label?: Int) -> Int\n"
"}\n"
msgstr ""

#: ../../language/methods.md:136
msgid ""
"In the body of a trait definition, a special type `Self` is used to refer"
" to the type that implements the trait."
msgstr "在特征定义的主体中，使用特殊类型 `Self` 来引用实现特征的类型。"

#: ../../language/methods.md:138
msgid "Extending traits"
msgstr "扩展特征"

#: ../../language/methods.md:140
msgid "A trait can depend on other traits, for example:"
msgstr "特征（子特征）可以依赖于其他特征（超特征），例如："

#: ../../language/methods.md:142
msgid ""
"trait Position {\n"
"  pos(Self) -> (Int, Int)\n"
"}\n"
"trait Draw {\n"
"  draw(Self) -> Unit\n"
"}\n"
"\n"
"trait Object : Position + Draw {}\n"
msgstr ""

#: ../../language/methods.md:148
msgid ""
"To implement the sub trait, one will have to implement the super traits,"
"  and the methods defined in the sub trait."
msgstr "要实现子特征，必须实现子特征和所有超特征中定义的方法。"

#: ../../language/methods.md:151
msgid "Implementing traits"
msgstr "实现特征"

#: ../../language/methods.md:153
msgid ""
"To implement a trait, a type must provide all the methods required by the"
" trait."
msgstr "要实现特征，类型必须提供特征所需的所有方法。"

#: ../../language/methods.md:155
msgid ""
"This allows types to implement a trait implicitly, hence allowing "
"different packages to work together without seeing or depending on each "
"other. For example, the following trait is automatically implemented for "
"builtin number types such as `Int` and `Double`:"
msgstr ""
"这使得类型可以隐式满足特征，从而允许不同的包在不看到或依赖于彼此的情况下运行。例如，内置数字类型（如 `Int` 和 "
"`Double`）自动满足了以下的特征："

#: ../../language/methods.md:158
msgid ""
"trait Number {\n"
"  op_add(Self, Self) -> Self\n"
"  op_mul(Self, Self) -> Self\n"
"}\n"
msgstr ""

#: ../../language/methods.md:164
msgid ""
"**Explicit implementation** for trait methods can be provided via the "
"syntax `impl Trait for Type with method_name(...) { ... }`, for example:"
msgstr ""
"**显式实现**特征方法可以通过语法 `impl Trait for Type with method_name(...) { ... }` "
"提供，例如："

#: ../../language/methods.md:166
msgid ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// trait implementation with type parameters.\n"
"// `[X : Show]` means the type parameter `X` must implement `Show`,\n"
"// this will be covered later.\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"
msgstr ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// 使用类型参数实现特征。\n"
"// `[X : Show]` 意味着类型参数 `X` 必须实现 `Show`，\n"
"// 我们将稍后介绍。\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"

#: ../../language/methods.md:172
msgid ""
"Type annotation can be omitted for trait `impl`: MoonBit will "
"automatically infer the type based on the signature of `Trait::method` "
"and the self type."
msgstr "`impl` 实现的类型注释可以省略：MoonBit 将根据 `Trait::method` 的签名和 self 类型自动推断类型。"

#: ../../language/methods.md:174
msgid ""
"The author of the trait can also define **default implementations** for "
"some methods in the trait, for example:"
msgstr "特征的作者还可以为特征中的某些方法定义**默认实现**，例如："

#: ../../language/methods.md:176
msgid ""
"trait J {\n"
"  f(Self) -> Unit\n"
"  f_twice(Self) -> Unit\n"
"}\n"
"\n"
"impl J with f_twice(self) {\n"
"  self.f()\n"
"  self.f()\n"
"}\n"
msgstr ""

#: ../../language/methods.md:182
msgid ""
"Implementers of trait `I` don't have to provide an implementation for "
"`f_twice`: to implement `I`, only `f` is necessary. They can always "
"override the default implementation with an explicit `impl I for Type "
"with f_twice`, if desired, though."
msgstr ""
" `I` 的类型实现特征时不必为 `f_twice` 提供实现：要实现 `I`，只有 `f` 是必要的。如果需要，他们总是可以显式地用 `impl"
" I for Type with f_twice` 覆盖默认实现。"

#: ../../language/methods.md:185
msgid ""
"If an explicit `impl` or default implementation is not found, trait "
"method resolution falls back to regular methods."
msgstr "如果找不到显式的 `impl` 或默认实现，特征方法解析将回退到常规方法。"

#: ../../language/methods.md:187
msgid "Using traits"
msgstr "使用特征"

#: ../../language/methods.md:189
msgid ""
"When declaring a generic function, the type parameters can be annotated "
"with the traits they should implement, allowing the definition of "
"constrained generic functions. For example:"
msgstr "在声明泛型函数时，可以使用特征注释类型参数，来定义受约束的泛型函数。例如："

#: ../../language/methods.md:191
msgid ""
"fn square[N : Number](x : N) -> N {\n"
"  x * x // <=> x.op_mul(x)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:197
msgid ""
"Without the `Number` requirement, the expression `x * x` in `square` will"
" result in a method/operator not found error. Now, the function `square` "
"can be called with any type that implements `Number`, for example:"
msgstr ""
"如果没有 `Number` 要求，`square` 中的表达式 `x * x` 将产生方法/运算符未找到的错误。现在，函数 `square` "
"可以使用任何实现 `Number` 的类型调用，例如："

#: ../../language/methods.md:199
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Show)\n"
"\n"
"impl Number for Point with op_add(self, other) {\n"
"  { x: self.x + other.x, y: self.y + other.y }\n"
"}\n"
"\n"
"impl Number for Point with op_mul(self, other) {\n"
"  { x: self.x * other.x, y: self.y * other.y }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(square(2), 4)\n"
"  assert_eq!(square(1.5), 2.25)\n"
"  assert_eq!(square(Point::{ x: 2, y: 3 }), { x: 4, y: 9 })\n"
"}\n"
msgstr ""

#: ../../language/methods.md:205
msgid "Invoke trait methods directly"
msgstr "直接调用特征方法"

#: ../../language/methods.md:207
msgid ""
"Methods of a trait can be called directly via `Trait::method`. MoonBit "
"will infer the type of `Self` and check if `Self` indeed implements "
"`Trait`, for example:"
msgstr ""
"可以通过 `Trait::method` 直接调用特征的方法。MoonBit 将推断 `Self` 的类型，并检查 `Self` 是否确实实现了 "
"`Trait`，例如："

#: ../../language/methods.md:209
msgid ""
"test {\n"
"  assert_eq!(Show::to_string(42), \"42\")\n"
"  assert_eq!(Compare::compare(1.0, 2.5), -1)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:215
msgid ""
"Trait implementations can also be invoked via dot syntax, with the "
"following restrictions:"
msgstr "特征实现也可以通过点语法调用，但有以下限制："

#: ../../language/methods.md:217
msgid ""
"if a regular method is present, the regular method is always favored when"
" using dot syntax"
msgstr "如果存在常规方法，使用点语法时总是优先选择常规方法"

#: ../../language/methods.md:218
msgid ""
"only trait implementations that are located in the package of the self "
"type can be invoked via dot syntax"
msgstr "只有位于 self 类型的包中的特征实现才能通过点语法调用"

#: ../../language/methods.md:219
msgid ""
"if there are multiple trait methods (from different traits) with the same"
" name available, an ambiguity error is reported"
msgstr "如果有多个具有相同名称的特征方法（来自不同的特征）可用，将报告歧义错误"

#: ../../language/methods.md:220
msgid ""
"if neither of the above two rules apply, trait `impl`s in current package"
" will also be searched for dot syntax. This allows extending a foreign "
"type locally."
msgstr "如果上述两条规则都不适用，还将在当前包中搜索特征 `impl` 以进行点语法。这允许在本地扩展外部类型。"

#: ../../language/methods.md:222
msgid ""
"these `impl`s can only be called via dot syntax locally, even if they are"
" public."
msgstr "这些 `impl` 只能在本地通过点语法调用，即使它们是公共的。"

#: ../../language/methods.md:224
msgid ""
"The above rules ensures that MoonBit's dot syntax enjoys good property "
"while being flexible. For example, adding a new dependency never break "
"existing code with dot syntax due to ambiguity. These rules also make "
"name resolution of MoonBit extremely simple: the method called via dot "
"syntax must always come from current package or the package of the type!"
msgstr ""
"上述规则确保了 MoonBit 的点语法具有良好的特性，同时也具有灵活性。例如，由于歧义，添加新依赖关系永远不会破坏现有的点语法代码。这些规则还使"
" MoonBit 的名称解析非常简单：通过点语法调用的方法必须始终来自当前包或类型的包！"

#: ../../language/methods.md:229
msgid "Here's an example of calling trait `impl` with dot syntax:"
msgstr "以下是使用点语法调用特征 `impl` 的示例："

#: ../../language/methods.md:231
msgid ""
"struct MyCustomType {}\n"
"\n"
"impl Show for MyCustomType with output(self, logger) { ... }\n"
"\n"
"fn f() -> Unit {\n"
"  let x = MyCustomType::{  }\n"
"  let _ = x.to_string()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:237
msgid "Trait objects"
msgstr "特征对象"

#: ../../language/methods.md:239
msgid ""
"MoonBit supports runtime polymorphism via trait objects. If `t` is of "
"type `T`, which implements trait `I`, one can pack the methods of `T` "
"that implements `I`, together with `t`, into a runtime object via `t as "
"&I`. Trait object erases the concrete type of a value, so objects created"
" from different concrete types can be put in the same data structure and "
"handled uniformly:"
msgstr ""
"MoonBit 支持通过特征对象实现运行时多态。如果 `t` 是类型 `T`，它实现了特征 `I`，可以通过 `t as &I` 将实现 `I` "
"的 `T` 的方法与 `t` 一起打包到运行时对象中。特征对象擦除了值的具体类型，因此可以将从不同具体类型创建的对象放入相同的数据结构并统一处理："

#: ../../language/methods.md:246
msgid ""
"trait Animal {\n"
"  speak(Self) -> String\n"
"}\n"
"\n"
"type Duck String\n"
"\n"
"fn Duck::make(name : String) -> Duck {\n"
"  Duck(name)\n"
"}\n"
"\n"
"fn speak(self : Duck) -> String {\n"
"  \"\\{self._}: quack!\"\n"
"}\n"
"\n"
"type Fox String\n"
"\n"
"fn Fox::make(name : String) -> Fox {\n"
"  Fox(name)\n"
"}\n"
"\n"
"fn Fox::speak(_self : Fox) -> String {\n"
"  \"What does the fox say?\"\n"
"}\n"
"\n"
"test {\n"
"  let duck1 = Duck::make(\"duck1\")\n"
"  let duck2 = Duck::make(\"duck2\")\n"
"  let fox1 = Fox::make(\"fox1\")\n"
"  let animals : Array[&Animal] = [\n"
"    duck1 as &Animal,\n"
"    duck2 as &Animal,\n"
"    fox1 as &Animal,\n"
"  ]\n"
"  inspect!(\n"
"    animals.map(fn(animal) { animal.speak() }),\n"
"    content=\n"
"      #|[\"duck1: quack!\", \"duck2: quack!\", \"What does the fox "
"say?\"]\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/methods.md:252
msgid ""
"Not all traits can be used to create objects. \"object-safe\" traits' "
"methods must satisfy the following conditions:"
msgstr "并非所有特征都可以用于创建对象。“对象安全” 特征的方法必须满足以下条件："

#: ../../language/methods.md:255
msgid "`Self` must be the first parameter of a method"
msgstr "`Self` 必须是方法的第一个参数"

#: ../../language/methods.md:256
msgid ""
"There must be only one occurrence of `Self` in the type of the method "
"(i.e. the first parameter)"
msgstr "方法的类型中只能出现一个 `Self` （即第一个参数）"

#: ../../language/methods.md:258
msgid ""
"Users can define new methods for trait objects, just like defining new "
"methods for structs and enums:"
msgstr "用户可以为特征对象定义新方法，就像为结构体和枚举定义新方法一样："

#: ../../language/methods.md:260
msgid ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// use the new method to simplify code\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"
msgstr ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// 使用新的方法来简化代码\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"

#: ../../language/methods.md:266
msgid "Builtin traits"
msgstr "内建特征"

#: ../../language/methods.md:268
msgid "MoonBit provides the following useful builtin traits:"
msgstr "MoonBit 提供了以下有用的内建特征："

#: ../../language/methods.md:272
msgid ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` for equal, `-1` for smaller, `1` for greater\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // to be implemented\n"
"  hash(Self) -> Int // has default implementation\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // to be implemented\n"
"  to_string(Self) -> String // has default implementation\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"
msgstr ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` 代表相等，`-1` 代表小于，`1` 代表大于\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // 待实现\n"
"  hash(Self) -> Int // 有默认实现\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // 待实现\n"
"  to_string(Self) -> String // 有默认实现\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"

#: ../../language/methods.md:297
msgid "Deriving builtin traits"
msgstr "派生内建特征"

#: ../../language/methods.md:299
msgid "MoonBit can automatically derive implementations for some builtin traits:"
msgstr "MoonBit 可以自动为一些内建特征派生实现："

#: ../../language/methods.md:301
msgid ""
"struct T {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare, Show, Default)\n"
"\n"
"test {\n"
"  let t1 = T::default()\n"
"  let t2 = T::{ x: 1, y: 1 }\n"
"  inspect!(t1, content=\"{x: 0, y: 0}\")\n"
"  inspect!(t2, content=\"{x: 1, y: 1}\")\n"
"  assert_not_eq!(t1, t2)\n"
"  assert_true!(t1 < t2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:307
msgid "See [Deriving](./derive.md) for more information about deriving traits."
msgstr "参见 [派生](./derive.md) 了解有关派生特征的更多信息。"

#: ../../language/packages.md:1
msgid "Managing Projects with Packages"
msgstr "使用包管理项目"

#: ../../language/packages.md:3
msgid ""
"When developing projects at large scale, the project usually needs to be "
"divided into smaller modular unit that depends on each other.  More "
"often, it involves using other people's work: most noticeably is the "
"[core](https://github.com/moonbitlang/core), the standard library of "
"MoonBit."
msgstr ""
"在大规模开发项目时，项目通常需要分解为相互依赖的较小模块单元。更常见的是使用其他人的工作：最典型的是 "
"[core](https://github.com/moonbitlang/core)，MoonBit 的标准库。"

#: ../../language/packages.md:6
msgid "Packages and modules"
msgstr "包和模块"

#: ../../language/packages.md:8
msgid ""
"In MoonBit, the most important unit for code organization is a package, "
"which consists of a number of source code files and a single "
"`moon.pkg.json` configuration file. A package can either be a `main` "
"package, consisting a `main` function, or a package that serves as a "
"library."
msgstr ""
"在 MoonBit 中，代码组织的最重要单元是包，它由多个源代码文件和一个单独的 `moon.pkg.json` 配置文件组成。包可以是一个 "
"`main` 包，包含一个 `main` 函数，或者是一个用作库的包。"

#: ../../language/packages.md:11
msgid ""
"A project, corresponding to a module, consists of multiple packages and a"
" single `moon.mod.json` configuration file."
msgstr "一个项目对应一个模块，由多个包和一个单独的 `moon.mod.json` 配置文件组成。"

#: ../../language/packages.md:13
msgid ""
"When using things from another package, the dependency between modules "
"should first be declared inside the `moon.mod.json`. The dependency "
"between packages should then be declared inside the `moon.pkg.json`. Then"
" it is possible to use `@pkg` to access the imported entities, where "
"`pkg` is the last part of the imported package's path or the declared "
"alias in `moon.pkg.json`:"
msgstr ""
"在从另一个包中使用内容时，模块之间的依赖关系应首先在 `moon.mod.json` 中声明。然后在 `moon.pkg.json` "
"中声明包之间的依赖关系。然后可以使用 `@pkg` 访问导入的实体，其中 `pkg` 是导入包路径的最后一部分或 `moon.pkg.json` "
"中声明的别名："

#: ../../language/packages.md:17
msgid "pkgB/moon.pkg.json"
msgstr ""

#: ../../language/packages.md:17
msgid ""
"{\n"
"    \"import\": [\n"
"        \"moonbit-community/language/packages/pkgA\"\n"
"    ]\n"
"}"
msgstr ""

#: ../../language/packages.md:22
msgid "pkgB/top.mbt"
msgstr ""

#: ../../language/packages.md:22
msgid ""
"pub fn add1(x : Int) -> Int {\n"
"  @pkgA.incr(x)\n"
"}"
msgstr ""

#: ../../language/packages.md:27
msgid "Access Control"
msgstr "访问控制"

#: ../../language/packages.md:29
msgid ""
"By default, all function definitions and variable bindings are "
"_invisible_ to other packages. You can use the `pub` modifier before "
"toplevel `let`/`fn` to make them public."
msgstr "默认情况下，所有函数定义和变量绑定对其他包是 _不可见_ 的。可以在顶层 `let`/`fn` 前使用 `pub` 修饰符使其公开。"

#: ../../language/packages.md:32
msgid "There are four different kinds of visibility for types in MoonBit:"
msgstr "MoonBit 中有四种不同的类型可见性："

#: ../../language/packages.md:34
msgid ""
"private type, declared with `priv`, completely invisible to the outside "
"world"
msgstr "私有类型，使用 `priv` 声明，对外部世界完全不可见"

#: ../../language/packages.md:35
msgid ""
"abstract type, which is the default visibility for types. Only the name "
"of an abstract type is visible outside, the internal representation of "
"the type is hidden"
msgstr "抽象类型，这是类型的默认可见性。只有抽象类型的名称对外部可见，类型的内部表示被隐藏"

#: ../../language/packages.md:36
msgid ""
"readonly types, declared with `pub(readonly)`. The internal "
"representation of readonly types are visible outside, but users can only "
"read the values of these types from outside, construction and mutation "
"are not allowed"
msgstr "只读类型，使用 `pub(readonly)` 声明。只读类型的内部表示对外部可见，但用户只能从外部读取这些类型的值，不允许构造和修改"

#: ../../language/packages.md:38
msgid ""
"fully public types, declared with `pub(all)`. The outside world can "
"freely construct, modify and read values of these types"
msgstr "完全公开类型，使用 `pub(all)` 声明。外部世界可以自由构造、修改和读取这些类型的值"

#: ../../language/packages.md:40
msgid ""
"In addition to the visibility of the type itself, the fields of a public "
"`struct` can be annotated with `priv`, which will hide the field from the"
" outside world completely. Note that `struct`s with private fields cannot"
" be constructed directly outside, but you can update the public fields "
"using the functional struct update syntax."
msgstr ""
"除了类型本身的可见性外，公开的结构体的字段可以用 `priv` 注释，这将完全隐藏字段对外部世界。请注意，具有私有字段的 `struct` "
"不能直接在外部构造，但可以使用函数式 `struct` 更新语法更新公共字段。"

#: ../../language/packages.md:45
msgid ""
"Readonly types is a very useful feature, inspired by [private "
"types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short,"
" values of `pub(readonly)` types can be destructed by pattern matching "
"and the dot syntax, but cannot be constructed or mutated in other "
"packages. Note that there is no restriction within the same package where"
" `pub(readonly)` types are defined."
msgstr ""
"只读类型是一个非常有用的功能，受到 OCaml 中 "
"[私有类型](https://v2.ocaml.org/manual/privatetypes.html) "
"的启发。简而言之，`pub(readonly)` 类型的值可以通过模式匹配和点语法解构，但不能在其他包中构造或修改。请注意，在定义 "
"`pub(readonly)` 类型的同一包中没有限制。"

#: ../../language/packages.md:49
msgid ""
"// Package A\n"
"pub(readonly) struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // OK\n"
"  let r = { ..r, field: 8 }  // OK\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // OK\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public"
" read-only type RO!\n"
"  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only "
"field!\n"
"}\n"
msgstr ""
"// Package A\n"
"pub(readonly) struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // 可以\n"
"  let r = { ..r, field: 8 }  // 可以\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // 可以\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // 错误：不能创建公共只读类型 RO 的值！\n"
"  let r = { ..r, field: 8 }  // 错误：不能修改公共只读字段！\n"
"}\n"

#: ../../language/packages.md:71
msgid ""
"Access control in MoonBit adheres to the principle that a `pub` type, "
"function, or variable cannot be defined in terms of a private type. This "
"is because the private type may not be accessible everywhere that the "
"`pub` entity is used. MoonBit incorporates sanity checks to prevent the "
"occurrence of use cases that violate this principle."
msgstr ""
"MoonBit "
"中的访问控制遵循一个原则，即公开的类型、函数或变量不能以私有类型定义。这是因为私有类型可能无法在使用公开的实体的所有地方访问。MoonBit "
"包含了健全性检查，以防止违反这一原则的用例发生。"

#: ../../language/packages.md:74
msgid ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // OK\n"
"  y: T2  // OK\n"
"  z: T3  // ERROR: public field has private type `T3`!\n"
"}\n"
"\n"
"// ERROR: public function has private parameter type `T3`!\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// ERROR: public function has private return type `T3`!\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// OK\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // ERROR: public variable has private type `T3`!\n"
msgstr ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // 可以\n"
"  y: T2  // 可以\n"
"  z: T3  // 错误：公开字段使用了私有类型 `T3`！\n"
"}\n"
"\n"
"// 错误：公开函数使用了私有类型 `T3`！\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// 错误：公开函数的返回值使用了私有类型 `T3`！\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// 可以\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // 错误：公开变量的类型是私有类型 `T3`！\n"

#: ../../language/packages.md:95
msgid "Access control of methods and trait implementations"
msgstr "方法和特征实现的访问控制"

#: ../../language/packages.md:97
msgid ""
"To make the trait system coherent (i.e. there is a globally unique "
"implementation for every `Type: Trait` pair), and prevent third-party "
"packages from modifying behavior of existing programs by accident, "
"MoonBit employs the following restrictions on who can define "
"methods/implement traits for types:"
msgstr ""
"为了使特征系统一致（即每个 `Type: Trait` 对都有全局唯一的实现），并防止第三方包意外地修改现有程序的行为，MoonBit "
"对谁可以定义方法/实现类型的特征采用了以下限制："

#: ../../language/packages.md:101
msgid ""
"_only the package that defines a type can define methods for it_. So one "
"cannot define new methods or override old methods for builtin and foreign"
" types."
msgstr "**只有定义类型的包才能为其定义方法**。因此，不能为内建和外部类型定义新方法或覆盖旧方法。"

#: ../../language/packages.md:102
msgid ""
"_only the package of the type or the package of the trait can define an "
"implementation_. For example, only `@pkg1` and `@pkg2` are allowed to "
"write `impl @pkg1.Trait for @pkg2.Type`."
msgstr ""
"**只有类型的包或特征的包才能定义实现**。例如，只有 `@pkg1` 和 `@pkg2` 允许编写 `impl @pkg1.Trait for "
"@pkg2.Type`。"

#: ../../language/packages.md:105
msgid ""
"The second rule above allows one to add new functionality to a foreign "
"type by defining a new trait and implementing it. This makes MoonBit's "
"trait & method system flexible while enjoying good coherence property."
msgstr "上述第二条规则允许通过定义新特征并实现它来为外部类型添加新功能。这使 MoonBit 的特征和方法系统灵活，同时享有良好的一致性属性。"

#: ../../language/packages.md:108
msgid "Visibility of traits and sealed traits"
msgstr "特征的可见性和封闭特征"

#: ../../language/packages.md:109
msgid ""
"There are four visibility for traits, just like `struct` and `enum`: "
"private, abstract, readonly and fully public. Private traits are declared"
" with `priv trait`, and they are completely invisible from outside. "
"Abstract trait is the default visibility. Only the name of the trait is "
"visible from outside, and the methods in the trait are not exposed. "
"Readonly traits are declared with `pub(readonly) trait`, their methods "
"can be involked from outside, but only the current package can add new "
"implementation for readonly traits. Finally, fully public traits are "
"declared with `pub(open) trait`, they are open to new implementations "
"outside current package, and their methods can be freely used."
msgstr ""
"特征有四种可见性，就像 `struct` 和 `enum`：私有、抽象、只读和完全公开。私有特征使用 `priv trait` "
"声明，对外部完全不可见。抽象特征是默认可见性：只有特征的名称对外部可见，特征中的方法不会暴露。只读特征使用 `pub(readonly) "
"trait` 声明，它们的方法可以从外部调用，但只有当前包可以为只读特征添加新实现。最后，完全公开特征使用 `pub(open) trait` "
"声明，它们对外部新实现是开放的，它们的方法可以自由使用。"

#: ../../language/packages.md:115
msgid ""
"Abstract and readonly traits are sealed, because only the package "
"defining the trait can implement them. Implementing a sealed (abstract or"
" readonly) trait outside its package result in compiler error. If you are"
" the owner of a sealed trait, and you want to make some implementation "
"available to users of your package, make sure there is at least one "
"declaration of the form `impl Trait for Type with ...` in your package. "
"Implementations with only regular method and default implementations will"
" not be available outside."
msgstr "抽象和只读特征是封闭的，因为只有定义特征的包才能实现它们。在其包外实现封闭（抽象或只读）特征会导致编译器错误。"

#: ../../language/packages.md:121
msgid "Here's an example of abstract trait:"
msgstr "以下是抽象特征的示例："

#: ../../language/packages.md:124
msgid ""
"trait Number {\n"
" op_add(Self, Self) -> Self\n"
" op_sub(Self, Self) -> Self\n"
"}\n"
"\n"
"fn add[N : Number](x : N, y: N) -> N {\n"
"  Number::op_add(x, y)\n"
"}\n"
"\n"
"fn sub[N : Number](x : N, y: N) -> N {\n"
"  Number::op_sub(x, y)\n"
"}\n"
"\n"
"impl Number for Int with op_add(x, y) { x + y }\n"
"impl Number for Int with op_sub(x, y) { x - y }\n"
"\n"
"impl Number for Double with op_add(x, y) { x + y }\n"
"impl Number for Double with op_sub(x, y) { x - y }\n"
msgstr ""

#: ../../language/packages.md:145
msgid "From outside this package, users can only see the following:"
msgstr "从包外，用户只能看到以下内容："

#: ../../language/packages.md:147
msgid ""
"trait Number\n"
"\n"
"fn op_add[N : Number](x : N, y : N) -> N\n"
"fn op_sub[N : Number](x : N, y : N) -> N\n"
"\n"
"impl Number for Int\n"
"impl Number for Double\n"
msgstr ""

#: ../../language/packages.md:157
msgid ""
"The author of `Number` can make use of the fact that only `Int` and "
"`Double` can ever implement `Number`, because new implementations are not"
" allowed outside."
msgstr "`Number` 的作者可以利用只有 `Int` 和 `Double` 可以实现 `Number` 这一事实，因为在外部不允许新的实现。"

#: ../../language/tests.md:1
msgid "Writing Tests"
msgstr "编写测试"

#: ../../language/tests.md:3
msgid ""
"Tests are important for improving quality and maintainability of a "
"program. They verify the behavior of a program and also serves as a "
"specification to avoid regressions over time."
msgstr "测试对于提高程序的质量和可维护性很重要。它们验证程序的行为，也作为规范，以避免随时间的推移出现退步。"

#: ../../language/tests.md:5
msgid "MoonBit comes with test support to make the writing easier and simpler."
msgstr "MoonBit 提供测试支持，使编写测试更加简单和容易。"

#: ../../language/tests.md:7
msgid "Test Blocks"
msgstr "测试块"

#: ../../language/tests.md:9
msgid ""
"MoonBit provides the test code block for writing inline test cases. For "
"example:"
msgstr "MoonBit 提供测试代码块，用于编写内联测试用例。例如："

#: ../../language/tests.md:17
msgid ""
"A test code block is essentially a function that returns a `Unit` but may"
" throws a `String` on error, or `Unit!String` as one would see in its "
"signature at the position of return type. It is called during the "
"execution of `moon test` and outputs a test report through the build "
"system. The `assert_eq` function is from the standard library; if the "
"assertion fails, it prints an error message and terminates the test. The "
"string `\"test_name\"` is used to identify the test case and is optional."
msgstr ""
"测试代码块本质上是一个返回 `Unit` 抛出 `String` 的函数。它在执行 `moon test` "
"期间被调用，并通过构建系统输出测试报告。`assert_eq` 函数来自标准库；如果断言失败，它会打印错误消息并终止测试。字符串 "
"`\"test_name\"` 用于标识测试用例，是可选的。"

#: ../../language/tests.md:19
msgid ""
"If a test name starts with `\"panic\"`, it indicates that the expected "
"behavior of the test is to trigger a panic, and the test will only pass "
"if the panic is triggered. For example:"
msgstr "如果测试名称以 `\"panic\"` 开头，表示测试的预期行为是触发 panic，只有在触发 panic 时测试才会通过。例如："

#: ../../language/tests.md:21
msgid ""
"test \"panic_test\" {\n"
"  let _ : Int = Option::None.unwrap()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/tests.md:27
msgid "Snapshot Tests"
msgstr "快照测试"

#: ../../language/tests.md:29
msgid ""
"Writing tests can be tedious when specifying the expected values. Thus, "
"MoonBit provides three kinds of snapshot tests. All of which can be "
"inserted or updated automatically using `moon test --update`."
msgstr ""
"在指定预期值时，编写测试可能会很繁琐。因此，MoonBit 提供了三种快照测试。所有这些都可以使用 `moon test --update` "
"自动插入或更新。"

#: ../../language/tests.md:32
msgid "Snapshotting `Show`"
msgstr "快照 `Show`"

#: ../../language/tests.md:34
msgid ""
"We can use `inspect!(x, content=\"x\")` to inspect anything that "
"implements `Show` trait.  As we mentioned before, `Show` is a builtin "
"trait that can be derived, providing `to_string` that will print the "
"content of the data structures.  The labelled argument `content` can be "
"omitted as `moon test --update` will insert it for you:"
msgstr ""
"我们可以使用 `inspect!(x, content=\"x\")` 来检查实现了 `Show` "
"特征的任何内容。正如我们之前提到的，`Show` 是一个可以派生的内建特征，提供了 `to_string`来打印数据结构的内容。标记参数 "
"`content` 可以省略，因为 `moon test --update` 会自动插入："

#: ../../language/tests.md:38
msgid ""
"struct X { x : Int } derive(Show)\n"
"\n"
"test \"show snapshot test\" {\n"
"  inspect!({x: 10}, content=\"{x: 10}\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:44
msgid "Snapshotting `JSON`"
msgstr "快照 `JSON`"

#: ../../language/tests.md:46
msgid ""
"The problem with the derived `Show` trait is that it does not perform "
"pretty printing, resulting in extremely long output."
msgstr "派生的 `Show` 特征的问题是它不能对输出进行格式化，导致输出非常长。"

#: ../../language/tests.md:48
msgid ""
"The solution is to use `@json.inspect!(x, content=x)`. The benefit is "
"that the resulting content is a JSON structure, which can be more "
"readable after being formatted."
msgstr "解决方案是使用 `@json.inspect!(x, content=x)`。其好处是生成的内容是一个 JSON 结构，在格式化后更易读。"

#: ../../language/tests.md:50
msgid ""
"enum Rec {\n"
"  End\n"
"  Really_long_name_that_is_difficult_to_read(Rec)\n"
"} derive(Show, ToJson)\n"
"\n"
"test \"json snapshot test\" {\n"
"  let r = Really_long_name_that_is_difficult_to_read(\n"
"    Really_long_name_that_is_difficult_to_read(\n"
"      Really_long_name_that_is_difficult_to_read(End),\n"
"    ),\n"
"  )\n"
"  inspect!(\n"
"    r,\n"
"    "
"content=\"Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(End)))\","
"\n"
"  )\n"
"  @json.inspect!(\n"
"    r,\n"
"    content={\n"
"      \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"      \"0\": {\n"
"        \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"        \"0\": {\n"
"          \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"          \"0\": { \"$tag\": \"End\" },\n"
"        },\n"
"      },\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/tests.md:56
msgid ""
"One can also implement a custom `ToJson` to keep only the essential "
"information."
msgstr "也可以实现自定义 `ToJson` 来保留必要的信息。"

#: ../../language/tests.md:58
msgid "Snapshotting Anything"
msgstr "快照任何内容"

#: ../../language/tests.md:60
msgid ""
"Still, sometimes we want to not only record one data structure but the "
"output of a whole process."
msgstr "有时我们不仅要记录一个数据结构，还要记录整个过程的输出。"

#: ../../language/tests.md:62
msgid ""
"A full snapshot test can be used to record anything using "
"`@test.T::write` and `@test.T::writeln`:"
msgstr "可以使用完整的快照测试使用 `@test.T::write` 和 `@test.T::writeln` 记录任何内容："

#: ../../language/tests.md:64
msgid ""
"test \"record anything\" (t : @test.T) {\n"
"  t.write(\"Hello, world!\")\n"
"  t.writeln(\" And hello, MoonBit!\")\n"
"  t.snapshot!(filename=\"record_anything.txt\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:70
msgid ""
"This will create a file under `__snapshot__` of that package with the "
"given filename:"
msgstr "这将在该包的 `__snapshot__` 下创建一个具有给定文件名的文件："

#: ../../language/tests.md:72
msgid "Hello, world! And hello, MoonBit!\n"
msgstr ""

#: ../../language/tests.md:75
msgid ""
"This can also be used for applications to test the generated output, "
"whether it were creating an image, a video or some custom data."
msgstr "这也可以用于测试应用程序的输出，无论是创建图像、视频还是一些自定义数据。"

#: ../../language/tests.md:77
msgid "BlackBox Tests and WhiteBox Tests"
msgstr "黑盒测试和白盒测试"

#: ../../language/tests.md:79
msgid ""
"When developing libraries, it is important to verify if the user can use "
"it correctly. For example, one may forget to make a type or a function "
"public. That's why MoonBit provides BlackBox tests, allowing developers "
"to have a grasp of how others are feeling."
msgstr ""
"在开发库时，验证用户是否可以正确使用它是很重要的。例如，可能会忘记使类型或函数公开。这就是为什么 MoonBit "
"提供了黑盒测试，允许开发人员了解其他人的感受。"

#: ../../language/tests.md:81
msgid ""
"A test that has access to all the members in a package is called a "
"WhiteBox tests as we can see everything. Such tests can be defined inline"
" or defined in a file whose name ends with `_wbtest.mbt`."
msgstr ""
"只能访问包中所有成员的测试称为白盒测试，因为我们可以看到一切。这样的测试可以内联定义，也可以在文件中定义，文件名以 `_wbtest.mbt` "
"结尾。"

#: ../../language/tests.md:83
msgid ""
"A test that has access only to the public members in a package is called "
"a BlackBox tests. Such tests need to be defined in a file whose name ends"
" with `_test.mbt`."
msgstr "只能访问包中公共成员的测试称为黑盒测试。这样的测试需要在文件中定义，文件名以 `_test.mbt` 结尾。"

#: ../../language/tests.md:85
msgid ""
"The WhiteBox test files (`_wbtest.mbt`) imports the packages defined in "
"the `import` and `wbtest-import` sections of the package configuration "
"(`moon.pkg.json`)."
msgstr ""
"白盒测试文件（`_wbtest.mbt`）导入包配置（`moon.pkg.json`）中的 `import` 和 `wbtest-import` "
"部分定义的包。"

#: ../../language/tests.md:87
msgid ""
"The BlackBox test files (`_test.mbt`) imports the current package and the"
" packages defined in the `import` and `test-import` sections of the "
"package configuration (`moon.pkg.json`)."
msgstr ""
"黑盒测试文件（`_test.mbt`）导入当前包和包配置（`moon.pkg.json`）中的 `import` 和 `test-import` "
"部分定义的包。"

#~ msgid ""
#~ "const [log, flush] = (() => {\n"
#~ "  var buffer = [];\n"
#~ "  function flush() {\n"
#~ "    if (buffer.length > 0) {\n"
#~ "      console.log(new TextDecoder(\"utf-16\").decode(new"
#~ " Uint16Array(buffer).valueOf()));\n"
#~ "      buffer = [];\n"
#~ "    }\n"
#~ "  }\n"
#~ "  function log(ch) {\n"
#~ "    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
#~ "    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
#~ "    else { buffer.push(ch); }\n"
#~ "  }\n"
#~ "  return [log, flush]\n"
#~ "})();\n"
#~ "\n"
#~ "const importObject = {\n"
#~ "  // ...\n"
#~ "  spectest: {\n"
#~ "    print_char: log\n"
#~ "  },\n"
#~ "}\n"
#~ "\n"
#~ "// ...\n"
#~ "WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
#~ "gc/release/build/lib/lib.wasm\"), importObject).then(\n"
#~ "  (obj) => {\n"
#~ "    obj.instance.exports._start();\n"
#~ "    // ...\n"
#~ "    flush()\n"
#~ "  }\n"
#~ ");\n"
#~ msgstr ""

#~ msgid ""
#~ "<!DOCTYPE html>\n"
#~ "<html>\n"
#~ "\n"
#~ "<head></head>\n"
#~ "\n"
#~ "<body>\n"
#~ "  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
#~ "  <script>\n"
#~ "    function prototype_to_ffi(prototype) {\n"
#~ "      return Object.fromEntries(\n"
#~ "        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
#~ "          .filter(([_key, value]) => value.value)\n"
#~ "          .map(([key, value]) => {\n"
#~ "            if (typeof value.value == 'function')\n"
#~ "              return [key, Function.prototype.call.bind(value.value)]\n"
#~ "            else\n"
#~ "              return [key, () => value.value]\n"
#~ "          })\n"
#~ "      );\n"
#~ "    }\n"
#~ "\n"
#~ "    const [log, flush] = (() => {\n"
#~ "      var buffer = [];\n"
#~ "      function flush() {\n"
#~ "        if (buffer.length > 0) {\n"
#~ "          console.log(new "
#~ "TextDecoder(\"utf-16\").decode(new "
#~ "Uint16Array(buffer).valueOf()));\n"
#~ "          buffer = [];\n"
#~ "        }\n"
#~ "      }\n"
#~ "      function log(ch) {\n"
#~ "        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
#~ "        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
#~ "        else { buffer.push(ch); }\n"
#~ "      }\n"
#~ "      return [log, flush]\n"
#~ "    })();\n"
#~ "\n"
#~ "\n"
#~ "\n"
#~ "    const importObject = {\n"
#~ "      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
#~ "      math: prototype_to_ffi(Math),\n"
#~ "      spectest: {\n"
#~ "        print_char: log\n"
#~ "      },\n"
#~ "    }\n"
#~ "\n"
#~ "    const canvas = document.getElementById(\"canvas\");\n"
#~ "    if (canvas.getContext) {\n"
#~ "      const ctx = canvas.getContext(\"2d\");\n"
#~ "      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
#~ "gc/release/build/lib/lib.wasm\"), importObject).then(\n"
#~ "        (obj) => {\n"
#~ "          obj.instance.exports._start();\n"
#~ "          obj.instance.exports[\"draw\"](ctx);\n"
#~ "          obj.instance.exports[\"display_pi\"]();\n"
#~ "          flush()\n"
#~ "        }\n"
#~ "      );\n"
#~ "    }\n"
#~ "  </script>\n"
#~ "</body>\n"
#~ "\n"
#~ "</html>\n"
#~ msgstr ""

