# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-25 16:52+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/async-experimental.md:1
msgid "Experimental async programming support"
msgstr "实验性的异步编程支持"

#: ../../language/async-experimental.md:3
msgid ""
"MoonBit is providing experimental support for async programming. But the "
"design and API is still highly unstable, and may receive big breaking "
"change in the future. This page documents the current design, and we "
"highly appreciate any feedback or experiment with current design."
msgstr ""
"MoonBit 目前提供了实验性的异步编程支持。但异步相关功能的设计和 API 非常不稳定，未来可能会有大的破坏性改动。本文档页面将介绍 "
"MoonBit 异步编程目前的设计，我们欢迎及感谢任何对目前设计的反馈与使用体验分享。"

#: ../../language/async-experimental.md:7
msgid "Async function"
msgstr "异步函数"

#: ../../language/async-experimental.md:8
msgid "Async functions can be declared with the `async` keyword:"
msgstr "异步函数可以用 `async` 关键字声明："

#: ../../language/async-experimental.md:10
msgid ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// anonymous/local function\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// 匿名/本地函数\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"

#: ../../language/async-experimental.md:16
msgid "Async functions must be called with the `!!` operator:"
msgstr "调用异步函数时，必须用 `!!` 操作符来标记这是一次异步函数调用："

#: ../../language/async-experimental.md:18
msgid ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // error will be rethrowed by `!!`\n"
"  some_async_function!!()\n"
"}\n"
msgstr ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // 异步函数中的错误也会被 `!!` 转发\n"
"  some_async_function!!()\n"
"}\n"

#: ../../language/async-experimental.md:24
msgid "If the async function may throw error, `!!` will also rethrow the error."
msgstr "如果异步函数会抛出错误，`!!` 也会把错误一并转发。"

#: ../../language/async-experimental.md:26
msgid ""
"Async functions can only be called in async functions. Currently, async "
"functions cannot be called in the body of `for .. in` loops."
msgstr "异步函数只能在其他异步函数中被调用。目前，在 `for .. in` 循环中不能使用异步函数。"

#: ../../language/async-experimental.md:28
msgid "Async primitives for suspension"
msgstr "用于中断异步函数的原语"

#: ../../language/async-experimental.md:29
msgid ""
"MoonBit provides two core primitives for `%async.suspend` and "
"`%async.run`:"
msgstr "MoonBit 提供了两个用于异步编程的原语：`%async.suspend` 和 `%async.run`："

#: ../../language/async-experimental.md:31
msgid ""
"\n"
"// `run_async` spawn a new coroutine and execute an async function in it\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` will suspend the execution of the current coroutine.\n"
"// The suspension will be handled by a callback passed to `suspend`\n"
"async fn suspend[T, E : Error](\n"
"  // `f` is a callback for handling suspension\n"
"  f : (\n"
"    // the first parameter of `f` is used to resume the execution of the "
"coroutine normally\n"
"    (T) -> Unit,\n"
"    // the second parameter of `f` is used to cancel the execution of the"
" current coroutine\n"
"    // by throwing an error at suspension point\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"
msgstr ""
"\n"
"// `run_async` 会创建一个新的协程，并在其中运行一个异步函数\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` 会中断当前协程的运行。\n"
"// `suspend` 会接受一个回调函数，并让这个回调函数来操作中断的协程\n"
"async fn suspend[T, E : Error](\n"
"  // `f` 是负责操作中断的协程的回调函数\n"
"  f : (\n"
"    // `f` 的第一个参数用于继续运行被中断的协程\n"
"    (T) -> Unit,\n"
"    // `f` 的第二个参数用于取消被中断的协程。\n"
"    // 取消会被表示为在中断处抛出错误\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"

#: ../../language/async-experimental.md:37
msgid ""
"There two primitives are not intended for direct use by end users. "
"However, since MoonBit's standard library for async programming is still "
"under development, currently users need to bind these two primitives "
"manually to do async programming."
msgstr "这两个原语不应该让终端用户直接调用。但由于 MoonBit 的异步标准库仍在开发中，目前，用户需要手动绑定这两个原语，才能编写异步程序。"

#: ../../language/async-experimental.md:41
msgid "There are two ways of reading these primitives:"
msgstr "可以用两种不同的方式来理解这两个原语："

#: ../../language/async-experimental.md:43
msgid ""
"the coroutine reading: `%async.run` spawn a new coroutine, and "
"`%async.suspend` suspend current coroutine. The main difference with "
"other languages here is: instead of yielding all the way to the caller of"
" `%async.run`, resumption of the coroutine is handled by the callback "
"passed to `%async.suspend`"
msgstr ""
"理解为协程：`%async.run` 创建一个新的协程，`%async.suspend` "
"中断当前协程。和其他语言的协程的主要区别是：中断协程时，不是由创建协程的地方来负责恢复执行，而是在中断的地方通过一个回调函数就地处理中断后的协程"

#: ../../language/async-experimental.md:48
msgid ""
"the delimited continuation reading: `%async.run` is the `reset` operator "
"in delimited continuation, and `%async.suspend` is the `shift` operator "
"in delimited continuation"
msgstr ""
"理解为 delimited continuation：`%async.run` 是 delimited continuation 中的 "
"`reset` 操作符，`%async.suspend` 是 delimited continuation `shift` 操作符"

#: ../../language/async-experimental.md:51
msgid "Here's an example of how these two primitives work:"
msgstr "以下是使用这两个原语的示例："

#: ../../language/async-experimental.md:53
msgid ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"the end of the coroutine\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// the program below should print:\n"
"//\n"
"//   the worker finishes\n"
"//   the end of the coroutine\n"
"//   after the first coroutine finishes\n"
"//   caught MyError\n"
"test {\n"
"  // when supplying an anonymous function\n"
"  // to a higher order function that expects async parameter,\n"
"  // the `async` keyword can be omitted\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"after the first coroutine finishes\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"协程结束运行\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// 下面这段程序应当输出：\n"
"//\n"
"//   worker 函数返回了\n"
"//   协程结束运行\n"
"//   协程结束之后\n"
"//   捕获到了 MyError\n"
"test {\n"
"  // 在调用一个需要异步参数的高阶函数时，\n"
"  // 如果参数是一个匿名函数，可以省略 `async` 关键字\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"第一个协程结束之后\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:59
msgid ""
"In `async_worker`, `suspend` will capture the rest of the current "
"coroutine as two \"continuation\" functions, and pass them to a callback."
" In the callback, calling `resume_ok` will resume execution at the point "
"of `suspend!!(...)`, all the way until the `run_async` call that start "
"this coroutine. calling `resume_err` will also resume execution of "
"current coroutine, but it will make `suspend!!(...)` throw an error "
"instead of returning normally."
msgstr ""
"在 `async_worker` 里，`suspend` 会捕获当前协程剩下的部分，并将它们表示成两个函数，传递给 `suspend` 的参数。在"
" `suspend` 的参数里，调用 `resume_ok` 会让 `suspend!!(...)` "
"正常返回，恢复协程的运行，一直运行到创建这个协程的 `run_async(...)` 为止。调用 `resume_err` "
"也会恢复协程的运行，但它会在 `suspend!!(...)` 的位置抛出一个错误。"

#: ../../language/async-experimental.md:65
msgid ""
"Notice that `suspend` type may throw error, even if `suspend` itself "
"never throw an error directly. This design makes coroutines cancellable "
"at every `suspend` call: just call the corresponding `resume_err` "
"callback."
msgstr ""
"`suspend` 的类型表明它可能抛出错误。但 `suspend` "
"自身不会直接产生任何错误。这一设计保证了协程在每一个的中断点都是可以取消的：调用对应的 `resume_err` 函数即可。"

#: ../../language/async-experimental.md:68
msgid "Integrating with JS Promise/callback based API"
msgstr "和 JS 的 Promise/回调 API 整合"

#: ../../language/async-experimental.md:69
msgid ""
"Since MoonBit's standard async library is still under development, so "
"there is no ready-to-use implementation for event loop and IO operations "
"yet. So the easiest way to write some async program is to use MoonBit's "
"Javascript backend, and reuse the event loop and IO operations of "
"Javascript. Here's an example of integrating MoonBit's async programming "
"support with JS's callback based API:"
msgstr ""
"MoonBit 的异步标准库仍在开发中，因此，目前没有直接可用的事件循环和输入输出原语实现。目前，要使用 MoonBit "
"编写异步程序最简单的办法是使用 JS 后端，并复用 JavaScript 的事件循环和输入输出 API。下面是一个整合 MoonBit "
"的异步编程支持和 JS 的回调 API 的例子："

#: ../../language/async-experimental.md:75
msgid ""
"extern type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"
msgstr ""
"extern type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:81
msgid ""
"Integrating with JS Promise is easy too: just pass `resume_ok` as the "
"`resolve` callback and `resume_err` as the `reject` callback to a JS "
"promise."
msgstr ""
"和 JS Promise 也非常简单：只需要把 `resume_ok` 函数用作 `Promise` 的 `resolve` 把 "
"`resume_err` 用作 Promise 的 `reject` 回调即可。"

#: ../../language/derive.md:1
msgid "Deriving traits"
msgstr "派生内建特征"

#: ../../language/derive.md:3
msgid ""
"MoonBit supports deriving a number of builtin traits automatically from "
"the type definition."
msgstr "MoonBit 支持从类型定义中自动派生一些内建特征。"

#: ../../language/derive.md:5
msgid ""
"To derive a trait `T`, it is required that all fields used in the type "
"implements `T`. For example, deriving `Show` for a struct `struct A { x: "
"T1; y: T2 }` requires both `T1: Show` and `T2: Show`"
msgstr ""
"要派生特征 `T`，需要类型中使用的所有字段都实现了 `T`。例如，为结构体 `struct A { x: T1; y: T2 }` 派生 "
"`Show` 需要 `T1: Show` 和 `T2: Show`。"

#: ../../language/derive.md:8
msgid "Show"
msgstr "输出"

#: ../../language/derive.md:10
msgid ""
"`derive(Show)` will generate a pretty-printing method for the type. The "
"derived format is similar to how the type can be constructed in code."
msgstr "`derive(Show)` 将为类型生成一个漂亮的打印方法。派生的格式类似于代码中构造类型的方式。"

#: ../../language/derive.md:13
msgid ""
"struct MyStruct {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Show)\n"
"\n"
"test \"derive show struct\" {\n"
"  let p = MyStruct::{ x: 1, y: 2 }\n"
"  assert_eq!(Show::to_string(p), \"{x: 1, y: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:19
msgid ""
"enum MyEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Show)\n"
"\n"
"test \"derive show enum\" {\n"
"  assert_eq!(Show::to_string(MyEnum::Case1(42)), \"Case1(42)\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case2(label=\"hello\")), "
"\"Case2(label=\\\"hello\\\")\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case3), \"Case3\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:25
msgid "Eq and Compare"
msgstr "相等和比较"

#: ../../language/derive.md:27
msgid ""
"`derive(Eq)` and `derive(Compare)` will generate the corresponding method"
" for testing equality and comparison. Fields are compared in the same "
"order as their definitions. For enums, the order between cases ascends in"
" the order of definition."
msgstr ""
"`derive(Eq)` 和 `derive(Compare)` "
"将为测试相等性和比较生成相应的方法。字段按照它们的定义顺序进行比较。对于枚举，构造器的顺序按照定义的顺序升序。"

#: ../../language/derive.md:31
msgid ""
"struct DeriveEqCompare {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare struct\" {\n"
"  let p1 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p2 = DeriveEqCompare::{ x: 2, y: 1 }\n"
"  let p3 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p4 = DeriveEqCompare::{ x: 1, y: 3 }\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"  \n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true)\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true)\n"
"  assert_eq!(p1 > p2, false)\n"
"  assert_eq!(p1 > p3, false)\n"
"  assert_eq!(p1 > p4, false)\n"
"  assert_eq!(p1 <= p2, true)\n"
"  assert_eq!(p1 >= p2, false)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:37
msgid ""
"enum DeriveEqCompareEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare enum\" {\n"
"  let p1 = DeriveEqCompareEnum::Case1(42)\n"
"  let p2 = DeriveEqCompareEnum::Case1(43)\n"
"  let p3 = DeriveEqCompareEnum::Case1(42)\n"
"  let p4 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p5 = DeriveEqCompareEnum::Case2(label=\"world\")\n"
"  let p6 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p7 = DeriveEqCompareEnum::Case3\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"\n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true) // 42 < 43\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true) // Case1 < Case2\n"
"  assert_eq!(p4 < p5, true)\n"
"  assert_eq!(p4 < p6, false)\n"
"  assert_eq!(p4 < p7, true) // Case2 < Case3\n"
"}\n"
msgstr ""

#: ../../language/derive.md:43
msgid "Default"
msgstr "默认值"

#: ../../language/derive.md:45
msgid ""
"`derive(Default)` will generate a method that returns the default value "
"of the type."
msgstr "`derive(Default)` 将生成一个返回类型的默认值的方法。"

#: ../../language/derive.md:47
msgid ""
"For structs, the default value is the struct with all fields set as their"
" default value."
msgstr "对于结构体，默认值是所有字段设置为它们的默认值的结构体。"

#: ../../language/derive.md:49
msgid ""
"struct DeriveDefault {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default struct\" {\n"
"  let p = DeriveDefault::default()\n"
"  assert_eq!(p, DeriveDefault::{ x: 0, y: None })\n"
"}\n"
msgstr ""

#: ../../language/derive.md:55
msgid "For enums, the default value is the only case that has no parameters."
msgstr "对于枚举，默认值是唯一没有参数的构造器。"

#: ../../language/derive.md:57
msgid ""
"enum DeriveDefaultEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default enum\" {\n"
"  assert_eq!(DeriveDefaultEnum::default(), DeriveDefaultEnum::Case3)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:63
msgid ""
"Enums that has no cases or more than one cases without parameters cannot "
"derive `Default`."
msgstr "没有构造器或有多个没有参数的构造器的枚举不能派生 `Default`。"

#: ../../language/derive.md:67
msgid ""
"enum CannotDerive1 {\n"
"    Case1(String)\n"
"    Case2(Int)\n"
"} derive(Default) // cannot find a constant constructor as default\n"
"\n"
"enum CannotDerive2 {\n"
"    Case1\n"
"    Case2\n"
"} derive(Default) // Case1 and Case2 are both candidates as default "
"constructor\n"
msgstr ""

#: ../../language/derive.md:79
msgid "Hash"
msgstr "哈希值"

#: ../../language/derive.md:81
msgid ""
"`derive(Hash)` will generate a hash implementation for the type. This "
"will allow the type to be used in places that expects a `Hash` "
"implementation, for example `HashMap`s and `HashSet`s."
msgstr ""
"`derive(Hash)` 将为类型生成一个哈希实现。这将允许类型在期望 `Hash` 实现的地方使用，例如 `HashMap` 和 "
"`HashSet`。"

#: ../../language/derive.md:85
msgid ""
"struct DeriveHash {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Hash, Eq, Show)\n"
"\n"
"test \"derive hash struct\" {\n"
"  let hs = @hashset.new()\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  assert_eq!(hs.size(), 1)\n"
"  hs.add(DeriveHash::{x: 123, y: Some(\"456\")})\n"
"  assert_eq!(hs.size(), 2)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:91
msgid "Arbitrary"
msgstr "任意值"

#: ../../language/derive.md:93
msgid "`derive(Arbitrary)` will generate random values of the given type."
msgstr "`derive(Arbitrary)` 将生成给定类型的随机值。"

#: ../../language/derive.md:95
msgid "FromJson and ToJson"
msgstr "从/到 Json"

#: ../../language/derive.md:97
msgid ""
"`derive(FromJson)` and `derive(ToJson)` will generate methods that "
"deserializes/serializes the given type from/to JSON files "
"correspondingly."
msgstr "`derive(FromJson)` 和 `derive(ToJson)` 将分别生成从/到 JSON 文件反序列化/序列化给定类型的方法。"

#: ../../language/derive.md:100
msgid ""
"struct JsonTest1 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"enum JsonTest2 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"test \"json basic\"{\n"
"  let input = JsonTest1::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"x\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest2::A(x=123)\n"
"  let expected: Json = { \"$tag\": \"A\", \"x\": 123 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:106
msgid ""
"Both derive directives accept a number of arguments to configure the "
"exact behavior of serialization and deserialization."
msgstr "这两个派生指令都接受一些参数来配置序列化和反序列化的确切行为。"

#: ../../language/derive.md:109
msgid "The actual behavior of JSON serialization arguments is unstable."
msgstr "JSON 序列化参数的实际行为是不稳定的。"

#: ../../language/derive.md:112
msgid ""
"struct JsonTest3 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(\n"
"  FromJson(fields(x(rename = \"renamedX\"))), \n"
"  ToJson(fields(x(rename = \"renamedX\"))),\n"
"  Eq, Show\n"
")\n"
"\n"
"enum JsonTest4 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(\n"
"  FromJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  ToJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  Eq, Show\n"
")\n"
"\n"
"test \"json args\"{\n"
"  let input = JsonTest3::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"renamedX\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest4::A(x=123)\n"
"  let expected: Json = { \"A\": { \"X\": 123 } }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:118
msgid "Enum representations"
msgstr "枚举表示"

#: ../../language/derive.md:120
msgid ""
"Enums can be represented in JSON in a number of styles. There are two "
"aspects of the representation:"
msgstr "枚举表示为 JSON 有多种风格。表示有两个方面："

#: ../../language/derive.md:123
msgid ""
"**Tag position** determines where the name of the enum tag (i.e. case or "
"constructor name) is stored."
msgstr "**标签位置** 决定枚举标签（即构造器名称）的名称存储在哪里。"

#: ../../language/derive.md:124
msgid ""
"**Case representation** determines how to represent the payload of the "
"enum."
msgstr "**构造器表示** 决定如何表示枚举的负载。"

#: ../../language/derive.md:126
msgid "Let's consider the following enum definition:"
msgstr "让我们考虑以下枚举定义："

#: ../../language/derive.md:128
msgid ""
"enum E {\n"
"    Uniform(Int)\n"
"    Axes(x~: Int, y~: Int)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:135
msgid "For tag position, there are 4 variants:"
msgstr "对于标签位置，有 4 个变体："

#: ../../language/derive.md:137
msgid "**Internally tagged** puts the tag alongside the payload values:"
msgstr "**内部标记** 将标签与负载值一起放置："

#: ../../language/derive.md:139
msgid ""
"`{ \"$tag\": \"Uniform\", \"0\": 1 }`, `{ \"$tag\": \"Axes\", \"x\": 2, "
"\"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:141
msgid ""
"**Externally tagged** puts the tag as the JSON object key outside the "
"payload values:"
msgstr "**外部标记** 将标签作为 JSON 对象键放置在负载值之外："

#: ../../language/derive.md:143
msgid "`{ \"Uniform\": { \"0\": 1 } }`, `{ \"Axes\": { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:145
msgid ""
"**Adjacently tagged** puts the tag payload in two adjacent keys in a JSON"
" object:"
msgstr "**相邻标记** 将标签负载放置在 JSON 对象中的两个相邻键中："

#: ../../language/derive.md:147
msgid ""
"`{ \"t\": \"Uniform\", \"c\": { \"0\": 1 } }`, `{ \"t\": \"Axes\", \"c\":"
" { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:149
msgid "**Untagged** has no explicit tag identifying which case the data is:"
msgstr "**无标记** 没有明确的标记标识数据属于哪个构造器："

#: ../../language/derive.md:151
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`."
msgstr ""

#: ../../language/derive.md:153
msgid ""
"The JSON deserializer will try to deserialize each case in order and "
"return the first one succeeding."
msgstr "JSON 反序列化器将尝试按顺序反序列化每个构造器，并返回第一个成功的构造器。"

#: ../../language/derive.md:155
msgid "For case representation, there are 2 variants:"
msgstr "对于构造器表示，有 2 个变体："

#: ../../language/derive.md:157
msgid ""
"**Object-like** representation serializes enum payloads into a JSON "
"object, whose key is either the tag name or the string of the positional "
"index within the struct."
msgstr "**对象式** 表示将枚举负载序列化为 JSON 对象，其键是标签名称或结构体中的位置索引的字符串。"

#: ../../language/derive.md:160
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:162
msgid ""
"**Tuple-like** representation serializes enum payloads into a tuple (jSON"
" array), in the same order as the type declaration. Labels are omitted in"
" tuple-like representations."
msgstr "**元组式** 表示将枚举负载序列化为元组（JSON 数组），顺序与类型声明相同。标签在元组式表示中被省略。"

#: ../../language/derive.md:166
msgid "`[1]`, `[2, 3]`"
msgstr ""

#: ../../language/derive.md:168
msgid ""
"The two aspects can be combined freely, except one case: _internally "
"tagged_ enums cannot use _tuple-like_ representation."
msgstr "这两个方面可以自由组合，除了一个情况：_内部标记_ 枚举不能使用 _元组式_ 表示。"

#: ../../language/derive.md:171
msgid "Container arguments"
msgstr "容器参数"

#: ../../language/derive.md:173
msgid ""
"`repr(...)` configures the representation of the container. This controls"
" the tag position of enums. For structs, the tag is assumed to be the "
"type of the type."
msgstr "`repr(...)` 配置容器的表示。这控制枚举的标签位置。对于结构体，假定标签是类型的类型。"

#: ../../language/derive.md:177
msgid "There are 4 representations available for selection:"
msgstr "有 4 种可供选择的表示："

#: ../../language/derive.md:179
msgid ""
"`repr(tag = \"tag\")` – Use internally tagged representation, with the "
"tag's object key name as specified."
msgstr "`repr(tag = \"tag\")` – 使用内部标记表示，标记的对象键名称如指定。"

#: ../../language/derive.md:182
msgid "`repr(untagged)` – Use untagged representation."
msgstr "`repr(untagged)` – 使用无标记表示。"

#: ../../language/derive.md:184
msgid "`repr(ext_tagged)` – Use externally tagged representation."
msgstr "`repr(ext_tagged)` – 使用外部标记表示。"

#: ../../language/derive.md:186
msgid ""
"`repr(tag = \"tag\", contents = \"contents\")` – Use adjacently tagged "
"representation, with the tag and contents key names as specified."
msgstr "`repr(tag = \"tag\", contents = \"contents\")` – 使用相邻标记表示，标记和内容键名称如指定。"

#: ../../language/derive.md:190
msgid "The default representation for struct is `repr(untagged)`."
msgstr "结构体的默认表示为 `repr(untagged)`。"

#: ../../language/derive.md:192
msgid "The default representation for enums is `repr(tag = \"$tag\")`"
msgstr "枚举的默认表示为 `repr(tag = \"$tag\")`"

#: ../../language/derive.md:194
msgid ""
"`case_repr(...)` (enum only) configures the case representation of the "
"container. This option is only available on enums."
msgstr "`case_repr(...)`（仅枚举）配置容器的构造器表示。此选项仅适用于枚举。"

#: ../../language/derive.md:197
msgid "`case_repr(struct)` – Use struct-like representation of enums."
msgstr "`case_repr(struct)` – 使用结构体式表示的枚举。"

#: ../../language/derive.md:200
msgid "`case_repr(tuple)` – Use tuple-like representation of enums."
msgstr "`case_repr(tuple)` – 使用元组式表示的枚举。"

#: ../../language/derive.md:203
msgid ""
"`rename_fields`, `rename_cases` (enum only), `rename_struct` (struct "
"only), `rename_all` renames fields, case names, struct name and all names"
" correspondingly, into a specific style."
msgstr ""
"`rename_fields`、`rename_cases`（仅枚举）、`rename_struct`（仅结构体）、`rename_all` "
"分别将字段、构造器名称、结构体名称和所有名称重命名为特定风格。"

#: ../../language/derive.md:207
msgid "Available parameters are:"
msgstr "可选的参数有："

#: ../../language/derive.md:209
msgid "`lowercase`"
msgstr ""

#: ../../language/derive.md:210
msgid "`UPPERCASE`"
msgstr ""

#: ../../language/derive.md:211
msgid "`camelCase`"
msgstr ""

#: ../../language/derive.md:212
msgid "`PascalCase`"
msgstr ""

#: ../../language/derive.md:213
msgid "`snake_case`"
msgstr ""

#: ../../language/derive.md:214
msgid "`SCREAMING_SNAKE_CASE`"
msgstr ""

#: ../../language/derive.md:215
msgid "`kebab-case`"
msgstr ""

#: ../../language/derive.md:216
msgid "`SCREAMING-KEBAB-CASE`"
msgstr ""

#: ../../language/derive.md:218
msgid ""
"Example: `rename_fields = \"PascalCase\"` for a field named "
"`my_long_field_name` results in `MyLongFieldName`."
msgstr ""
"例如：`rename_fields = \"PascalCase\"` 用于名为 `my_long_field_name` 的字段将得到 "
"`MyLongFieldName`。"

#: ../../language/derive.md:222
msgid ""
"Renaming assumes the name of fields in `snake_case` and the name of "
"structs/enum cases in `PascalCase`."
msgstr "重命名假定字段的名称为 `snake_case`，结构体/枚举构造器的名称为 `PascalCase`。"

#: ../../language/derive.md:225
msgid "`cases(...)` (enum only) controls the layout of enum cases."
msgstr "`cases(...)`（仅枚举）控制枚举构造器的布局。"

#: ../../language/derive.md:227
msgid "For example, for an enum"
msgstr "例如，对于一个枚举"

#: ../../language/derive.md:229
msgid ""
"enum E {\n"
"  A(...)\n"
"  B(...)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:236
msgid "you are able to control each case using `cases(A(...), B(...))`."
msgstr "您可以使用 `cases(A(...), B(...))` 控制每个构造器。"

#: ../../language/derive.md:238
msgid "See [Case arguments](#case-arguments) below for details."
msgstr "有关详细信息，请参见下面的[构造器参数](#case-arguments)。"

#: ../../language/derive.md:240
msgid "`fields(...)` (struct only) controls the layout of struct fields."
msgstr "`fields(...)`（仅结构体）控制结构体字段的布局。"

#: ../../language/derive.md:242
msgid "For example, for a struct"
msgstr "例如，对于一个结构体"

#: ../../language/derive.md:244
msgid ""
"struct S {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/derive.md:251
msgid "you are able to control each field using `fields(x(...), y(...))`"
msgstr "您可以使用 `fields(x(...), y(...))` 控制每个字段。"

#: ../../language/derive.md:253 ../../language/derive.md:263
msgid "See [Field arguments](#field-arguments) below for details."
msgstr "有关详细信息，请参见下面的[字段参数](#field-arguments)。"

#: ../../language/derive.md:255
msgid "Case arguments"
msgstr "构造器参数"

#: ../../language/derive.md:257
msgid ""
"`rename = \"...\"` renames this specific case, overriding existing "
"container-wide rename directive if any."
msgstr "`rename = \"...\"` 重命名此特定构造器，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/derive.md:260
msgid ""
"`fields(...)` controls the layout of the payload of this case. Note that "
"renaming positional fields are not possible currently."
msgstr "`fields(...)` 控制此构造器的负载布局。请注意，目前无法重命名位置字段。"

#: ../../language/derive.md:265
msgid "Field arguments"
msgstr "字段参数"

#: ../../language/derive.md:267
msgid ""
"`rename = \"...\"` renames this specific field, overriding existing "
"container-wide rename directives if any."
msgstr "`rename = \"...\"` 重命名此特定字段，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/docs.md:1
msgid "Documentation"
msgstr "文档"

#: ../../language/docs.md:3
msgid "Doc Comments"
msgstr "文档注释"

#: ../../language/docs.md:5
msgid ""
"Doc comments are comments prefix with `///` in each line in the leading "
"of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc "
"comments contains a markdown text and several pragmas."
msgstr ""
"文档注释是在顶层结构（如 `fn`、`let`、`enum`、`struct`、`type`）的每一行前面加上 `///` "
"的注释。文档注释包含一个 markdown 文本和几个注解。"

#: ../../language/docs.md:7
msgid ""
"/// Return a new array with reversed elements.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"
msgstr ""
"/// 返回一个新数组，其中元素被反转。\n"
"///\n"
"/// # 示例\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"

#: ../../language/docs.md:13
msgid "Pragmas"
msgstr "注解"

#: ../../language/docs.md:15
msgid ""
"Pragmas are annotations inside doc comments. They all take the form `/// "
"@word ...`. The _word_ indicates the type of pragma and is followed "
"optionally by several _word_ or string literals. Pragmas do not normally "
"affect the meaning of programs. Unrecognized pragmas will be reported as "
"warnings."
msgstr ""
"注解是文档注释中的标记。它们都采用 `/// @word ...` 的形式。_word_ 表示注解的类型，后面可以跟几个 _word_ "
"或字符串文字。注解通常不会影响程序的含义。未识别的注解将被报告为警告。"

#: ../../language/docs.md:17
msgid "Alert Pragmas"
msgstr "警告注解"

#: ../../language/docs.md:19
msgid ""
"Alert pragmas in doc comments of functions will be reported when those "
"functions are referenced. This mechanism is a generalized way to mark "
"functions as `deprecated` or `unsafe`."
msgstr "函数文档注释中的警告注解将在引用这些函数时报告。这种机制是一种通用的方法，用于将函数标记为 `deprecated` 或 `unsafe`。"

#: ../../language/docs.md:21
msgid "It takes the form `@alert category \"alert message...\"`."
msgstr "它采用 `@alert category \"alert message...\"` 的形式。"

#: ../../language/docs.md:23
msgid ""
"The category can be an arbitrary identifier. It allows configuration to "
"decide which alerts are enabled or turned into errors."
msgstr "类别可以是任意标识符。它允许配置决定哪些警告是启用的或转换为错误。"

#: ../../language/docs.md:26
msgid ""
"/// @alert deprecated \"Use foo2 instead\"\n"
"pub fn foo() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"/// @alert unsafe \"Div will cause an error when y is zero\"\n"
"pub fn div(x : Int, y : Int) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"test {\n"
"  // Warning (Alert deprecated): Use foo2 instead\n"
"  foo()\n"
"  // Warning (Alert unsafe): Div will cause an error when y is zero\n"
"  div(1, 2) |> ignore\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:1
msgid "Error handling"
msgstr "错误处理"

#: ../../language/error-handling.md:3
msgid ""
"Error handling has always been at core of our language design. In the "
"following we'll be explaining how error handling is done in MoonBit. We "
"assume you have some prior knowledge of MoonBit, if not, please checkout "
"[A tour of MoonBit](../tutorial/tour.md)."
msgstr ""
"错误处理一直是我们语言设计的核心。接下来我们将解释 MoonBit 中的错误处理。我们假设您对 MoonBit 有一些了解，如果没有，请查看 "
"[MoonBit 之旅](../tutorial/tour.md)。"

#: ../../language/error-handling.md:7
msgid "Error types"
msgstr "错误类型"

#: ../../language/error-handling.md:9
msgid ""
"The error values used in MoonBit must have an error type. An error type "
"can be defined in the following forms:"
msgstr "MoonBit 中使用的错误值必须具有错误类型。错误类型可以用以下形式定义："

#: ../../language/error-handling.md:12
msgid ""
"type! E1 Int // error type E1 has one constructor E1 with an Int payload\n"
"\n"
"type! E2  // error type E2 has one constructor E2 with no payload\n"
"\n"
"type! E3 { // error type E3 has three constructors like a normal enum "
"type\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"
msgstr ""
"type! E1 Int  // 错误类型 E1 具有一个构造器 E1，并带有一个 Int 负载\n"
"type! E2      // 错误类型 E2 具有一个没有负载的构造器 E2\n"
"type! E3 {    // 错误类型 E3 类似于普通的枚举类型，有三个构造器\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"

#: ../../language/error-handling.md:19
msgid ""
"The return type of a function can include an error type to indicate that "
"the function might return an error. For example, the following function "
"`div` might return an error of type `DivError`:"
msgstr "函数的返回类型可以包含错误类型，以表明函数可能返回一个错误。例如，以下函数 `div` 可能返回一个类型为 `DivError` 的错误："

#: ../../language/error-handling.md:23
msgid ""
"type! DivError String\n"
"\n"
"fn div(x : Int, y : Int) -> Int!DivError {\n"
"  if y == 0 {\n"
"    raise DivError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:30
msgid ""
"Here, the keyword `raise` is used to interrupt the function execution and"
" return an error."
msgstr "这里使用了关键字 `raise` 来中断函数执行并返回一个错误。"

#: ../../language/error-handling.md:33
msgid "The Default Error Type"
msgstr "默认错误类型"

#: ../../language/error-handling.md:35
msgid ""
"MoonBit provides a default error type `Error` that can be used when the "
"concrete error type is not important. For convenience, you can annotate "
"the function name or the return type with the suffix `!` to indicate that"
" the `Error` type is used. For example, the following function signatures"
" are equivalent:"
msgstr ""
"MoonBit 提供了一个默认错误类型 `Error`，当具体的错误类型不重要时可以使用它。为了方便起见，您可以在函数名或返回类型后面加上后缀 "
"`!`，以表示使用了 `Error` 类型。例如，以下函数签名是等价的："

#: ../../language/error-handling.md:40
msgid ""
"fn f() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"fn g!() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn h() -> Unit!Error {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:47
msgid ""
"For anonymous function and matrix function, you can annotate the keyword "
"`fn` with the `!` suffix to achieve that. For example,"
msgstr "对于匿名函数和矩阵函数，您可以在关键字 `fn` 后面加上 `!` 后缀来实现这一点。例如："

#: ../../language/error-handling.md:50
msgid ""
"type! IntError Int\n"
"\n"
"fn h(f : (Int) -> Int!, x : Int) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Unit {\n"
"  let _ = h(fn! { x => raise IntError(x) }, 0)\n"
"  let _ = h(fn!(x) { raise IntError(x) }, 0)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:56
msgid ""
"As shown in the above example, the error types defined by `type!` can be "
"used as value of the type `Error` when the error is raised."
msgstr "如上例所示，`type!` 定义的错误类型可以在引发错误时作为 `Error` 类型的值使用。"

#: ../../language/error-handling.md:59
msgid ""
"Note that only error types or the type `Error` can be used as errors. For"
" functions that are generic in the error type, you can use the `Error` "
"bound to do that. For example,"
msgstr "请注意，只有错误类型或 `Error` 类型可以用作错误。对于在错误类型上是泛型的函数，您可以使用 `Error` 约束来实现。例如："

#: ../../language/error-handling.md:63
msgid ""
"// Result::unwrap_or_error\n"
"fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {\n"
"  match result {\n"
"    Ok(x) => x\n"
"    Err(e) => raise e\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:69
msgid ""
"Since the type `Error` can include multiple error types, pattern matching"
" on the `Error` type must use the wildcard `_` to match all error types. "
"For example,"
msgstr "由于 `Error` 类型可以包含多个错误类型，对 `Error` 类型进行模式匹配必须使用通配符 `_` 来匹配所有错误类型。例如："

#: ../../language/error-handling.md:72
msgid ""
"type! E4\n"
"\n"
"type! E5\n"
"\n"
"fn f(e : Error) -> Unit {\n"
"  match e {\n"
"    E4 => println(\"E1\")\n"
"    E5 => println(\"E2\")\n"
"    _ => println(\"unknown error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:78
msgid "Handling Errors"
msgstr "处理错误"

#: ../../language/error-handling.md:80
msgid "There are three ways to handle errors:"
msgstr "有三种方式可以处理错误："

#: ../../language/error-handling.md:82
msgid ""
"Append `!` after the function name in a function application to rethrow "
"the error directly in case of an error, for example:"
msgstr "在函数应用中的函数名后面附加 `!`，以便在出现错误时直接重新抛出错误，例如："

#: ../../language/error-handling.md:85
msgid ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // Rethrow the error if `div` raised an error\n"
"}\n"
msgstr ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // 如果 `div` 引发错误，则重新抛出错误\n"
"}\n"

#: ../../language/error-handling.md:91
msgid ""
"Append `?` after the function name to convert the result into a first-"
"class value of the `Result` type, for example:"
msgstr "在函数名后面附加 `?`，将结果转换为 `Result` 类型的值，例如："

#: ../../language/error-handling.md:94
msgid ""
"test {\n"
"  let res = div?(6, 3)\n"
"  inspect!(res, content=\"Ok(2)\")\n"
"  let res = div?(6, 0)\n"
"  inspect!(\n"
"    res,\n"
"    content=\n"
"      #|Err(\"division by zero\")\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:100
msgid "Use `try` and `catch` to catch and handle errors, for example:"
msgstr ""

#: ../../language/error-handling.md:102
msgid ""
"fn main {\n"
"try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  DivError(s) => println(s)\n"
"} else {\n"
"  v => println(v)\n"
"}\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:111 ../../language/fundamentals.md:117
#: ../../language/fundamentals.md:149 ../../language/fundamentals.md:176
#: ../../language/fundamentals.md:208 ../../language/fundamentals.md:600
#: ../../language/fundamentals.md:614 ../../language/fundamentals.md:628
#: ../../language/fundamentals.md:642 ../../language/fundamentals.md:654
#: ../../language/fundamentals.md:671 ../../language/fundamentals.md:709
#: ../../language/fundamentals.md:756 ../../language/fundamentals.md:770
#: ../../language/fundamentals.md:904 ../../language/fundamentals.md:940
#: ../../language/fundamentals.md:971 ../../language/fundamentals.md:998
#: ../../language/fundamentals.md:1027 ../../language/fundamentals.md:1047
#: ../../language/fundamentals.md:1081 ../../language/fundamentals.md:1095
#: ../../language/methods.md:91
msgid "Output"
msgstr "输出"

#: ../../language/error-handling.md:111
msgid "division by zero\n"
msgstr "除零"

#: ../../language/error-handling.md:115
msgid ""
"Here, `try` is used to call a function that might throw an error, and "
"`catch` is used to match and handle the caught error. If no error is "
"caught, the catch block will not be executed and the `else` block will be"
" executed instead."
msgstr ""
"这里，`try` 用于调用可能引发错误的函数，`catch` 用于匹配和处理捕获的错误。如果没有捕获到错误，`catch` 块将不会执行，而是执行"
" `else` 块。"

#: ../../language/error-handling.md:119
msgid ""
"The `else` block can be omitted if no action is needed when no error is "
"caught. For example:"
msgstr "如果不需要在没有捕获到错误时执行任何操作，则可以省略 `else` 块。例如："

#: ../../language/error-handling.md:122
msgid ""
"try {\n"
"  println(div!(42, 0))\n"
"} catch {\n"
"  _ => println(\"Error\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:129
msgid ""
"The `catch` keyword is optional, and when the body of `try` is a simple "
"expression, the curly braces can be omitted. For example:"
msgstr "`catch` 关键字是可选的，当 `try` 的主体是一个简单表达式时，大括号可以省略。例如："

#: ../../language/error-handling.md:132
msgid ""
"let a = try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  _ => 0\n"
"}\n"
"println(a)\n"
msgstr ""

#: ../../language/error-handling.md:139
msgid ""
"The `!` and `?` attributes can also be used on method invocation and pipe"
" operator. For example:"
msgstr "`!` 和 `?` 符号也可以用于方法调用和管道运算符。例如："

#: ../../language/error-handling.md:142
msgid ""
"type T Int\n"
"\n"
"type! E Int derive(Show)\n"
"\n"
"fn k(self : T) -> Unit!E {\n"
"  ...\n"
"}\n"
"\n"
"fn l() -> Unit!E {\n"
"  let x = T(42)\n"
"  k!(x)\n"
"  x.k!()\n"
"  x |> k!()\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:148
msgid ""
"However for infix operators such as `+` `*` that may raise an error, the "
"original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`."
msgstr "然而对于可能引发错误的中缀运算符，如 `+` `*`，必须使用原始形式，例如 `x.op_add!(y)`，`x.op_mul!(y)`。"

#: ../../language/error-handling.md:151
msgid ""
"Additionally, if the return type of a function includes an error type, "
"the function call must use `!` or `?` for error handling, otherwise the "
"compiler will report an error."
msgstr "此外，如果函数的返回类型包含错误类型，则函数调用必须使用 `!` 或 `?` 进行错误处理，否则编译器将报告错误。"

#: ../../language/error-handling.md:155
msgid "Error Inference"
msgstr "错误推导"

#: ../../language/error-handling.md:157
msgid ""
"Within a `try` block, several different kinds of errors can be raised. "
"When that happens, the compiler will use the type `Error` as the common "
"error type. Accordingly, the handler must use the wildcard `_` to make "
"sure all errors are caught. For example,"
msgstr ""
"在 `try` 块中，可能引发多种不同类型的错误。当发生这种情况时，编译器将使用 `Error` "
"类型作为通用错误类型。因此，处理程序必须使用通配符 `_` 来确保捕获所有错误。例如："

#: ../../language/error-handling.md:162
msgid ""
"fn f1() -> Unit!E1 {\n"
"  ...\n"
"}\n"
"\n"
"fn f2() -> Unit!E2 {\n"
"  ...\n"
"}\n"
"\n"
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch {\n"
"  E1(_) => ...\n"
"  E2 => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:169
msgid ""
"You can also use `catch!` to rethrow the uncaught errors for convenience."
" This is useful when you only want to handle a specific error and rethrow"
" others. For example,"
msgstr "您还可以使用 `catch!` 来重新抛出未捕获的错误，以方便处理。当您只想处理特定错误并重新抛出其他错误时，这很有用。例如："

#: ../../language/error-handling.md:173
msgid ""
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch! {\n"
"  E1(_) => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:180
msgid "Example: Division by Zero"
msgstr "示例：除零"

#: ../../language/error-handling.md:182
msgid ""
"We'll write a small example to demonstrate the basics of MoonBit's error "
"handling system. Consider the following `div` function which'll raise an "
"error on division by zero:"
msgstr "我们将编写一个小例子来演示 MoonBit 错误处理系统的基础知识。考虑以下 `div` 函数，它将在除零时引发错误："

#: ../../language/error-handling.md:186
msgid ""
"type! DivisionByZeroError String\n"
"fn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  if y == 0 {\n"
"    raise DivisionByZeroError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:196
msgid ""
"In before, we would typically use `type` to define a wrapper type which "
"wraps around some existing foreign type. Here however, we append `type` "
"with `!` to define a error type `DivisionByZeroError` which wraps around "
"`String`."
msgstr ""
"在以前，我们通常使用 `type` 来定义一个包装器类型，该类型包装了某些现有的外部类型。然而，在这里，我们使用 `!` 将 `type` 附加到"
" `DivisionByZeroError`，以定义一个错误类型，该类型包装了 `String`。"

#: ../../language/error-handling.md:200
msgid "`type! E S` construct a error type `E` from `S`"
msgstr "`type! E S` 从 `S` 构造一个错误类型 `E`"

#: ../../language/error-handling.md:202
msgid ""
"Just like `type`, `type!` may have a payload like the above "
"`DivisionByZeroError`, or may not, or may even have multiple constructors"
" like a normal `enum`:"
msgstr ""
"就像 `type` 一样，`type!` 可能有一个像上面的 `DivisionByZeroError` 那样的数据，也可能没有，甚至可能像普通的"
" `enum` 一样有多个构造器："

#: ../../language/error-handling.md:204
msgid ""
"type! ConnectionError {\n"
"  BrokenPipe(Int,String)\n"
"  ConnectionReset\n"
"  ConnectionAbort\n"
"  ConnectionRefused\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:213
msgid ""
"To utilize `DivisionByZeroError` type, we would usually define a function"
" which may raise error by denoting its return type like `T ! E` in the "
"signature, with `T` being the actual return type and `E` being the error "
"type. In this case, it's `Int!DivisionByZeroError`. The error can be "
"thrown using `raise e` where `e` is an instance of `E` which can be "
"constructed using the default constructor of `S`."
msgstr ""
"要使用 `DivisionByZeroError` 类型，我们通常会定义一个函数，该函数通过在签名中定义返回类型为 `T ! E` "
"来表示它会引发错误，其中 `T` 是实际的返回类型，`E` 是错误类型。在这个例子中，它是 "
"`Int!DivisionByZeroError`。错误可以使用 `raise e` 抛出，其中 `e` 是 `E` 的实例，可以使用 `S` "
"的默认构造器构造。"

#: ../../language/error-handling.md:220
msgid ""
"Any instance of an error is a second class object. Meaning it may only "
"appear in the return value. And if it does appear, the function signature"
" has to be adjusted to match with the return type."
msgstr "任何错误的实例都是一个二等公民对象。这意味着它只能出现在返回值中。如果返回值包含错误，函数签名必须调整以匹配返回类型。"

#: ../../language/error-handling.md:224
msgid ""
"The `test` block in MoonBit may also be seen as a function, with a return"
" type of Unit!Error."
msgstr "MoonBit 中的 `test` 块也可以看作是一个函数，返回类型为 Unit!Error。"

#: ../../language/error-handling.md:227
msgid "Calling an error-able function"
msgstr "调用一个可出错的函数"

#: ../../language/error-handling.md:229
msgid ""
"an error-able function is usually called in 2 manners: `f!(...)` and "
"`f?(...)`."
msgstr "一个可出错的函数通常有两种调用方式：`f!(...)` 和 `f?(...)`。"

#: ../../language/error-handling.md:231
msgid "As-is calling"
msgstr "直接调用"

#: ../../language/error-handling.md:233
msgid ""
"`f!(...)` calls the function directly. The possible error must be dealt "
"in the function that calls `f`. We can either re-raising it without "
"actually dealing with the error:"
msgstr "`f!(...)` 直接调用函数。可能的错误必须在调用 `f` 的函数中处理。我们可以重新抛出它，而不实际处理错误："

#: ../../language/error-handling.md:237
msgid ""
"// We have to match the error type of `div2` with `div`\n"
"fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  div!(x,y)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:244
msgid "or use `try...catch` block like in many other languages:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error-handling.md:246
msgid ""
"fn div3(x : Int, y : Int) -> Unit {\n"
"  try {\n"
"    div!(x, y)\n"
"  } catch { // `catch` and `except` works the same.\n"
"    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n"
"  } else {\n"
"    v => println(v)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:258
msgid ""
"The `catch...` clause has similar semantics like pattern matching. We can"
" unwrap the error to retrieve the underlying `String` and print it. "
"Additionally, there's an `else` clause to handle the value of `try...` "
"block."
msgstr ""
"`catch...` 子句的语义类似于模式匹配。我们可以解包错误以检索底层的 `String` 并打印它。此外，还有一个 `else` 子句来处理"
" `try...` 块的值。"

#: ../../language/error-handling.md:262
msgid ""
"fn test_try() -> Result[Int, Error] {\n"
"  // compiler can figure out the type of a local error-able function.\n"
"  fn f() -> _!_ {\n"
"    raise Failure(\"err\")\n"
"  }\n"
"\n"
"  try Ok(f!()) { err => Err(err) }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:273
msgid ""
"Curly braces may be omitted if the body of try is a one-liner "
"(expression). The `catch` keyword can also be omitted as well. In the "
"case where a `try` body would raise different errors, the special "
"`catch!` can be used to catch some of the errors, while re-raising other "
"uncaught errors:"
msgstr ""
"如果 `try` 的主体是一行代码（表达式），则大括号可以省略。`catch` 关键字也可以省略。在 `try` "
"主体可能引发不同错误的情况下，可以使用特殊的 `catch!` 来捕获一些错误，同时重新抛出其他未捕获的错误："

#: ../../language/error-handling.md:277
msgid ""
"type! E1\n"
"type! E2\n"
"fn f1() -> Unit!E1 { raise E1 }\n"
"fn f2() -> Unit!E2 { raise E2 }\n"
"fn f() -> Unit! {\n"
"  try {\n"
"    f1!()\n"
"    f2!()\n"
"  } catch! {\n"
"    E1 => println(\"E1\")\n"
"    // E2 gets re-raised.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:293
msgid "Convert to Result"
msgstr "转换为 Result"

#: ../../language/error-handling.md:295
msgid "Extracting values"
msgstr "提取值"

#: ../../language/error-handling.md:297
msgid ""
"A object of type `Result` is a first class value in MoonBit. `Result` has"
" 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first"
" class object and the latter accept a error object."
msgstr ""
"`Result` 类型的对象是 MoonBit 中的一等公民。`Result` 有 2 个构造器：`Ok(...)` 和 "
"`Err(...)`，前者接受一个一等公民对象，后者接受一个错误对象。"

#: ../../language/error-handling.md:299
msgid ""
"With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We "
"may use pattern matching to extract value from it:"
msgstr "使用 `f?(...)`，返回类型 `T!E` 被转换为 `Result[T,E]`。我们可以使用模式匹配从中提取值："

#: ../../language/error-handling.md:301
msgid ""
"let res = div?(10, 0)\n"
"match res {\n"
"  Ok(x) => println(x)\n"
"  Err(DivisionByZeroError(e)) => println(e)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:309
msgid "the `f?()` is basically a syntactic sugar for"
msgstr "`f?()` 基本上是一个语法糖，等价于"

#: ../../language/error-handling.md:311
msgid ""
"let res = try {\n"
"  Ok(div!(10, 0))\n"
"} catch {\n"
"  s => Err(s)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:319
msgid ""
"Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is"
" equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able "
"function `f`."
msgstr ""
"注意 `T?` 和 `f?(...)` 之间的区别：`T` 是一个类型，`T?` 等价于 `Option[T]`，而 `f?(...)` "
"是对可出错函数 `f` 的调用。"

#: ../../language/error-handling.md:323
msgid ""
"Besides pattern matching, `Result` provides some useful methods to deal "
"with possible error:"
msgstr "除了模式匹配，`Result` 还提供了一些有用的方法来处理可能的错误："

#: ../../language/error-handling.md:325
msgid ""
"let res1: Result[Int, String] = Err(\"error\")\n"
"let value = res1.or(0) // 0\n"
"\n"
"let res2: Result[Int, String] = Ok(42)\n"
"let value = res2.unwrap() // 42\n"
msgstr ""

#: ../../language/error-handling.md:333
msgid ""
"`or` returns the value if the result is `Ok` or a default value if it is "
"`Err`"
msgstr "`or` 如果结果是 `Ok`，则返回值，如果是 `Err`，则返回默认值"

#: ../../language/error-handling.md:334
msgid "`unwrap` panics if the result is `Err` and return the value if it is `Ok`"
msgstr "`unwrap` 如果结果是 `Err`，则会崩溃，如果是 `Ok`，则返回值"

#: ../../language/error-handling.md:336
msgid "Mapping values"
msgstr "映射值"

#: ../../language/error-handling.md:338
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n"
msgstr ""

#: ../../language/error-handling.md:346
msgid ""
"`map` applies a function to the value within, except it doesn't nothing "
"if result is `Err`."
msgstr "`map` 将函数应用于内部的值；如果结果是 `Err`，则不执行任何操作。"

#: ../../language/error-handling.md:347
msgid "`map_err` does the opposite."
msgstr "`map_err` 则相反。"

#: ../../language/error-handling.md:349
msgid ""
"Unlike some languages, MoonBit treats error-able and nullable value "
"differently. Although one might treat them analogously, as an `Err` "
"result contains no value, only the error, which is like `null`. MoonBit "
"knows that."
msgstr ""
"与一些语言不同，MoonBit 对可出错值和可空值进行了区分。尽管有些人可能将它们类比对待，因为一个不包含值的 `Err` 对象就像 "
"`null`。MoonBit 知道这一点。"

#: ../../language/error-handling.md:351
msgid "`to_option` converts a `Result` to `Option`."
msgstr "`to_option` 将 `Result` 转换为 `Option`。"

#: ../../language/error-handling.md:353
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let option = res1.to_option() // Some(42)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let option1 = res2.to_option() // None\n"
msgstr ""

#: ../../language/error-handling.md:361
msgid "Built-in error type and functions"
msgstr "内置错误类型和相关函数"

#: ../../language/error-handling.md:363
msgid "In MoonBit, `Error` is a generalized error type:"
msgstr "在 MoonBit 中，`Error` 是一个通用的错误类型："

#: ../../language/error-handling.md:365
msgid ""
"// These signatures are equivalent. They all raise Error.\n"
"fn f() -> Unit! { .. }\n"
"fn f!() -> Unit { .. }\n"
"fn f() -> Unit!Error { .. }\n"
"\n"
"fn test_error() -> Result[Int, Error] {\n"
"  fn f() -> _!_ {\n"
"    raise DivisionByZeroError(\"err\")\n"
"  }\n"
"\n"
"  try {\n"
"    Ok(f!())\n"
"  } catch {\n"
"    err => Err(err)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:384
msgid ""
"Although the constructor `Err` expects a type of `Error`, we may still "
"pass an error of type `DivisionByZeroError` to it."
msgstr "尽管构造器 `Err` 期望一个 `Error` 类型，我们仍然可以将 `DivisionByZeroError` 类型的错误传递给它。"

#: ../../language/error-handling.md:387
msgid ""
"But `Error` can't be constructed directly. It's meant to be passed "
"around, not used directly:"
msgstr "但是 `Error` 不能直接构造。它是用来传递的，而不是直接使用："

#: ../../language/error-handling.md:389
msgid ""
"type! ArithmeticError\n"
"\n"
"fn what_error_is_this(e : Error) -> Unit {\n"
"  match e {\n"
"    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n"
"    ArithmeticError => println(\"ArithmeticError\")\n"
"    ... => println(\"...\")\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:402
msgid ""
"`Error` is typically used where concrete error type is not needed, or "
"simply act as a catch-all for all kinds of sub-errors."
msgstr "`Error` 通常用于不需要具体错误类型的情况，或者简单地用来捕获所有的子错误。"

#: ../../language/error-handling.md:405
msgid ""
"As `Error` includes multiple error types, partial matching is not allowed"
" here. We have to do exhaustive matching by providing a catch-"
"all/wildcard case `_`."
msgstr "由于 `Error` 包含多种错误类型，这里不允许部分匹配。我们必须通过提供一个通配符 `_` 来进行兜底匹配。"

#: ../../language/error-handling.md:407
msgid ""
"We usually use the builtin `Failure` error type for a generalized error, "
"and by generalized we mean using it for trivial errors that doesn't need "
"a new error type."
msgstr "我们通常使用内置的 `Failure` 错误类型来表示通用错误：通用意味着它用于不值得单独定义类型的错误。"

#: ../../language/error-handling.md:410
msgid ""
"fn div_trivial(x : Int, y : Int) -> Int!Failure {\n"
"  if y == 0 {\n"
"    raise Failure(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:419
msgid ""
"Besides using the constructor directly, the function `fail!` provides a "
"shorthand to construct a `Failure`. And if we take a look at the source "
"code:"
msgstr "除了直接使用构造器，函数 `fail!` 提供了一个快捷方式来构造 `Failure`。如果我们查看源代码："

#: ../../language/error-handling.md:422
msgid ""
"pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n"
"  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:428
msgid ""
"We can see that `fail` is merely a constructor with a pre-defined output "
"template for showing both the error and the source location. In practice,"
" `fail!` is always preferred over `Failure`."
msgstr "我们可以看到 `fail` 只是一个带有预定义输出模板的构造函数，用于显示错误和源位置。在实践中，`fail!` 总是比 `Failure`更常用。"

#: ../../language/error-handling.md:432
msgid ""
"Other functions used to break control flow are `abort` and `panic`. They "
"are equivalent. An `panic` at any place will manually crash the program "
"at that place, and prints out stack trace."
msgstr ""
"其他用于打破控制流的函数有 `abort` 和 `panic`。它们是等效的。在任何地方的 `panic` "
"都会手动在那个地方崩溃程序，并打印出堆栈跟踪。"

#: ../../language/error_codes/E0001.md:1
msgid "E0001"
msgstr ""

#: ../../language/error_codes/E0001.md:3
msgid ""
"There is an internal error occurred to the compiler. Usually this means "
"you have discovered a bug in the compiler."
msgstr ""

#: ../../language/error_codes/E0001.md:6
msgid ""
"A bug report containing the error description and relevant code would be "
"greatly appreciated. You can submit the bug report here:"
msgstr ""

#: ../../language/error_codes/E0001.md:9 ../../language/error_codes/E4048.md:9
#: ../../language/error_codes/E4049.md:11
msgid "<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug,ICE>"
msgstr ""

#: ../../language/error_codes/E1001.md:1
msgid "E1001"
msgstr ""

#: ../../language/error_codes/E1001.md:3
msgid "Unused function."
msgstr "内联函数"

#: ../../language/error_codes/E1001.md:5
msgid ""
"This function is not used by any other part of your code, nor marked with"
" `pub` visibility."
msgstr ""

#: ../../language/error_codes/E1001.md:8
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two functions in your codebase that has similar "
"name, you might just call the other function by mistake."
msgstr ""

#: ../../language/error_codes/E1001.md:12
#: ../../language/error_codes/E1002.md:15
#: ../../language/error_codes/E1003.md:16 ../../language/error_codes/E1005.md:9
#: ../../language/error_codes/E1006.md:11 ../../language/error_codes/E1007.md:6
#: ../../language/error_codes/E1008.md:6 ../../language/error_codes/E1009.md:5
#: ../../language/error_codes/E1010.md:10 ../../language/error_codes/E1011.md:6
#: ../../language/error_codes/E1012.md:7 ../../language/error_codes/E1013.md:18
#: ../../language/error_codes/E1014.md:5 ../../language/error_codes/E1015.md:8
#: ../../language/error_codes/E1018.md:12
#: ../../language/error_codes/E1019.md:11
#: ../../language/error_codes/E1020.md:30 ../../language/error_codes/E1021.md:5
#: ../../language/error_codes/E1022.md:8 ../../language/error_codes/E1023.md:5
#: ../../language/error_codes/E1024.md:5 ../../language/error_codes/E1026.md:8
#: ../../language/error_codes/E1028.md:5 ../../language/error_codes/E1029.md:5
#: ../../language/error_codes/E1030.md:5 ../../language/error_codes/E1031.md:7
#: ../../language/error_codes/E1032.md:5 ../../language/error_codes/E1033.md:10
#: ../../language/error_codes/E1035.md:29
#: ../../language/error_codes/E1036.md:13 ../../language/error_codes/E1037.md:5
#: ../../language/error_codes/E1038.md:13
#: ../../language/error_codes/E1039.md:11 ../../language/error_codes/E1040.md:7
#: ../../language/error_codes/E2000.md:17 ../../language/error_codes/E3001.md:5
#: ../../language/error_codes/E3002.md:5 ../../language/error_codes/E3003.md:5
#: ../../language/error_codes/E3004.md:6 ../../language/error_codes/E3005.md:11
#: ../../language/error_codes/E3006.md:7 ../../language/error_codes/E3007.md:5
#: ../../language/error_codes/E3008.md:5 ../../language/error_codes/E3009.md:5
#: ../../language/error_codes/E3010.md:5 ../../language/error_codes/E3011.md:6
#: ../../language/error_codes/E3012.md:6 ../../language/error_codes/E3014.md:8
#: ../../language/error_codes/E3015.md:25 ../../language/error_codes/E3016.md:5
#: ../../language/error_codes/E3017.md:9 ../../language/error_codes/E3018.md:5
#: ../../language/error_codes/E3019.md:10 ../../language/error_codes/E3020.md:6
#: ../../language/error_codes/E3800.md:10 ../../language/error_codes/E4000.md:5
#: ../../language/error_codes/E4005.md:5 ../../language/error_codes/E4007.md:8
#: ../../language/error_codes/E4050.md:9 ../../language/error_codes/E4051.md:15
#: ../../language/error_codes/E4052.md:7 ../../language/error_codes/E4053.md:18
#: ../../language/error_codes/E4055.md:5 ../../language/error_codes/E4056.md:5
#: ../../language/error_codes/E4057.md:5 ../../language/error_codes/E4059.md:9
#: ../../language/error_codes/E4060.md:13
#: ../../language/error_codes/E4061.md:18
#: ../../language/error_codes/E4062.md:37
#: ../../language/error_codes/E4063.md:13
#: ../../language/error_codes/E4065.md:27 ../../language/error_codes/E4066.md:9
#: ../../language/error_codes/E4067.md:11
#: ../../language/error_codes/E4068.md:11
#: ../../language/error_codes/E4069.md:15 ../../language/error_codes/E4070.md:8
#: ../../language/error_codes/E4071.md:9 ../../language/error_codes/E4072.md:5
#: ../../language/error_codes/E4073.md:12
#: ../../language/error_codes/E4074.md:18 ../../language/error_codes/E4075.md:7
#: ../../language/error_codes/E4076.md:9 ../../language/error_codes/E4077.md:9
#: ../../language/error_codes/E4078.md:9 ../../language/error_codes/E4079.md:8
#: ../../language/error_codes/E4080.md:5 ../../language/error_codes/E4086.md:12
#: ../../language/error_codes/E4088.md:9 ../../language/error_codes/E4089.md:11
#: ../../language/error_codes/E4090.md:6 ../../language/error_codes/E4091.md:8
#: ../../language/error_codes/E4093.md:8 ../../language/error_codes/E4094.md:8
#: ../../language/error_codes/E4095.md:18 ../../language/error_codes/E4100.md:9
#: ../../language/error_codes/E4101.md:16
#: ../../language/error_codes/E4102.md:14
#: ../../language/error_codes/E4103.md:13
#: ../../language/error_codes/E4104.md:25
#: ../../language/error_codes/E4105.md:23
#: ../../language/error_codes/E4106.md:11
#: ../../language/error_codes/E4107.md:10
#: ../../language/error_codes/E4108.md:25 ../../language/error_codes/E4109.md:8
#: ../../language/error_codes/E4110.md:21 ../../language/error_codes/E4111.md:8
#: ../../language/error_codes/E4112.md:8 ../../language/error_codes/E4113.md:16
#: ../../language/error_codes/E4114.md:8 ../../language/error_codes/E4115.md:9
#: ../../language/error_codes/E4116.md:9 ../../language/error_codes/E4117.md:7
#: ../../language/error_codes/E4118.md:8 ../../language/error_codes/E4119.md:5
#: ../../language/error_codes/E4120.md:11
#: ../../language/error_codes/E4121.md:13
#: ../../language/error_codes/E4122.md:14 ../../language/error_codes/E4124.md:5
#: ../../language/error_codes/E4125.md:13 ../../language/error_codes/E4127.md:8
#: ../../language/error_codes/E4128.md:5 ../../language/error_codes/E4129.md:5
#: ../../language/error_codes/E4130.md:10
#: ../../language/error_codes/E4131.md:10 ../../language/error_codes/E4132.md:5
#: ../../language/error_codes/E4133.md:11 ../../language/error_codes/E4134.md:6
#: ../../language/error_codes/E4135.md:9 ../../language/error_codes/E4136.md:9
#: ../../language/error_codes/E4137.md:8 ../../language/error_codes/E4138.md:6
#: ../../language/error_codes/E4139.md:8 ../../language/error_codes/E4140.md:13
#: ../../language/error_codes/E4141.md:11
#: ../../language/error_codes/E4142.md:11
#: ../../language/error_codes/E4143.md:13
#: ../../language/error_codes/E4144.md:10 ../../language/error_codes/E4145.md:8
#: ../../language/error_codes/E4146.md:8 ../../language/error_codes/E4147.md:10
#: ../../language/error_codes/E4148.md:9 ../../language/error_codes/E4149.md:7
#: ../../language/error_codes/E4150.md:9
msgid "Erroneous example"
msgstr "错误示例"

#: ../../language/error_codes/E1001.md:14
msgid ""
"fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
"\n"
"fn main {\n"
"  fn local_greeting() -> String {\n"
"    \"Hello, world!\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:26
#: ../../language/error_codes/E1002.md:31
#: ../../language/error_codes/E1003.md:30
#: ../../language/error_codes/E1005.md:24
#: ../../language/error_codes/E1006.md:28
#: ../../language/error_codes/E1007.md:37
#: ../../language/error_codes/E1008.md:22
#: ../../language/error_codes/E1009.md:23
#: ../../language/error_codes/E1010.md:21
#: ../../language/error_codes/E1011.md:17
#: ../../language/error_codes/E1012.md:16
#: ../../language/error_codes/E1013.md:59
#: ../../language/error_codes/E1014.md:14
#: ../../language/error_codes/E1015.md:18
#: ../../language/error_codes/E1018.md:25
#: ../../language/error_codes/E1019.md:17
#: ../../language/error_codes/E1020.md:40
#: ../../language/error_codes/E1021.md:22
#: ../../language/error_codes/E1022.md:22
#: ../../language/error_codes/E1023.md:17
#: ../../language/error_codes/E1024.md:13
#: ../../language/error_codes/E1026.md:34
#: ../../language/error_codes/E1028.md:13
#: ../../language/error_codes/E1029.md:50
#: ../../language/error_codes/E1030.md:19
#: ../../language/error_codes/E1031.md:33
#: ../../language/error_codes/E1032.md:30
#: ../../language/error_codes/E1033.md:51
#: ../../language/error_codes/E1035.md:37
#: ../../language/error_codes/E1036.md:29
#: ../../language/error_codes/E1037.md:24
#: ../../language/error_codes/E1038.md:28
#: ../../language/error_codes/E1039.md:30
#: ../../language/error_codes/E1040.md:25
#: ../../language/error_codes/E2000.md:39
#: ../../language/error_codes/E3001.md:23
#: ../../language/error_codes/E3002.md:21
#: ../../language/error_codes/E3003.md:13
#: ../../language/error_codes/E3004.md:14
#: ../../language/error_codes/E3005.md:17
#: ../../language/error_codes/E3006.md:16
#: ../../language/error_codes/E3007.md:22
#: ../../language/error_codes/E3008.md:16
#: ../../language/error_codes/E3009.md:22
#: ../../language/error_codes/E3010.md:14
#: ../../language/error_codes/E3011.md:16
#: ../../language/error_codes/E3012.md:29
#: ../../language/error_codes/E3014.md:16
#: ../../language/error_codes/E3015.md:33
#: ../../language/error_codes/E3016.md:21
#: ../../language/error_codes/E3017.md:18
#: ../../language/error_codes/E3018.md:17
#: ../../language/error_codes/E3019.md:23
#: ../../language/error_codes/E3020.md:21
#: ../../language/error_codes/E3800.md:26
#: ../../language/error_codes/E4000.md:17
#: ../../language/error_codes/E4001.md:28
#: ../../language/error_codes/E4002.md:20
#: ../../language/error_codes/E4003.md:18
#: ../../language/error_codes/E4004.md:14
#: ../../language/error_codes/E4005.md:14
#: ../../language/error_codes/E4006.md:21
#: ../../language/error_codes/E4007.md:21
#: ../../language/error_codes/E4008.md:14
#: ../../language/error_codes/E4009.md:21
#: ../../language/error_codes/E4010.md:19
#: ../../language/error_codes/E4011.md:18
#: ../../language/error_codes/E4013.md:21
#: ../../language/error_codes/E4014.md:16
#: ../../language/error_codes/E4015.md:18
#: ../../language/error_codes/E4016.md:22
#: ../../language/error_codes/E4017.md:26
#: ../../language/error_codes/E4018.md:22
#: ../../language/error_codes/E4019.md:20
#: ../../language/error_codes/E4020.md:19
#: ../../language/error_codes/E4021.md:19
#: ../../language/error_codes/E4023.md:19
#: ../../language/error_codes/E4024.md:19
#: ../../language/error_codes/E4025.md:23
#: ../../language/error_codes/E4026.md:18
#: ../../language/error_codes/E4027.md:19
#: ../../language/error_codes/E4028.md:19
#: ../../language/error_codes/E4030.md:21
#: ../../language/error_codes/E4031.md:19
#: ../../language/error_codes/E4033.md:21
#: ../../language/error_codes/E4034.md:22
#: ../../language/error_codes/E4036.md:32
#: ../../language/error_codes/E4037.md:53
#: ../../language/error_codes/E4038.md:30
#: ../../language/error_codes/E4039.md:18
#: ../../language/error_codes/E4040.md:20
#: ../../language/error_codes/E4041.md:15
#: ../../language/error_codes/E4042.md:20
#: ../../language/error_codes/E4043.md:32
#: ../../language/error_codes/E4044.md:22
#: ../../language/error_codes/E4045.md:22
#: ../../language/error_codes/E4046.md:20
#: ../../language/error_codes/E4050.md:19
#: ../../language/error_codes/E4051.md:47
#: ../../language/error_codes/E4052.md:14
#: ../../language/error_codes/E4053.md:53
#: ../../language/error_codes/E4055.md:14
#: ../../language/error_codes/E4056.md:22
#: ../../language/error_codes/E4057.md:14
#: ../../language/error_codes/E4059.md:34
#: ../../language/error_codes/E4060.md:30
#: ../../language/error_codes/E4061.md:62
#: ../../language/error_codes/E4062.md:81
#: ../../language/error_codes/E4063.md:34
#: ../../language/error_codes/E4065.md:43
#: ../../language/error_codes/E4066.md:18
#: ../../language/error_codes/E4067.md:33
#: ../../language/error_codes/E4068.md:35
#: ../../language/error_codes/E4069.md:33
#: ../../language/error_codes/E4070.md:19
#: ../../language/error_codes/E4071.md:21
#: ../../language/error_codes/E4072.md:23
#: ../../language/error_codes/E4073.md:49
#: ../../language/error_codes/E4074.md:53
#: ../../language/error_codes/E4075.md:14
#: ../../language/error_codes/E4076.md:16
#: ../../language/error_codes/E4077.md:19
#: ../../language/error_codes/E4078.md:15
#: ../../language/error_codes/E4079.md:18
#: ../../language/error_codes/E4080.md:33
#: ../../language/error_codes/E4081.md:21
#: ../../language/error_codes/E4082.md:24
#: ../../language/error_codes/E4084.md:17
#: ../../language/error_codes/E4085.md:23
#: ../../language/error_codes/E4086.md:24
#: ../../language/error_codes/E4087.md:20
#: ../../language/error_codes/E4088.md:23
#: ../../language/error_codes/E4089.md:20
#: ../../language/error_codes/E4090.md:16
#: ../../language/error_codes/E4091.md:22
#: ../../language/error_codes/E4093.md:23
#: ../../language/error_codes/E4094.md:56
#: ../../language/error_codes/E4095.md:26
#: ../../language/error_codes/E4100.md:22
#: ../../language/error_codes/E4101.md:33
#: ../../language/error_codes/E4102.md:38
#: ../../language/error_codes/E4103.md:25
#: ../../language/error_codes/E4104.md:50
#: ../../language/error_codes/E4105.md:39
#: ../../language/error_codes/E4106.md:27
#: ../../language/error_codes/E4107.md:21
#: ../../language/error_codes/E4108.md:43
#: ../../language/error_codes/E4109.md:23
#: ../../language/error_codes/E4110.md:33
#: ../../language/error_codes/E4111.md:21
#: ../../language/error_codes/E4112.md:21
#: ../../language/error_codes/E4113.md:34
#: ../../language/error_codes/E4114.md:20
#: ../../language/error_codes/E4115.md:17
#: ../../language/error_codes/E4116.md:17
#: ../../language/error_codes/E4118.md:23
#: ../../language/error_codes/E4119.md:15
#: ../../language/error_codes/E4120.md:28
#: ../../language/error_codes/E4121.md:33
#: ../../language/error_codes/E4122.md:50
#: ../../language/error_codes/E4124.md:25
#: ../../language/error_codes/E4125.md:35
#: ../../language/error_codes/E4127.md:18
#: ../../language/error_codes/E4128.md:11
#: ../../language/error_codes/E4129.md:12
#: ../../language/error_codes/E4130.md:20
#: ../../language/error_codes/E4131.md:22
#: ../../language/error_codes/E4132.md:13
#: ../../language/error_codes/E4133.md:21
#: ../../language/error_codes/E4134.md:28
#: ../../language/error_codes/E4135.md:34
#: ../../language/error_codes/E4136.md:30
#: ../../language/error_codes/E4137.md:16
#: ../../language/error_codes/E4138.md:17
#: ../../language/error_codes/E4139.md:21
#: ../../language/error_codes/E4140.md:19
#: ../../language/error_codes/E4141.md:24
#: ../../language/error_codes/E4142.md:17
#: ../../language/error_codes/E4143.md:19
#: ../../language/error_codes/E4144.md:24
#: ../../language/error_codes/E4145.md:48
#: ../../language/error_codes/E4146.md:20
#: ../../language/error_codes/E4147.md:24
#: ../../language/error_codes/E4148.md:30
#: ../../language/error_codes/E4149.md:19
#: ../../language/error_codes/E4150.md:21
msgid "Suggestion"
msgstr "建议"

#: ../../language/error_codes/E1001.md:28
#: ../../language/error_codes/E1002.md:33
#: ../../language/error_codes/E1003.md:32
msgid "There are multiple ways to fix this warning:"
msgstr "有几种方式可以修复这个警告："

#: ../../language/error_codes/E1001.md:30
msgid ""
"If the function is indeed useless, you can remove the definition of the "
"function."
msgstr "如果这个函数确实没有用，你可以移除函数的定义"

#: ../../language/error_codes/E1001.md:32
msgid ""
"If this function is at the toplevel (i.e., not local), and is part of the"
" public API of your module, you can add the `pub` keyword to the "
"function."
msgstr "如果这个函数是在顶层（即不是局部的），并且是你模块的公开 API 的一部分，你可以给函数添加 `pub` 关键字。"

#: ../../language/error_codes/E1001.md:35
msgid ""
"pub fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:41
msgid ""
"If you made a typo in the function name, you can rename the function to "
"the correct name at the call site."
msgstr "如果你在函数名上犯了拼写错误，你可以在调用的地方将函数重命名为正确的名字。"

#: ../../language/error_codes/E1001.md:44
msgid ""
"There are some cases where you might want to keep the function private "
"and unused at the same time. In this case, you can call `ignore()` on the"
" function to force the use of it."
msgstr "在某些情况下，你可能想要保持函数为私有且同时不使用。在这种情况下，你可以对该函数调用 `ignore()` 以强制使用它。"

#: ../../language/error_codes/E1001.md:48
msgid ""
"fn greeting() -> String {\n"
"  \"Hello, world!\"\n"
"}\n"
"\n"
"fn init {\n"
"  ignore(greeting)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:58
msgid ""
"fn main {\n"
"  fn local_greeting() -> String {\n"
"    \"Hello, world!\"\n"
"  }\n"
"  ignore(local_greeting)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:1
msgid "E1002"
msgstr ""

#: ../../language/error_codes/E1002.md:3
msgid "Unused variable."
msgstr "未使用的变量。"

#: ../../language/error_codes/E1002.md:5
msgid ""
"This variable is unused by any other part of your code, nor marked with "
"`pub` visibility."
msgstr "这个变量未被代码的其他部分使用，也没有标记 `pub` 可见性。"

#: ../../language/error_codes/E1002.md:8
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two variables in your codebase that has similar "
"name, you might just use the other variable by mistake."
msgstr "请注意，这个警告可能会揭示你代码中的其他错误。例如，如果你的代码库中有两个变量名称相似，你可能会错误地使用另一个变量。"

#: ../../language/error_codes/E1002.md:12
msgid ""
"Specifically, if the variable is at the toplevel, and the body of the "
"module contains side effects, the side effects will not happen."
msgstr "具体来说，如果变量是在顶层，并且模块的主体包含副作用，则这些副作用将不会发生。"

#: ../../language/error_codes/E1002.md:17
msgid ""
"let p : Int = {\n"
"//  ^ Warning: Unused toplevel variable 'p'.\n"
"//             Note if the body contains side effect, it will not happen."
"\n"
"//             Use `fn init { .. }` to wrap the effect.\n"
"  println(\"Side effect\")\n"
"  42\n"
"}\n"
"\n"
"fn main {\n"
"  let x = 42 // Warning: Unused variable 'x'\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:35
msgid ""
"If the variable is indeed useless, you can remove the definition of the "
"variable."
msgstr "如果这个变量确实没有用，你可以移除变量的定义。"

#: ../../language/error_codes/E1002.md:37
msgid ""
"If this variable is at the toplevel (i.e., not local), and is part of the"
" public API of your module, you can add the `pub` keyword to the "
"variable."
msgstr "如果这个变量是在顶层（即不是局部的），并且是你模块的公开 API 的一部分，你可以给变量添加 `pub` 关键字。"

#: ../../language/error_codes/E1002.md:40
msgid "pub let p = 42\n"
msgstr ""

#: ../../language/error_codes/E1002.md:44
msgid ""
"If you made a typo in the variable name, you can rename the variable to "
"the correct name at the use site."
msgstr "如果你在变量名上犯了拼写错误，你可以在使用的地方将变量重命名为正确的名字。"

#: ../../language/error_codes/E1002.md:46
msgid ""
"If your code depends on the side-effect of the variable, you can wrap the"
" side-effect in a `fn init` block."
msgstr "如果你的代码依赖于变量的副作用，你可以将副作用包装在 `fn init` 块中。"

#: ../../language/error_codes/E1002.md:49
msgid ""
"fn init {\n"
"  println(\"Side effect\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:55
msgid ""
"There are some cases where you might want to keep the variable private "
"and unused at the same time. In this case, you can call `ignore()` on the"
" variable to force the use of it."
msgstr "在某些情况下，你可能想要保持变量为私有且同时不使用。在这种情况下，你可以对该变量调用 `ignore()` 以强制使用它。"

#: ../../language/error_codes/E1002.md:59
msgid ""
"let p : Int = {\n"
"  println(\"Side effect\")\n"
"  42\n"
"}\n"
"\n"
"fn init {\n"
"  ignore(p)\n"
"}\n"
"\n"
"fn main {\n"
"  let x = 42\n"
"  ignore(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:1
msgid "E1003"
msgstr ""

#: ../../language/error_codes/E1003.md:3
msgid "Unused type declaration."
msgstr "未使用的类型声明。"

#: ../../language/error_codes/E1003.md:5
msgid ""
"This type is not used by any other part of your code, and it is private. "
"Type declaration is by default abstract, which means it is publicly "
"visible to users of this package, but they cannot see the implementation "
"of the type, nor can create instances of it directly. Therefore, this "
"warning is only shown if the type is marked with `priv` visibility, and "
"is not used by any other part of this package."
msgstr ""
"这个类型没有被代码的其他部分使用，而且它是私有的。类型声明默认是抽象的，这意味着它对这个包的用户是公开可见的，但他们不能看到类型的实现，也不能直接创建它的实例。因此，只有当类型标记为"
" `priv` 可见性，并且没有被这个包的其他部分使用时，才会显示这个警告。"

#: ../../language/error_codes/E1003.md:12
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two types in the package that has similar name, you"
" might just use the other type by mistake."
msgstr "请注意，这个警告可能会揭示你代码中的其他错误。例如，如果包中有两个类型名称相似，你可能会错误地使用另一个类型。"

#: ../../language/error_codes/E1003.md:18
msgid ""
"priv struct Foo { // Warning: Unused type 'Foo'.\n"
"  bar : Int\n"
"}\n"
"\n"
"fn main {\n"
"  struct Bar { // Warning: Unused type 'Bar'.\n"
"    foot : Int\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:34
msgid "If the type is indeed useless, you can remove the definition of the type."
msgstr "如果这个类型确实没有用，你可以移除类型的定义。"

#: ../../language/error_codes/E1003.md:35
msgid ""
"If this type is not local, and is part of the public API of your module, "
"you can remove the `priv` visibility keyword from the type."
msgstr "如果这个类型不是局部的，并且是你模块的公开 API 的一部分，你可以移除 `priv` 可见性关键字。"

#: ../../language/error_codes/E1003.md:38
msgid ""
"struct Foo {\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:44
msgid "Check if you are referencing the type with a correct name."
msgstr "检查你是否以正确的名称引用该类型。"

#: ../../language/error_codes/E1003.md:46
msgid ""
"It is rather rare to have a type that is private and unused at the same "
"time; therefore, we suggest you remove the type if it is not used."
msgstr "在某些情况下，私有且未使用的类型是相对少见的；因此，我们建议你如果没有使用这个类型，就将其移除。"

#: ../../language/error_codes/E1004.md:1
msgid "E1004"
msgstr ""

#: ../../language/error_codes/E1004.md:3
msgid "Unused abstract type."
msgstr "未使用的抽象类型。"

#: ../../language/error_codes/E1004.md:5 ../../language/error_codes/E1016.md:5
msgid "Currently, MoonBit won't emit this warning."
msgstr "目前，MoonBit 不会发出这个警告。"

#: ../../language/error_codes/E1005.md:1
msgid "E1005"
msgstr ""

#: ../../language/error_codes/E1005.md:3
msgid "Unused generic type variable."
msgstr "未使用的泛型类型变量。"

#: ../../language/error_codes/E1005.md:5
msgid ""
"In some cases, using types with unused generic type variables will make "
"it impossible for the type checker to infer the type of the unused "
"variable. This might lead to cryptic error messages, even unexpected "
"runtime behavior."
msgstr "在某些情况下，使用带有未使用的泛型类型变量的类型将使类型检查器无法推断未使用变量的类型。这可能导致难以理解的错误信息，甚至是意想不到的运行时行为。"

#: ../../language/error_codes/E1005.md:11
msgid ""
"struct Foo[T] { // Warning: Unused type variable 'T'.\n"
"  bar : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let foo : Foo[Int] = { bar : 42 }\n"
"  let baz = { bar : 42 } // Warning: The type of this expression is "
"Foo[_/0]\n"
"  println(foo.bar)\n"
"  println(baz.bar)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1005.md:26
msgid "If the type variable is indeed useless, remove the unused type variable."
msgstr "如果类型变量确实没有用，移除未使用的类型变量。"

#: ../../language/error_codes/E1005.md:28
msgid ""
"struct Foo { // Remove the unused type variable.\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1005.md:34
msgid ""
"If you wish to keep the type variable, you can use `_` to indicate that "
"the type variable is intentionally unused."
msgstr "如果你希望保留类型变量，你可以使用 `_` 来表示类型变量是有意未使用的。"

#: ../../language/error_codes/E1005.md:37
msgid ""
"struct Foo[_] {\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:1
msgid "E1006"
msgstr ""

#: ../../language/error_codes/E1006.md:3
msgid "Variant is never read, never constructed, or both."
msgstr "枚举值从未被读取，从未被构造，或两者都是。"

#: ../../language/error_codes/E1006.md:5
msgid ""
"If a variant is never read, it means it is defined but never destructed "
"in a pattern matching expression (`match`, `let`, `guard let`, loop "
"function, etc.)."
msgstr "如果枚举值从未被读取，意味着它被定义但从未在模式匹配表达式中析构（`match`、`let`、`guard let`、循环函数等）。"

#: ../../language/error_codes/E1006.md:8
msgid "If a variant `A` is never constructed, it means there is no `A(...)`."
msgstr "如果枚举值 `A` 从未被构造，意味着没有 `A(...)`。"

#: ../../language/error_codes/E1006.md:9
msgid "If a variant is unused, it means it is never constructed and never read."
msgstr "如果枚举值未使用，意味着它既没有被构造也没有被读取。"

#: ../../language/error_codes/E1006.md:13
msgid ""
"priv enum T {\n"
"  A // Warning: Variant 'A' is never read\n"
"  B // Warning: Variant 'B' is never constructed\n"
"  C // Warning: Variant 'C' is unused\n"
"}\n"
"\n"
"fn main {\n"
"  match T::A {\n"
"    B => ()\n"
"    _ => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:30
msgid ""
"If some variants are never read, while others are read, this means that "
"you have use wildcard pattern (`_`) in your code. You can expand the "
"wildcard pattern to include the unused variants."
msgstr "如果有一些枚举值从未被读取，而其他枚举值被读取，这意味着你在代码中使用了通配符模式（`_`）。你可以展开通配符模式以包含未使用的枚举值。"

#: ../../language/error_codes/E1006.md:34
msgid ""
"fn main {\n"
"  match T::A {\n"
"    B => ()\n"
"    C => ()\n"
"    A => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:44
msgid ""
"If all variants are never read, and you need to read these variants "
"outside of current package, you can add `pub` keyword to the enum "
"definition. Notice this will make the implementation of the variant "
"visible to the users of the package."
msgstr "如果所有枚举值从未被读取，而你需要在当前包之外读取这些枚举值，你可以给枚举定义添加 `pub` 关键字。注意这将使枚举值的实现对包的用户可见。"

#: ../../language/error_codes/E1006.md:49
msgid ""
"pub enum T {\n"
"  A\n"
"  B\n"
"  C\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:57
msgid ""
"If you need to construct the \"never constructed\" variant outside of the"
" current package, you can add `pub(all)` keyword to the variant."
msgstr "如果你需要在当前包之外构造“从未被构造”的枚举值，你可以给枚举值添加 `pub(all)` 关键字。"

#: ../../language/error_codes/E1006.md:60
msgid ""
"pub(all) enum T {\n"
"  A\n"
"  B\n"
"  C\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:68
msgid "If some variants are indeed useless, you can remove the unused variants."
msgstr "如果有一些枚举值确实没有用，你可以移除未使用的枚举值。"

#: ../../language/error_codes/E1006.md:70
msgid ""
"enum T {\n"
"  A\n"
"  B\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:1
msgid "E1007"
msgstr ""

#: ../../language/error_codes/E1007.md:3
msgid ""
"Field is never read. This include fields in structs and fields in enum "
"constructors."
msgstr "字段从未被读取。这包括结构体中的字段和枚举构造器中的字段。"

#: ../../language/error_codes/E1007.md:8
msgid "For enum constructor fields:"
msgstr "对于枚举构造器字段"

#: ../../language/error_codes/E1007.md:10
msgid ""
"enum E {\n"
"  A(Int) // Warning: The 1st positional argument of constructor 'A' is "
"unused.\n"
"  B(value~ : Int) // Warning: Field 'value' of constructor 'B' is unused."
"\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(B(value=1))\n"
"  match A(1) {\n"
"    A(_) => println(\"A\")\n"
"    B(_) => println(\"B\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:25
msgid "For struct fields:"
msgstr "对于结构体字段"

#: ../../language/error_codes/E1007.md:27
msgid ""
"struct S {\n"
"  value : Int // Warning: Field 'value' is never read\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(S::{ value : 1 })\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:39
msgid ""
"If the fields in enum constructors are unused, you can expand them in the"
" pattern to use them:"
msgstr "如果枚举构造器中的字段未使用，你可以在模式中展开它们以使用它们："

#: ../../language/error_codes/E1007.md:42
msgid ""
"fn main {\n"
"  // ...\n"
"  match A(1) {\n"
"    A(x) => println(\"A(\\{x})\")\n"
"    B(value~) => println(\"B(\\{value})\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:52
msgid ""
"If the fields in structs are unused, you can list them in record pattern,"
" or use the dot-syntax to access them:"
msgstr "如果结构体中的字段未使用，你可以在结构体模式中列出它们，或使用点语法访问它们："

#: ../../language/error_codes/E1007.md:55
msgid ""
"fn main {\n"
"  let s = S::{ value : 1 }\n"
"  match s {\n"
"    { value } => println(\"S(\\{value})\")\n"
"  }\n"
"  println(\"S(\\{s.value})\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:65
msgid ""
"Or, if the fields are indeed useless, you can remove the field from the "
"constructor:"
msgstr "或者，如果字段确实没有用，你可以从构造器中移除字段："

#: ../../language/error_codes/E1007.md:68
msgid ""
"enum E {\n"
"  A\n"
"  B\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:75
msgid ""
"struct S {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1008.md:1
msgid "E1008"
msgstr ""

#: ../../language/error_codes/E1008.md:3
msgid ""
"The modifier (`pub`/`priv`) is redundant here, since this field has such "
"visibility by default."
msgstr "修饰符（`pub`/`priv`）在这里是多余的，因为这个字段默认具有这样的可见性。"

#: ../../language/error_codes/E1008.md:8
msgid ""
"struct A {\n"
"  priv value : Int\n"
"  // Warning: The private modifier is redundant here\n"
"  //          since field value is private by default\n"
"}\n"
"\n"
"pub struct B {\n"
"  pub value : Int\n"
"  // Warning: The public modifier is redundant here\n"
"  //          since field value is public by default\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1008.md:24
msgid "Remove the visibility modifier on the field."
msgstr "移除字段上的可见性修饰符。"

#: ../../language/error_codes/E1008.md:26
msgid ""
"struct A {\n"
"  value : Int\n"
"}\n"
"\n"
"pub struct B {\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:1
msgid "E1009"
msgstr ""

#: ../../language/error_codes/E1009.md:3
msgid "The struct is never constructed."
msgstr "结构体从未被构造。"

#: ../../language/error_codes/E1009.md:7
msgid ""
"pub struct A { // Warning: The struct A is never constructed\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:13
msgid ""
"priv struct A { // Warning: The struct A is never constructed\n"
"  value : Int\n"
"}\n"
"\n"
"fn f(a : A) -> Int {\n"
"  a.value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:25
msgid ""
"The `pub` visibility modifier only allows external packages to access the"
" struct, by dot-syntax (`a.value`), or by pattern matching. Therefore, if"
" you expect external packages to be able to construct the struct, you "
"should use the `pub(all)` visibility modifier."
msgstr ""
"`pub` 可见性修饰符只允许外部包通过点语法（`a.value`）或模式匹配来访问结构体。因此，如果你希望外部包能够构造结构体，你应该使用 "
"`pub(all)` 可见性修饰符。"

#: ../../language/error_codes/E1009.md:30
msgid ""
"pub(all) struct A {\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:36
msgid ""
"However, if you do not want external packages to construct the struct, "
"this might be due to incompleteness or bugs in your code. There are some "
"common cases:"
msgstr "然而，如果你不希望外部包构造结构体，这可能是由于你代码的不完整或错误。以下是一些常见情况："

#: ../../language/error_codes/E1009.md:40
msgid ""
"You planned to use smart constructors or factory functions to construct "
"the struct, but you forgot or have not implemented them."
msgstr "你计划使用智能构造器或工厂函数来构造结构体，但你忘记了或尚未实现它们。"

#: ../../language/error_codes/E1009.md:42
msgid ""
"You intend to keep the struct private to control its instantiation but "
"may have forgotten to provide a way to do so within its own package."
msgstr "你打算保持结构体私有以控制其实例化，但可能忘记了在其自己的包中提供这样的方法。"

#: ../../language/error_codes/E1009.md:45
msgid ""
"In these cases, you should consider providing a way to construct the "
"struct within its own package."
msgstr "在这些情况下，你应该考虑在自己的包内提供构造结构体的方法。"

#: ../../language/error_codes/E1009.md:48
msgid ""
"priv struct A {\n"
"  value : Int\n"
"}\n"
"\n"
"fn A::new(value : Int) -> A {\n"
"  A::{ value }\n"
"}\n"
"\n"
"fn A::value(self : A) -> Int {\n"
"  self.value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:1
msgid "E1010"
msgstr ""

#: ../../language/error_codes/E1010.md:3
msgid ""
"This pattern is unused. This usually happens in pattern matching, and "
"this pattern is completely covered by a prior pattern."
msgstr "这个模式未使用。这通常发生在模式匹配中，这个模式完全被前一个模式覆盖。"

#: ../../language/error_codes/E1010.md:6
msgid ""
"Pattern matching in MoonBit is executed sequentially, from the first "
"branch to the last. If a pattern is covered by a prior pattern, it will "
"never be reached, since all control flow will be directed to the first "
"matching branch."
msgstr ""
"MoonBit "
"中的模式匹配是按顺序执行的，从第一个分支到最后一个。如果一个模式被前一个模式覆盖，它将永远不会被执行，因为所有的控制流都将被定向到第一个匹配的分支。"

#: ../../language/error_codes/E1010.md:12
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    _ => println(\"_\")\n"
"    Some(a) => println(\"Some(\\{a})\") // Warning: Unused pattern\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:23
msgid ""
"This warning can be usually fixed by swapping the order of the branches "
"in the pattern matching. If the order of the branches is important, then "
"you may want to refine the first pattern so that it excludes what the "
"second pattern covers."
msgstr "这个警告通常可以通过交换模式匹配中分支的顺序来修复。如果分支的顺序很重要，那么你可能希望完善第一个模式，使其排除第二个模式覆盖的内容。"

#: ../../language/error_codes/E1010.md:27
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(a) => println(\"Some(\\{a})\")\n"
"    _ => println(\"_\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:36
#: ../../language/error_codes/E3012.md:43
#: ../../language/error_codes/E3016.md:39
msgid "Or,"
msgstr "或者，"

#: ../../language/error_codes/E1010.md:38
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    None => println(\"_\")\n"
"    Some(a) => println(\"Some(\\{a})\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:1
msgid "E1011"
msgstr ""

#: ../../language/error_codes/E1011.md:3
msgid ""
"Partial match. The match/guard/loop expression does not cover all "
"possible cases."
msgstr "部分匹配。`match`/`guard`/`loop` 表达式未覆盖所有可能的情况。"

#: ../../language/error_codes/E1011.md:8
msgid ""
"///|\n"
"fn main {\n"
"  match Some(1) { // Partial match, some hints: None\n"
"    Some(x) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:19
msgid ""
"The warning message usually contains hints about the missing patterns. "
"Add the missing cases to avoid incomplete matches."
msgstr "警告消息通常包含有关缺失模式的提示。添加缺失的情况以避免不完整的匹配。"

#: ../../language/error_codes/E1011.md:21
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(x) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:29
msgid "Or, you can add a wildcard pattern to catch all remaining cases:"
msgstr "或者，你可以添加一个通配符模式来捕获所有剩余的情况："

#: ../../language/error_codes/E1011.md:31
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(x) => println(x)\n"
"    _ => println(\"Other\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1012.md:1
msgid "E1012"
msgstr ""

#: ../../language/error_codes/E1012.md:3
msgid ""
"Unreachable code. This usually happens when a `return` statement is "
"followed by more code. The `return` statement will exit the function "
"immediately, so any code after it will not be executed."
msgstr "不可达代码。这通常发生在 `return` 语句后面跟着更多代码的情况。`return` 语句将立即退出函数，因此它后面的任何代码都不会被执行。"

#: ../../language/error_codes/E1012.md:9
msgid ""
"fn main {\n"
"  return\n"
"  println(\"Hello, World!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1012.md:18
msgid ""
"Remove the unreachable code, or move it before the `return` statement if "
"you want the code to be executed."
msgstr "移除不可达代码，或者如果你希望代码被执行，将其移动到 `return` 语句之前。"

#: ../../language/error_codes/E1012.md:21
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"  return\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:1
msgid "E1013"
msgstr ""

#: ../../language/error_codes/E1013.md:3
msgid "The type of this expression contains unresolved type variables."
msgstr "这个表达式的类型包含未解析的类型变量。"

#: ../../language/error_codes/E1013.md:5
msgid ""
"This error occurs when the compiler encounters a type that contains type "
"variables which cannot be determined from the context. Type variables are"
" placeholders for types that should be inferred by the compiler."
msgstr "当编译器遇到无法从上下文确定的类型变量时，将会出现此错误。类型变量是应由编译器推断的类型的占位符。"

#: ../../language/error_codes/E1013.md:9
msgid "Common cases where this happens:"
msgstr "常见情况："

#: ../../language/error_codes/E1013.md:11
msgid "Writing local functions without explicit type annotations"
msgstr "编写没有明确类型注释的局部函数"

#: ../../language/error_codes/E1013.md:12
msgid ""
"Creating empty collections (Arrays, Options) without specifying their "
"element type"
msgstr "创建空集合（数组，选项），而未指定其元素类型。"

#: ../../language/error_codes/E1013.md:15
msgid ""
"When the compiler cannot resolve these type variables, it defaults them "
"to `Unit` type, which may not be what you intended."
msgstr "当编译器无法解析这些类型变量时，它将其默认为 `Unit` 类型，这可能并不是你所期望的。"

#: ../../language/error_codes/E1013.md:20
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x) {\n"
"//     ^ Warning: The type of this expression is Option[_/0], which "
"contains\n"
"//                unresolved type variables. The type variable is default"
" to\n"
"//                Unit.\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"\n"
"  f(None)\n"
"}\n"
"\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[_]) -> Int {\n"
"//     ^ Warning: The type of this expression is Array[_/0], which "
"contains\n"
"//                unresolved type variables. The type variable is default"
" to\n"
"//                Unit.\n"
"    x.length()\n"
"  }\n"
"\n"
"  println(f([]))\n"
"}\n"
"\n"
"fn main {\n"
"  let a = []\n"
"//        ^^ Warning: The type of this expression is Array[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(a.length())\n"
"  let b = None\n"
"//        ^^ Warning: The type of this expression is Option[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(b.is_empty())\n"
"}\n"
"\n"
msgstr ""

#: ../../language/error_codes/E1013.md:61
msgid "To fix this warning, you can:"
msgstr "要修复这个警告，你可以："

#: ../../language/error_codes/E1013.md:63
msgid "Add type annotations to local function parameters. For example,"
msgstr "为局部类型函数参数添加类型注释。例如："

#: ../../language/error_codes/E1013.md:65
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x: Option[Int]) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"  f(None)\n"
"}\n"
"\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[Int]) -> Int {\n"
"    x.length()\n"
"  }\n"
"  println(f([]))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:84
msgid ""
"Explicitly specify the type of the variable or the collection element "
"type."
msgstr "显式指定变量或集合元素的类型。"

#: ../../language/error_codes/E1013.md:86
msgid ""
"fn main {\n"
"  let a : Array[Int] = []\n"
"  println(a.length())\n"
"  let b : Option[Int] = None\n"
"  println(b.is_empty())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:95
msgid "Or equivalently, add annotations on the collection creation."
msgstr "或者，等效地，在集合创建时添加类型注释。"

#: ../../language/error_codes/E1013.md:97
msgid ""
"fn main {\n"
"  let a = ([] : Array[Int])\n"
"  println(a.length())\n"
"  let b = (None : Option[Int])\n"
"  println(b.is_empty())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:106
msgid "Provide enough context through usage."
msgstr "通过使用提供足够的上下文。"

#: ../../language/error_codes/E1013.md:108
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a + 1)\n"
"//                       ^^^^^ through this usage, the compiler can infer"
" the\n"
"//                             type of `x` is `Option[Int]`.\n"
"    }\n"
"  }\n"
"  f(None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1014.md:1
msgid "E1014"
msgstr ""

#: ../../language/error_codes/E1014.md:3
msgid ""
"Type name should be capitalized. In MoonBit, we recommend using a "
"capitalized type name for all types, including built-in types and user-"
"defined types. This is a convention that is followed by the standard "
"library and most of the community code."
msgstr "类型名称应该大写。在 MoonBit 中，我们建议对所有类型使用大写类型名称，包括内置类型和用户定义类型。这是一个标准库和大多数社区代码遵循的约定。"

#: ../../language/error_codes/E1014.md:7
msgid ""
"struct point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1014.md:16
msgid "Capitalize the type name."
msgstr "将类型名称大写。"

#: ../../language/error_codes/E1014.md:18
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1015.md:1
msgid "E1015"
msgstr ""

#: ../../language/error_codes/E1015.md:3
msgid ""
"The mutability is never used. It is a common mistake to declare an array "
"to be mutable when it is not necessary. Setting the value of an element "
"in an array does not require the array to be mutable. For example, `a[0] "
"= 0` does not require `a` to be mutable, but `a = [0, 1, 2]` does."
msgstr ""
"数据从未被修改。一个常见错误是在不必要的情况下声明数组为可变。设置数组中元素的值并不需要数组是可变的。例如，`a[0] = 0` 不需要 `a` "
"是可变的，但 `a = [0, 1, 2]` 需要。"

#: ../../language/error_codes/E1015.md:10
msgid ""
"fn main {\n"
"  let mut x = [1, 2, 3] // Warning: The mutability of 'x' is never used.\n"
"  x[0] = 0\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1015.md:20
msgid "Remove the `mut` keyword from the variable declaration."
msgstr "移除变量声明中的 `mut` 关键字。"

#: ../../language/error_codes/E1015.md:22
msgid ""
"fn main {\n"
"  let x = [1, 2, 3]\n"
"  x[0] = 0\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1016.md:1
msgid "E1016"
msgstr ""

#: ../../language/error_codes/E1016.md:3
msgid "Parser consistency check failed."
msgstr "解析器一致性检查失败。"

#: ../../language/error_codes/E1018.md:1
msgid "E1018"
msgstr ""

#: ../../language/error_codes/E1018.md:3
msgid "There is no `continue` in this loop expression, so `loop` is useless here."
msgstr "在这个循环表达式中没有 `continue`，因此 `loop` 在这里是无用的。"

#: ../../language/error_codes/E1018.md:5
msgid ""
"This error occurs when using a `loop` expression that contains no "
"`continue` statement. In MoonBit, a `loop` without any `continue` "
"statements is equivalent to an block expression that will be executed "
"only once, making the `loop` keyword redundant in such cases. You should "
"either add a `continue` statement if you need to restart the loop from "
"the beginning, or use a simpler control flow construct like `match` or "
"`if`."
msgstr ""
"当使用一个不包含 `continue` 语句的 `loop` 表达式时，将会出现这个错误。在 MoonBit 中，一个不包含任何 "
"`continue` 语句的 `loop` 相当于一个只执行一次的块表达式，使得在这种情况下 `loop` "
"关键字是多余的。如果你需要从头重新开始循环，你应该添加一个 `continue` 语句，或者使用一个更简单的控制流结构，如 `match` 或 "
"`if`。"

#: ../../language/error_codes/E1018.md:14
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  loop count {\n"
"    _..<0 => break\n"
"    _ => count = count - 1\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1018.md:27
msgid "Either add a `continue` statement if you need to restart the loop:"
msgstr "如果你需要重新开始循环，添加一个 `continue` 语句："

#: ../../language/error_codes/E1018.md:29
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  loop count {\n"
"    _..<0 => break\n"
"    _ => {\n"
"      continue count - 1\n"
"    }\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1018.md:42
msgid "Or use `if`/`match` you don't need to use `continue`:"
msgstr "或者如果不需要使用 `continue`，使用 `if`/`match`："

#: ../../language/error_codes/E1018.md:44
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  match count {\n"
"    _..<0 => ()\n"
"    _ => count = count - 1\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1019.md:1
msgid "E1019"
msgstr ""

#: ../../language/error_codes/E1019.md:3
msgid ""
"Toplevel declaration is not left aligned. Every toplevel structure in "
"MoonBit should be left-aligned, i.e. there is no space between the "
"beginning of the line and the declaration."
msgstr "顶层声明未左对齐。MoonBit 中的每个顶层结构都应该左对齐，即行首和声明之间没有空格。"

#: ../../language/error_codes/E1019.md:7
msgid ""
"Sometimes, earlier parsing errors might causing this error to be raised "
"in the following lines. Therefore, when your are writing local "
"declarations while seeing this error, you should check the previous lines"
" for any parsing errors."
msgstr "有时，更早出现的解析错误可能会导致在后续行中引发此错误。因此，当你在编写局部声明时看到这个错误，你应该检查前面的行是否有解析错误。"

#: ../../language/error_codes/E1019.md:13
msgid "  let x = 1\n"
msgstr ""

#: ../../language/error_codes/E1019.md:19
msgid "Remove the leading spaces:"
msgstr "移除前导空格："

#: ../../language/error_codes/E1019.md:21
msgid "let x = 1\n"
msgstr ""

#: ../../language/error_codes/E1020.md:1
msgid "E1020"
msgstr ""

#: ../../language/error_codes/E1020.md:3
msgid ""
"Invalid pragma. The pragma either has invalid id, or has invalid "
"properties."
msgstr "无效的编译器指令。编译器指令的 id 不合法，或者有不合法的属性。"

#: ../../language/error_codes/E1020.md:5
msgid "MoonBit compiler support the following pragmas:"
msgstr "MoonBit 编译器支持以下编译器指令："

#: ../../language/error_codes/E1020.md:7
msgid ""
"`@alert`. This pragma is used to emit a warning message. It has the "
"following format: `@alert <category> \"message\"`. For example:"
msgstr "`@alert`。这个编译器指令用于发出警告消息。它有以下格式：`@alert <category> \"message\"`。例如："

#: ../../language/error_codes/E1020.md:10
msgid ""
"///|\n"
"/// @alert deprecated \"This function is deprecated\"\n"
"fn deprecated_function() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:18
msgid ""
"`@coverage.skip`. This pragma indicates that the following declaration "
"should be skipped when calculating code coverage. It has the following "
"format: `@coverage.skip`. For example:"
msgstr "`@coverage.skip`。这个编译器指令表示在计算代码覆盖率时应跳过以下声明。它有以下格式：`@coverage.skip`。例如："

#: ../../language/error_codes/E1020.md:22
msgid ""
"///|\n"
"/// @coverage.skip\n"
"fn function_to_skip() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:32
msgid ""
"///|\n"
"/// @deprecated \"This function is deprecated\"\n"
"fn f() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:42
msgid ""
"Depending on the pragma you want to use, you should either remove the "
"invalid pragma, or replace it with a valid one."
msgstr "根据你想使用的编译器指令，你应该移除无效的编译器指令，或者替换为有效的编译器指令。"

#: ../../language/error_codes/E1020.md:45
msgid ""
"///|\n"
"/// @alert deprecated \"This function is deprecated\"\n"
"fn f() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:1
msgid "E1021"
msgstr ""

#: ../../language/error_codes/E1021.md:3
msgid "Some arguments of constructor are omitted in pattern."
msgstr "一些构造器的参数在模式中被省略。"

#: ../../language/error_codes/E1021.md:7
msgid ""
"enum E {\n"
"  A(Int, w~ : Int, h~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~) => { // Warning: The argument(s) h of constructor A are "
"omitted.\n"
"      println(v)\n"
"      println(w)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:24
msgid ""
"If you want to omit some arguments, add the `..` to the end of the "
"pattern:"
msgstr "如果你想省略一些参数，在模式的末尾添加 `..`："

#: ../../language/error_codes/E1021.md:26
msgid ""
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~, ..) => {\n"
"      println(v)\n"
"      println(w)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:37
msgid "Or, you can match all arguments:"
msgstr "或者，你可以匹配所有参数："

#: ../../language/error_codes/E1021.md:39
msgid ""
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~, h~) => {\n"
"      println(v)\n"
"      println(w)\n"
"      println(h)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:1
msgid "E1022"
msgstr ""

#: ../../language/error_codes/E1022.md:3
msgid ""
"Ambiguous block expression. In MoonBit, the expression `{ value }` is "
"ambiguous because it could be interpreted as a block expression or a "
"struct literal. For now, we treat it as a struct literal, but writing "
"such expressions is discouraged."
msgstr ""
"有歧义的块表达式。在 MoonBit 中，表达式 `{ value }` "
"有歧义，因为它可以被解释为块表达式或结构体字面量。目前，我们将其视为结构体字面量，但不建议编写这样的表达式。"

#: ../../language/error_codes/E1022.md:10
msgid ""
"struct S {\n"
"  value : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let value = 3\n"
"  let s = { value }\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:24
msgid ""
"If you want to construct a struct using the struct literal, you can add a"
" comma to the end of the struct literal. Or you can call formatter on "
"this buffer to have the comma added automatically."
msgstr "如果你想使用结构体字面量构造结构体，你可以在结构体字面量的末尾添加逗号。或者你可以在这个编辑区域中调用格式化程序，让它自动添加逗号。"

#: ../../language/error_codes/E1022.md:28
msgid ""
"fn main {\n"
"  let value = 3\n"
"  let s = { value, }\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:36
msgid ""
"If you are using it as a block expression, please remove the braces as it"
" has only one expression and is equivalent to the expression `value`:"
msgstr "如果你将其用作块表达式，请移除大括号，因为它只有一个表达式，等效于表达式 `value`："

#: ../../language/error_codes/E1022.md:39
msgid ""
"fn main {\n"
"  let value = 3\n"
"  let s = value\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1023.md:1
msgid "E1023"
msgstr ""

#: ../../language/error_codes/E1023.md:3
msgid "The body of this try expression never raises any error."
msgstr "这个 try 表达式的主体从未引发任何错误。"

#: ../../language/error_codes/E1023.md:7
msgid ""
"fn main {\n"
"  try {\n"
"    println(\"Hello, world!\")\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1023.md:19
msgid "Remove the `try` expression:"
msgstr "移除 `try` 表达式："

#: ../../language/error_codes/E1023.md:21
#: ../../language/error_codes/E3002.md:27
#: ../../language/error_codes/E3003.md:17
#: ../../language/error_codes/E4069.md:67
msgid ""
"fn main {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1024.md:1
msgid "E1024"
msgstr ""

#: ../../language/error_codes/E1024.md:3
msgid "The error type of this function is never used."
msgstr "这个函数的错误类型从未被使用。"

#: ../../language/error_codes/E1024.md:7
msgid ""
"fn greet() -> Unit! {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1024.md:15
msgid "Remove the error type:"
msgstr "移除错误类型"

#: ../../language/error_codes/E1024.md:17
msgid ""
"fn greet() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1026.md:1
msgid "E1026"
msgstr ""

#: ../../language/error_codes/E1026.md:3
msgid ""
"The patterns are complete so the usage of `catch!` is useless. In "
"MoonBit, when there is only one error type that will be raised in a try "
"block, compiler will know that the error type is the only one that will "
"be caught. So, there is no need to use `catch!` in this case."
msgstr ""
"模式匹配是完整的，因此使用 `catch!` 是无用的。在 MoonBit 中，当在 try "
"块中只会引发一个错误类型时，编译器将知道这个错误类型是唯一会被捕获的。因此，在这种情况下，不需要使用 `catch!`。"

#: ../../language/error_codes/E1026.md:10
msgid ""
"type! E\n"
"\n"
"fn f() -> Unit!E {\n"
"  raise E\n"
"}\n"
"\n"
"fn g() -> Unit! {\n"
"  try {\n"
"    f!()\n"
"  } catch! {\n"
"    E => raise E\n"
"  }\n"
"}\n"
"\n"
"fn main {\n"
"  try {\n"
"    g!()\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1026.md:36
msgid "Remove the `!` in the `catch!`:"
msgstr "移除 `catch!` 中的 `!`："

#: ../../language/error_codes/E1026.md:38
msgid ""
"type! E\n"
"\n"
"fn f() -> Unit!E {\n"
"  raise E\n"
"}\n"
"\n"
"fn g() -> Unit! {\n"
"  try {\n"
"    f!()\n"
"  } catch {\n"
"    E => raise E\n"
"  }\n"
"}\n"
"\n"
"fn main {\n"
"  try {\n"
"    g!()\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1027.md:1
msgid "E1027"
msgstr ""

#: ../../language/error_codes/E1027.md:3
msgid ""
"The syntax is deprecated. Please refer to the warning message on the "
"reason and potential fix."
msgstr "语法已弃用。请参考警告消息，了解原因和潜在修复方法。"

#: ../../language/error_codes/E1028.md:1
msgid "E1028"
msgstr ""

#: ../../language/error_codes/E1028.md:3
msgid ""
"Unfinished code. In MoonBit, you can use `...` to mark a piece of code "
"that is incomplete. You can still compile and run the code, but it will "
"cause a runtime error when it is executed."
msgstr "未完成的代码。在 MoonBit 中，你可以使用 `...` 标记一个不完整的代码片段。你仍然可以编译和运行代码，但在执行时会导致运行时错误。"

#: ../../language/error_codes/E1028.md:7
msgid ""
"fn f() -> Unit {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1028.md:15
msgid "Complete the code:"
msgstr "完成代码："

#: ../../language/error_codes/E1028.md:17
msgid ""
"fn f() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:1
msgid "E1029"
msgstr ""

#: ../../language/error_codes/E1029.md:3
msgid "Unused package."
msgstr "未使用的包。"

#: ../../language/error_codes/E1029.md:7
msgid "`moon.mod.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:9
msgid ""
"{\n"
"  \"name\": \"username/hello\",\n"
"  \"version\": \"0.1.0\",\n"
"  \"readme\": \"README.md\",\n"
"  \"source\": \"src\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:18
#: ../../language/error_codes/E1033.md:12
#: ../../language/error_codes/E4069.md:19
#: ../../language/error_codes/E4069.md:47
msgid "`lib/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:20
#: ../../language/error_codes/E1033.md:14
#: ../../language/error_codes/E4061.md:34
#: ../../language/error_codes/E4094.md:14
#: ../../language/error_codes/E4145.md:14
msgid "{}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:24
msgid "`lib/hello.mbt`:"
msgstr ""

#: ../../language/error_codes/E1029.md:26
#: ../../language/error_codes/E1033.md:20
msgid ""
"pub fn greeting() -> String {\n"
"  \"Hello, world!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:32
#: ../../language/error_codes/E1029.md:54
#: ../../language/error_codes/E1033.md:26
#: ../../language/error_codes/E1033.md:56
#: ../../language/error_codes/E4067.md:15
#: ../../language/error_codes/E4067.md:50
#: ../../language/error_codes/E4068.md:15
#: ../../language/error_codes/E4069.md:57
msgid "`main/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:34
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    \"username/hello/lib\" // Unused package 'username/hello/lib'\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:43
#: ../../language/error_codes/E1033.md:43
#: ../../language/error_codes/E1033.md:72
#: ../../language/error_codes/E4067.md:23
#: ../../language/error_codes/E4067.md:37
#: ../../language/error_codes/E4068.md:23
#: ../../language/error_codes/E4069.md:65
msgid "`main/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1029.md:45
msgid ""
"fn main {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:52
msgid "Remove the unused package:"
msgstr "移除未使用的包："

#: ../../language/error_codes/E1029.md:56
#: ../../language/error_codes/E4068.md:17
#: ../../language/error_codes/E4068.md:53
#: ../../language/error_codes/E4069.md:49
#: ../../language/error_codes/E4069.md:59
msgid ""
"{\n"
"  \"is-main\": true\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1030.md:1
msgid "E1030"
msgstr ""

#: ../../language/error_codes/E1030.md:3
msgid ""
"The package alias is empty. The default package alias will be used "
"instead."
msgstr "包别名为空。将使用默认包别名。"

#: ../../language/error_codes/E1030.md:7
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"\" // Warning: The package alias is empty. The default"
" package alias will be used instead.\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1030.md:21
msgid "Use a non-empty alias for the package:"
msgstr "为包使用非空别名："

#: ../../language/error_codes/E1030.md:23
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\"\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:1
msgid "E1031"
msgstr ""

#: ../../language/error_codes/E1031.md:3
msgid ""
"The optional argument is never supplied. If the optional argument is "
"never supplied, then it can be safely removed from the parameter list and"
" be used purely internally as a normal variable."
msgstr "可选参数从未被提供。如果可选参数从未被提供，那么它可以安全地从参数列表中移除，并作为普通变量纯粹在内部使用。"

#: ../../language/error_codes/E1031.md:9
msgid ""
"Note, this warning is turned off by default. To enable this warning, you "
"have to modify the `\"warn-list\"` of `moon.pkg.json`:"
msgstr "注意，默认情况下，此警告是关闭的。要启用此警告，你必须修改 `moon.pkg.json` 的 `\"warn-list\"`："

#: ../../language/error_codes/E1031.md:12
msgid ""
"{\n"
"  // ...\n"
"  \"warn-list\": \"+31\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:19
#: ../../language/error_codes/E1032.md:16
msgid "`main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1031.md:21
msgid ""
"fn f(opt~ : Int = 4) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:35
msgid ""
"You can remove the optional argument, and use a local variable definition"
" instead:"
msgstr "你可以移除可选参数，并使用局部变量定义代替："

#: ../../language/error_codes/E1031.md:38
msgid ""
"fn f() -> Int {\n"
"  let opt = 4\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:1
msgid "E1032"
msgstr ""

#: ../../language/error_codes/E1032.md:3
msgid ""
"Default value of optional argument is unused. This implies at every call "
"site of this function, the optional argument is always explicitly "
"supplied with a value. This means the optional argument can be refactored"
" into a labelled argument."
msgstr "可选参数的默认值未被使用。这意味着在这个函数的每个调用点，可选参数总是显式地提供一个值。这意味着可选参数可以重构为带标签的参数。"

#: ../../language/error_codes/E1032.md:7
msgid ""
"Note, this warning is turned off by default. To enable this warning, you "
"need to modify the `\"warn-list\"` of `moon.pkg.json`:"
msgstr "注意，默认情况下，此警告是关闭的。要启用此警告，你需要修改 `moon.pkg.json` 的 `\"warn-list\"`："

#: ../../language/error_codes/E1032.md:9
msgid ""
"{\n"
"  // ...\n"
"  \"warn-list\": \"+32\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:18
msgid ""
"fn f(opt~ : Int = 4) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f(opt=3))\n"
"  println(f(opt=3))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:32
msgid "Turn the optional argument into a labelled argument:"
msgstr "将可选参数转换为带标签的参数："

#: ../../language/error_codes/E1032.md:34
msgid ""
"fn f(opt~ : Int) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f(opt=3))\n"
"  println(f(opt=3))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:1
msgid "E1033"
msgstr ""

#: ../../language/error_codes/E1033.md:3
msgid "The import value is never used directly."
msgstr "导入的值从未被直接使用。"

#: ../../language/error_codes/E1033.md:5
msgid ""
"In MoonBit, you can import a value (say `f`) from another package into "
"current package, so that you don't have to use `@pkg.f` to qualify the "
"value, and you can just use `f` as if it were defined in this package. "
"However, if `f` is not used in current package, this warning will be "
"emitted."
msgstr "在 MoonBit 中，你可以从另一个包中导入一个值（比如 `f`）到当前包中，这样你就不必使用 `@pkg.f` 来限定值，"

#: ../../language/error_codes/E1033.md:18
msgid "`lib/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1033.md:28
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\",\n"
"      \"value\": [\n"
"        \"greeting\" // Warning: The import value greeting is never used "
"directly.\n"
"      ]\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:45
msgid ""
"fn main {\n"
"  println(@hello.greeting())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:53
msgid ""
"It is possible that you still use qualified name to access the imported "
"value. In this case, either remove the imported value from "
"`moon.pkg.json`."
msgstr "你可能仍然使用限定名称来访问导入的值。在这种情况下，要么从 `moon.pkg.json` 中删除导入的值。"

#: ../../language/error_codes/E1033.md:58
msgid ""
"{\n"
"  // ...\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\"\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:70
msgid "Or remove the qualified package name from your code:"
msgstr "或者从你的代码中移除限定的包名："

#: ../../language/error_codes/E1033.md:74
msgid ""
"fn main {\n"
"  println(greeting())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1034.md:1
msgid "E1034"
msgstr ""

#: ../../language/error_codes/E1034.md:3
msgid ""
"The syntax `~label` is deprecated. We have removed this syntax and this "
"warning is no longer emitted by the compiler."
msgstr "语法 `~label` 已弃用。我们已经移除了这个语法，编译器不再发出此警告。"

#: ../../language/error_codes/E1035.md:1
msgid "E1035"
msgstr ""

#: ../../language/error_codes/E1035.md:3
msgid ""
"The word is reserved for possible future use. Please use another name for"
" it."
msgstr "这个词被保留以备将来使用。请使用其他名称。"

#: ../../language/error_codes/E1035.md:5
msgid "Here is a list of reserved name:"
msgstr "这里有一个保留名称的列表："

#: ../../language/error_codes/E1035.md:7
msgid "`module`"
msgstr ""

#: ../../language/error_codes/E1035.md:8
msgid "`move`"
msgstr ""

#: ../../language/error_codes/E1035.md:9
msgid "`ref`"
msgstr ""

#: ../../language/error_codes/E1035.md:10
msgid "`static`"
msgstr ""

#: ../../language/error_codes/E1035.md:11
msgid "`super`"
msgstr ""

#: ../../language/error_codes/E1035.md:12
msgid "`unsafe`"
msgstr ""

#: ../../language/error_codes/E1035.md:13
msgid "`use`"
msgstr ""

#: ../../language/error_codes/E1035.md:14
msgid "`where`"
msgstr ""

#: ../../language/error_codes/E1035.md:15
msgid "`await`"
msgstr ""

#: ../../language/error_codes/E1035.md:16
msgid "`dyn`"
msgstr ""

#: ../../language/error_codes/E1035.md:17
msgid "`abstract`"
msgstr ""

#: ../../language/error_codes/E1035.md:18
msgid "`do`"
msgstr ""

#: ../../language/error_codes/E1035.md:19
msgid "`final`"
msgstr ""

#: ../../language/error_codes/E1035.md:20
msgid "`macro`"
msgstr ""

#: ../../language/error_codes/E1035.md:21
msgid "`override`"
msgstr ""

#: ../../language/error_codes/E1035.md:22
msgid "`typeof`"
msgstr ""

#: ../../language/error_codes/E1035.md:23
msgid "`virtual`"
msgstr ""

#: ../../language/error_codes/E1035.md:24
msgid "`yield`"
msgstr ""

#: ../../language/error_codes/E1035.md:25
msgid "`local`"
msgstr ""

#: ../../language/error_codes/E1035.md:26
msgid "`method`"
msgstr ""

#: ../../language/error_codes/E1035.md:27
msgid "`alias`"
msgstr ""

#: ../../language/error_codes/E1035.md:31
msgid ""
"fn module() -> Int { // Warning: The word `module` is reserved for "
"possible future use. Please consider using another name.\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1035.md:39
msgid ""
"fn module_() -> Int {\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1036.md:1
msgid "E1036"
msgstr ""

#: ../../language/error_codes/E1036.md:3
msgid "The loop label name shadows a label that is already in scope."
msgstr "循环标签名称隐藏了已经在作用域中的标签。"

#: ../../language/error_codes/E1036.md:5
msgid ""
"Loop labels must be unique within their scope. When a label name is "
"reused within a nested scope, it shadows the outer label, which can lead "
"to confusion about which loop is being referenced by `break` or "
"`continue` statements."
msgstr ""
"循环标签在它们的作用域内必须是唯一的。当标签名在嵌套作用域内被重复使用时，它会遮蔽外部标签，这可能导致对 `break` 或 `continue`"
" 语句所引用的循环产生混淆。"

#: ../../language/error_codes/E1036.md:9
msgid ""
"This warning helps prevent bugs that could occur when breaking or "
"continuing to the wrong loop level due to label shadowing. It's "
"recommended to use distinct, descriptive label names for different loops "
"to make the code's intent clear."
msgstr "此警告有助于防止由于标签遮蔽而导致错误地中断或继续到错误的循环级别。建议为不同的循环使用不同的、描述性的标签名称，以使代码的意图清晰。"

#: ../../language/error_codes/E1036.md:15
msgid ""
"fn f(xss : Array[Array[Int]]) -> Unit {\n"
"  l~: for xs in xss {\n"
"    l~: for x in xs {\n"
"//  ^^  Warning: The label name `l` shadows a label name that is already "
"in\n"
"//               scope.\n"
"      if x > 0 {\n"
"        break l~\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1036.md:31
msgid ""
"Use distinct, descriptive label names for different loops to make the "
"code's intent clear."
msgstr "为不同的循环使用不同的、描述性的标签名称，以使代码的意图清晰。"

#: ../../language/error_codes/E1037.md:1
msgid "E1037"
msgstr ""

#: ../../language/error_codes/E1037.md:3
msgid "The loop label name is never used."
msgstr "循环标签名称从未被使用。"

#: ../../language/error_codes/E1037.md:7
msgid ""
"fn read() -> BytesView {\n"
"  ...\n"
"}\n"
"\n"
"fn main {\n"
"  let mut bytes = []\n"
"  read~: loop read() {\n"
"    [] => break\n"
"    bs => {\n"
"      bytes = [..bytes, ..bs]\n"
"      continue read()\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1037.md:26
msgid "Remove the unused loop label."
msgstr "移除未使用的循环标签。"

#: ../../language/error_codes/E1037.md:28
msgid ""
"fn main {\n"
"  let mut bytes = []\n"
"  loop {\n"
"    let bs = read()\n"
"    if bs == [] {\n"
"      break\n"
"    }\n"
"    bytes = [..bytes, ..bs]\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:1
msgid "E1038"
msgstr ""

#: ../../language/error_codes/E1038.md:3
msgid ""
"Useless guard because the pattern is irrefutable. A pattern is "
"irrefutable means it accepts all possible input. If a pattern in guard "
"let accepts all possible input, then it will always continue on, making "
"the guard useless."
msgstr ""
"无用的 guard，因为模式是不可反驳的。不可反驳的模式意味着它接受所有可能的输入。如果 guard let "
"中的模式接受所有可能的输入，那么它将总是继续执行，使 guard 无用。"

#: ../../language/error_codes/E1038.md:7
msgid ""
"One common mistake is, say if you want to return early on some condition,"
" and continues otherwise. However, since the pattern matching is "
"evaluated from first to last, the pattern after `guard let` will be first"
" evaluated and will always be success. Therefore, such code will not work"
" since all control will continue on and never returns early."
msgstr ""
"一个常见的错误是，比如你想在某些条件下提前返回，否则继续。然而，由于模式匹配是从前到后评估的，`guard let` "
"后的模式将首先被评估，并且总是成功。因此，这样的代码将不起作用，因为所有控制都将继续执行，并且永远不会提前返回。"

#: ../../language/error_codes/E1038.md:15
msgid ""
"fn f(input : Int?) -> Int {\n"
"  guard let _ = input else {\n"
"    Some(_..<0) => abort(\"Invalid input\")\n"
"  }\n"
"  3\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(f(None))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:30
msgid ""
"If you want all possible control flows goes through, then you can remove "
"the guard and just use let expression."
msgstr "如果你希望所有可能的控制流都通过，那么你可以移除 guard，只使用 let 表达式。"

#: ../../language/error_codes/E1038.md:33
msgid ""
"fn f(input : Int?) -> Int {\n"
"  let _ = input\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:40
msgid ""
"If you fail into the early return mistake, you can switch to `match` "
"expression:"
msgstr "如果你陷入了提前返回的错误，你可以切换到 `match` 表达式："

#: ../../language/error_codes/E1038.md:42
msgid ""
"fn f(input : Int?) -> Int {\n"
"  match input {\n"
"    Some(_..<0) => abort(\"Invalid input\")\n"
"    _ => ()\n"
"  }\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:1
msgid "E1039"
msgstr ""

#: ../../language/error_codes/E1039.md:3
msgid "Method name conflicts with another definition."
msgstr "方法名与另一个定义冲突。"

#: ../../language/error_codes/E1039.md:6
msgid ""
"Methods declared with the syntax `fn f(self : T, ..)` will be promoted to"
" regular function in the future, declare the method using `fn T::f(..)` "
"to avoid name clash."
msgstr "使用语法 `fn f(self : T, ..)` 声明的方法将在未来提升为常规函数，使用 `fn T::f(..)` 声明方法以避免名称冲突。"

#: ../../language/error_codes/E1039.md:13
msgid ""
"type A Int\n"
"\n"
"fn f() -> Int {\n"
"  3\n"
"}\n"
"\n"
"fn f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(A(3).f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:32
msgid "You can defined the method as `A::f`:"
msgstr "你可以将方法定义为 `A::f`："

#: ../../language/error_codes/E1039.md:34
msgid ""
"fn T::f(self : A) -> Int {\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:40
msgid ""
"However, defining a method with `T::` prefix makes it impossible to be "
"invoked as regular function. If you wish to call the method as regular "
"function, then you have to rename either the method name, or the regular "
"function name to resolve the name clash."
msgstr "但是，使用 `T::` 前缀定义方法将使其无法作为常规函数调用。如果你希望将方法作为常规函数调用，那么你必须重命名方法名或常规函数名以解决名称冲突。"

#: ../../language/error_codes/E1039.md:45
msgid ""
"fn f_(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  println(f_(A(3)))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:1
msgid "E1040"
msgstr ""

#: ../../language/error_codes/E1040.md:3
msgid ""
"This method is declared as `T::f`, Calling this kind of method directly "
"via name(..) is deprecated, use qualified syntax `T::f(..)`, or declare "
"the method as `fn f(self : A, ..)` instead."
msgstr ""
"这个方法被声明为 `T::f`，直接通过名称(..) 调用的语法被废弃了，使用限定语法 `T::f(..)`，或者将方法声明为 `fn "
"f(self : A, ..)`。"

#: ../../language/error_codes/E1040.md:9
msgid ""
"type A Int\n"
"\n"
"fn A::f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  let _ = f(A(1))\n"
"  // Warning:\n"
"  // This method is declared as A::f, calling this kind of method "
"directly via\n"
"  // f(..) is deprecated, use qualified syntax A::f(..), or declare the "
"method\n"
"  // as `fn f(self : A, ..)` instead.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:27
msgid "You can either modify the calling of this function at call sites:"
msgstr "你可以在调用点修改这个函数的调用："

#: ../../language/error_codes/E1040.md:29
msgid ""
"fn main {\n"
"  let _ = A::f(A(1))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:35
msgid "Or you can define the method as:"
msgstr "或者你可以将方法定义为："

#: ../../language/error_codes/E1040.md:37
msgid ""
"fn f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  let _ = f(A(1))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:1
msgid "E2000"
msgstr ""

#: ../../language/error_codes/E2000.md:3
msgid ""
"The usage of function (type, trait, etc.) is flagged with alert. Usually,"
" alert message comes with a alert kind and a detailed description of the "
"alert. If you are using the function from a library, these alerts are set"
" by the library author to provide some more information on the usage of "
"the function"
msgstr "函数（类型、特征等）的使用被标记为警告。通常，警告消息会带有警告类型和警告的详细描述。如果你正在使用来自库的函数，这些警告是由库作者设置的，以提供有关函数使用的更多信息。"

#: ../../language/error_codes/E2000.md:8
msgid "There are some common alerts that you may encounter:"
msgstr "以下是一些常见的警告："

#: ../../language/error_codes/E2000.md:10
msgid ""
"`deprecated`: indicates the function (or type, trait, etc.) is deprecated"
" and should not be used. You should migrate to new APIs."
msgstr "`deprecated`: 表示函数（类型、特征等）已被弃用，不应该使用。你应迁移到新的 API。"

#: ../../language/error_codes/E2000.md:12
msgid ""
"`unsafe`: indicates this API may panic, have internal invariants, or have"
" undefined behavior under some circumstances. The concrete semantics of "
"this kind of alerts may be different across packages, and please consult "
"the documentation or the author of these packages for further details."
msgstr ""
"`unsafe`: 表示该 API 可能会导致 "
"panic、具有内部不变式，或在某些情况下具有未定义的行为。对于这类警告的具体语义可能会因软件包而异，请咨询相关文档或软件包的作者以获得更多详细信息。"

#: ../../language/error_codes/E2000.md:19
msgid ""
"/// @alert deprecated \"Use `greet` instead\"\n"
"fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
"\n"
"fn greet(name~ : String = \"\") -> String {\n"
"  if name != \"\" {\n"
"    \"Hello!\"\n"
"  } else {\n"
"    \"Hello, \\{name}!\"\n"
"  }\n"
"}\n"
"\n"
"fn main {\n"
"  println(greeting())\n"
"  //      ^~~~~~~~ Warning (Alert deprecated): Use `greet` instead(2000)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:41
msgid ""
"One way to fix the alert, is to change your code as suggested by the "
"message (like `deprecated`):"
msgstr "修复警告的一种方法是按照消息中的建议更改代码（如 `deprecated`）："

#: ../../language/error_codes/E2000.md:43
msgid ""
"// ... code in the example above ...\n"
"fn main {\n"
"  println(greet(name=\"world\"))\n"
"}\n"
msgstr ""
"// ... 上方例子中的代码 ...\n"
"fn main {\n"
"  println(greet(name=\"world\"))\n"
"}\n"

#: ../../language/error_codes/E2000.md:50
msgid ""
"If you clearly know what you are doing and would like to suppress the "
"alert, you can change the `moon.pkg.json` file for packages where you "
"would like to disable **this kind of alert**. For example:"
msgstr "如果你清楚知道自己在做什么，并且想要抑制警告，你可以更改 `moon.pkg.json` 文件，以禁用**这种类型的警告**。例如："

#: ../../language/error_codes/E2000.md:52
msgid ""
"{\n"
"  // ... other fields in the file\n"
"  \"alert-list\": \"-deprecated\"\n"
"}\n"
msgstr ""
"{\n"
"  // ... 文件中的其他字段\n"
"  \"alert-list\": \"-deprecated\"\n"
"}\n"

#: ../../language/error_codes/E2000.md:60
msgid "There is no way to disable alerts for a line/file."
msgstr "无法为一行/文件禁用警告。"

#: ../../language/error_codes/E3001.md:1
msgid "E3001"
msgstr ""

#: ../../language/error_codes/E3001.md:3
msgid "This source files contains invalid or incomplete tokens."
msgstr "源文件包含无效或不完整的记号。"

#: ../../language/error_codes/E3001.md:7
msgid ""
"fn main {\n"
"  println('3)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3001.md:13
msgid "This example gives the following error on line 2:"
msgstr "这个例子在第 2 行给出了以下错误："

#: ../../language/error_codes/E3001.md:15
msgid "Lexing error: unrecognized character u32:0x27\n"
msgstr ""

#: ../../language/error_codes/E3001.md:19
msgid ""
"... which indicates that the compiler don't know how to interpret the "
"dangling character `'` (ASCII 0x27) on that line as a part of a MoonBit "
"token."
msgstr "这表明编译器不知道如何将该行上的悬空字符 `'`（ASCII 0x27）解释为 MoonBit 记号的一部分。"

#: ../../language/error_codes/E3001.md:25
msgid ""
"Change your code to strictly follow the MoonBit syntax rules, so that it "
"only contains valid MoonBit tokens."
msgstr "更改你的代码，严格遵循 MoonBit 语法规则，确保它仅包含有效的 MoonBit 记号。"

#: ../../language/error_codes/E3001.md:28
msgid "In the above example, the missing closing apostrophe should be added:"
msgstr "在上面的例子中，应该添加缺失的闭合撇号："

#: ../../language/error_codes/E3001.md:30
msgid ""
"fn main {\n"
"  println('3')\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3002.md:1
msgid "E3002"
msgstr ""

#: ../../language/error_codes/E3002.md:3
msgid "This source files contains errors in the syntax of the code."
msgstr "这个源文件包含代码语法错误。"

#: ../../language/error_codes/E3002.md:7
msgid ""
"fn main() -> Unit {\n"
"  println(\"Hello, world!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3002.md:13
msgid "This example gives the following error on line 3:"
msgstr "这个例子在第 3 行给出了以下错误："

#: ../../language/error_codes/E3002.md:15
msgid "Parse error, unexpected token `}`, you may expect `,` or `)`.\n"
msgstr ""

#: ../../language/error_codes/E3002.md:19
msgid ""
"... which indicates a missing closing parenthesis (`)`) in the `println` "
"function call."
msgstr "这表明 `println` 函数调用中缺少闭合括号（`）`）。"

#: ../../language/error_codes/E3002.md:23
msgid "Change your code to strictly follow the MoonBit syntax rules."
msgstr "更改你的代码，严格遵循 MoonBit 语法规则。"

#: ../../language/error_codes/E3002.md:25
msgid "In the above example, the missing closing parenthesis should be added:"
msgstr ""

#: ../../language/error_codes/E3003.md:1
msgid "E3003"
msgstr ""

#: ../../language/error_codes/E3003.md:3
msgid "`init` and `main` function must have no arguments and no return value."
msgstr "`init` 与 `main` 函数不得有参数列表或返回类型。"

#: ../../language/error_codes/E3003.md:7
msgid ""
"fn main() -> Unit { // Error: Main function must have no arguments and no"
" return value.\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3003.md:15
msgid "Remove the argument list and return type annotation, as:"
msgstr "删除参数列表和返回类型注释，如："

#: ../../language/error_codes/E3004.md:1
msgid "E3004"
msgstr ""

#: ../../language/error_codes/E3004.md:3
msgid ""
"Missing parameters list. Add `()` after the name of the function if it "
"takes 0 parameter."
msgstr "缺少参数列表。如果函数不接受参数，在函数名后添加 `()`。"

#: ../../language/error_codes/E3004.md:8
msgid ""
"fn greet { // Error: Missing parameters list. Add `()` if function "
"`greet` has 0 parameter.\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3004.md:16
msgid "Add `()` after the function name."
msgstr "在函数名后添加 `()`。"

#: ../../language/error_codes/E3004.md:18
msgid ""
"fn greet() {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3005.md:1
msgid "E3005"
msgstr ""

#: ../../language/error_codes/E3005.md:3
msgid "There is no such visibility for the entity (function/type/trait/...)."
msgstr "对象没有这样的可见性（函数/类型/特征/...）。"

#: ../../language/error_codes/E3005.md:5
msgid ""
"Usually, this means that you put an `priv` visibility modifier on a "
"entity is by-default private."
msgstr "通常，这意味着你在一个默认为私有的对象上放置了 `priv` 可见性修饰符。"

#: ../../language/error_codes/E3005.md:8
msgid ""
"See the [Access Control](/language/packages.md#access-control) section of"
" for a detailed explanation on the visibility in MoonBit."
msgstr "查看 [访问控制](/language/packages.md#access-control) 中的详细说明。"

#: ../../language/error_codes/E3005.md:13
msgid "priv let value = 3 // Error: No 'priv' visibility for value.\n"
msgstr ""

#: ../../language/error_codes/E3005.md:19
msgid "Remove the visibility modifier from the definition of the entity:"
msgstr "移除对象定义中的可见性修饰符："

#: ../../language/error_codes/E3005.md:21
msgid "let value = 3 // This is already `priv` by default.\n"
msgstr "let value = 3 // 这默认为 `priv`。"

#: ../../language/error_codes/E3006.md:1
msgid "E3006"
msgstr ""

#: ../../language/error_codes/E3006.md:3
msgid "There is no individual visibility control for enum constructors."
msgstr "枚举构造器没有独立的可见性控制。"

#: ../../language/error_codes/E3006.md:5
msgid ""
"Usually, this means that you put an `priv` or `pub` visibility modifier "
"on a enum constructor."
msgstr "通常这意味着你在枚举构造器前放置了 `priv` 或者 `pub` 可见性修饰符。"

#: ../../language/error_codes/E3006.md:9
msgid ""
"enum A {\n"
"  priv A1 // Error: No individual visibility for enum constructor.\n"
"  pub A2 // Error: No individual visibility for enum constructor.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3006.md:18
msgid ""
"Remove the visibility modifier from the definition of the enum "
"constructor:"
msgstr "从枚举构造器前移除可见性修饰符："

#: ../../language/error_codes/E3006.md:20
msgid ""
"enum A {\n"
"  A1\n"
"  A2\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3007.md:1
msgid "E3007"
msgstr ""

#: ../../language/error_codes/E3007.md:3
msgid ""
"Wrong location of `..` in pattern match. Put `..` at the end of the "
"pattern."
msgstr "错误的 `..` 位置。请将 `..` 放在模式的最后。"

#: ../../language/error_codes/E3007.md:7
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"  c : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2, c : 3 }\n"
"  let { a, .., c } = s\n"
"  //       ^^\n"
"  // Error: Unexpected `..` here, add `, ..` behind the last field to "
"ignore the rest of record.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3007.md:24
msgid ""
"// ...\n"
"fn main {\n"
"  // ...\n"
"  let { a, c, .. } = s\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3008.md:1
msgid "E3008"
msgstr ""

#: ../../language/error_codes/E3008.md:3
msgid ""
"There are multiple `..` patterns in array pattern. Remove until there is "
"only one `..` pattern in array pattern."
msgstr "在数组模式中有多个 `..` 模式。请在数组模式中仅保留一个 `..` 模式。"

#: ../../language/error_codes/E3008.md:7
msgid ""
"fn main {\n"
"  let array = [1, 2, 3, 4, 5]\n"
"  let [fst, .., .., snd] = array\n"
"  //            ^^\n"
"  // Error: At most one `..` is allowed in array pattern.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3008.md:18
msgid "Remove the extra `..` pattern."
msgstr "移除多余的 `..` 模式。"

#: ../../language/error_codes/E3008.md:20
msgid ""
"fn main {\n"
"  // ...\n"
"  let [fst, .., snd] = array\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:1
msgid "E3009"
msgstr ""

#: ../../language/error_codes/E3009.md:3
msgid "Record pattern cannot contain only `..`, use wildcard pattern `_` instead."
msgstr "结构体模式不能仅包含 `..`，请使用通配符模式 `_`。"

#: ../../language/error_codes/E3009.md:7
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn process_point(p: Point) -> Unit {\n"
"  match p {\n"
"    { .. } => println(\"Got a point\")\n"
"  //^~~~~~\n"
"  // Error: Record pattern cannot contain only `..`, use wildcard pattern"
" `_` instead.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:24
msgid "Use the wildcard pattern `_` instead of `{ .. }`:"
msgstr "使用通配符模式 `_` 代替 `{ .. }`："

#: ../../language/error_codes/E3009.md:26
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn process_point(p: Point) -> Unit {\n"
"  match p {\n"
"    _ => println(\"Got a point\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:39
msgid ""
"You can also use `{ .. }` along with other fields if you want to match "
"specific fields:"
msgstr "如果你想匹配特定字段的话，你也可以与其他字段一起使用 `{ .. }`："

#: ../../language/error_codes/E3009.md:41
msgid ""
"fn process_point(p: Point) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"Point on y-axis\")\n"
"    _ => println(\"Other point\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3010.md:1
msgid "E3010"
msgstr ""

#: ../../language/error_codes/E3010.md:3
msgid "Only labelled arguments can have default value."
msgstr "只有带标签参数才可以有默认值。"

#: ../../language/error_codes/E3010.md:7
msgid ""
"fn greet(name : String = \"World\") -> Unit {\n"
"  //                   ^ Error: Only labelled arguments can have default "
"value.\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3010.md:16
msgid "Use a labelled argument with `~` if you want to provide a default value:"
msgstr "如果你想提供默认值，用 `~` 定义一个带标签的参数。"

#: ../../language/error_codes/E3010.md:18
msgid ""
"fn greet(name~ : String = \"World\") -> Unit {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
"\n"
"fn main {\n"
"  // Can be called as:\n"
"  greet() // Uses default value \"World\"\n"
"  greet(name=\"Alice\") // Uses provided value \"Alice\"\n"
"}\n"
msgstr ""
"fn greet(name~ : String = \"World\") -> Unit {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
"\n"
"fn main {\n"
"  // 可以这样调用:\n"
"  greet() // 使用默认值 \"World\"\n"
"  greet(name=\"Alice\") // 使用提供值 \"Alice\"\n"
"}\n"

#: ../../language/error_codes/E3010.md:30
msgid ""
"Or remove the default value if you want to keep it as a positional "
"argument:"
msgstr "或者如果你想保持它为一个位置参数，移除默认值："

#: ../../language/error_codes/E3010.md:32
msgid ""
"fn greet(name: String) -> Unit {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3011.md:1
msgid "E3011"
msgstr ""

#: ../../language/error_codes/E3011.md:3
msgid ""
"The assignment contains an invalid left-hand-side (LHS) expression, such "
"as a constant or a constructor."
msgstr "赋值包含一个无效的左侧表达式，例如常量或构造函数。"

#: ../../language/error_codes/E3011.md:8
msgid ""
"const N = 4\n"
"\n"
"fn main {\n"
"  N = 5 // Error: Invalid left value for assignment.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3011.md:18
msgid ""
"Change the LHS to a valid mutable memory location, such as a mutable "
"variable or a mutable field:"
msgstr "将左侧表达式改为一个合法的可变的内存位置，例如一个可变变量或者一个可变字段："

#: ../../language/error_codes/E3011.md:21
msgid ""
"fn main {\n"
"  let mut n = 4\n"
"  n = 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:1
msgid "E3012"
msgstr ""

#: ../../language/error_codes/E3012.md:3
msgid ""
"Record pattern and map pattern cannot be mixed. The key in map pattern "
"must be a literal, while the key in record pattern must be the field "
"name."
msgstr "结构体模式和字典模式不能被混用。字典模式中的键必须是字面量，而结构体模式的键必须是字段名。"

#: ../../language/error_codes/E3012.md:8
msgid ""
"struct S {\n"
"  value : Int\n"
"}\n"
"\n"
"pub fn S::op_get(self : S, index : String) -> Int? {\n"
"  if index == \"value\" {\n"
"    return Some(self.value)\n"
"  }\n"
"  return None\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { \"value\": value, value } => println(\"Value is: \\{value}\") // "
"Error: Record pattern and map pattern cannot be mixed.\n"
"    _ => println(\"No value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:31
msgid ""
"Remove either the map pattern part or the record pattern part from the "
"pattern."
msgstr "从模式中移除字典模式部分或结构体模式部分。"

#: ../../language/error_codes/E3012.md:33
msgid ""
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { \"value\": value } => println(\"Value is: \\{value}\")\n"
"    _ => println(\"No value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:45
msgid ""
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { value } => println(\"Value is: \\{value}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3014.md:1
msgid "E3014"
msgstr ""

#: ../../language/error_codes/E3014.md:3
msgid ""
"Inline wasm syntax error. MoonBit will check if the inline wasm syntax is"
" correct, including:"
msgstr "内联 Wasm 语法错误。MoonBit 会检查内联 Wasm 是否正确，包括："

#: ../../language/error_codes/E3014.md:5
msgid "If the parenthesis are correctly matched."
msgstr "括号是否正确配对。"

#: ../../language/error_codes/E3014.md:6
msgid "If the wasm instructions are correctly formatted."
msgstr "Wasm 指令是否正确格式化。"

#: ../../language/error_codes/E3014.md:10
msgid ""
"extern \"wasm\" fn i32_load(addr : Int) -> Int = // Error: Inline wasm "
"syntax error: unmatched parenthesis at 1:1-1:57\n"
"  #|(func (param i32) (result i32)\n"
"  #| (i32.load (local.get 0))\n"
msgstr ""

#: ../../language/error_codes/E3014.md:18
msgid "Fix the inline wasm syntax as suggested by the warning message."
msgstr "根据错误信息的建议修正内联 Wasm。"

#: ../../language/error_codes/E3014.md:20
msgid ""
"extern \"wasm\" fn i32_load(addr : Int) -> Int =\n"
"  #|(func (param i32) (result i32)\n"
"  #| (i32.load (local.get 0)))\n"
msgstr ""

#: ../../language/error_codes/E3015.md:1
msgid "E3015"
msgstr ""

#: ../../language/error_codes/E3015.md:3
msgid "The parameter already has default value `None`."
msgstr "参数已经有默认值 `None`。"

#: ../../language/error_codes/E3015.md:5
msgid "In MoonBit, the optional parameter has one of the two following forms:"
msgstr "在 MoonBit 中，可选参数有如下两种形式："

#: ../../language/error_codes/E3015.md:7
msgid "Optional parameter with default value:"
msgstr "有参数的可选值："

#: ../../language/error_codes/E3015.md:9
msgid ""
"fn f(a~ : Int = 0) -> Unit {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3015.md:15
msgid ""
"Optional parameter with no default value. In this case, when the "
"parameter is not provided, it is `None` by default."
msgstr "无参数的可选值。在这种情况下，如果参数没有提供，则默认为 `None`。"

#: ../../language/error_codes/E3015.md:17
msgid ""
"fn f(a? : Int) -> Unit { // a has type Int?\n"
"  // ...\n"
"}\n"
msgstr ""
"fn f(a? : Int) -> Unit { // a 的类型为 Int?\n"
"  // ...\n"
"}\n"

#: ../../language/error_codes/E3015.md:23
msgid ""
"Therefore, if the optional parameter has a default value of `None`, it is"
" redundant and should be removed."
msgstr "因此，如果可选参数的默认值为 `None`，提供默认值就是多余的，应该删除。"

#: ../../language/error_codes/E3015.md:27
msgid ""
"fn f(a? : Int = None) -> Unit { // Error: The parameter a? already has "
"default value `None`.\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3015.md:35
msgid "Remove the `= None` part from the optional parameter."
msgstr "从可选参数中移除 `= None` 部分"

#: ../../language/error_codes/E3015.md:37
msgid ""
"fn f(a? : Int) -> Unit {\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:1
msgid "E3016"
msgstr ""

#: ../../language/error_codes/E3016.md:3
msgid "Unexpected `~` in argument. Did you mean `label=pattern` or `label~`?"
msgstr "参数中出现了意外的 `~`。你是不是想要 `label=pattern` 或 `label~`？"

#: ../../language/error_codes/E3016.md:7
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b~=c) => {\n"
"      println(\"Hello, world! \\{c}\") // Error: unexpected `~` in "
"argument. Did you mean `label=pattern` or `label~`?\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:23
msgid "Replace `b~` with `b=` or `b~` as appropriate."
msgstr "将 `b~` 替换为适当的 `b=` 或 `b~`。"

#: ../../language/error_codes/E3016.md:25
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b~) => {\n"
"      println(\"Hello, world! \\{b}\")\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:41
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b=c) => {\n"
"      println(\"Hello, world! \\{c}\")\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3017.md:1
msgid "E3017"
msgstr ""

#: ../../language/error_codes/E3017.md:3
msgid "JSON parse error. This will only appear in `moon.pkg.json` files only."
msgstr "JSON 解析错误。这只会出现在 `moon.pkg.json` 文件中。"

#: ../../language/error_codes/E3017.md:5
msgid ""
"It is very like that the editor you are using will have support for JSON "
"installed (for example, Visual Studio Code has a built-in JSON parser). "
"This error is likely to be caused by a missing comma or a missing closing"
" brace."
msgstr ""
"您使用的编辑器可能已经安装对 JSON 的支持（例如，Visual Studio Code 有内置的 JSON "
"解析器）。此错误可能是由于缺少逗号或缺少结束大括号引起的。"

#: ../../language/error_codes/E3017.md:11
msgid ""
"{\n"
"  \"is-main\": true\n"
"  \"import\": [] // Error: Expect_comma_or_rbrace\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3017.md:20
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": []\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:1
msgid "E3018"
msgstr ""

#: ../../language/error_codes/E3018.md:3
msgid "Bounds of range pattern must be constant, named constant or wildcard."
msgstr "范围模式的边界必须是常数字面量、常量或通配符。"

#: ../../language/error_codes/E3018.md:7
msgid ""
"fn main {\n"
"  let a = 3\n"
"  match 0 {\n"
"    0..<a => println(\"Between 0 and 3\") // Error: Bounds of range "
"pattern must be constant, named constant or wildcard.\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:19
msgid "You can either lift the variable `a` to a named constant:"
msgstr "你可以将变量 `a` 改为一个常量："

#: ../../language/error_codes/E3018.md:21
msgid ""
"const A = 3\n"
"fn main {\n"
"  match 0 {\n"
"    0..<A => println(\"Between 0 and 3\")\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:31
msgid "Or, you can use the constant value directly:"
msgstr "或者，你可以直接使用常数字面量："

#: ../../language/error_codes/E3018.md:33
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..<3 => println(\"Between 0 and 3\")\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:42
msgid "Or, you can use a wildcard:"
msgstr "或者，你可以使用一个通配符："

#: ../../language/error_codes/E3018.md:44
msgid ""
"fn main {\n"
"  let a = 3\n"
"  match 0 {\n"
"    0..<_ => println(\"Big than or equal to 0\")\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:54
msgid "Notice, using wildcard alters the meaning of this range pattern."
msgstr "注意：使用通配符会改变这个范围模式的含义。"

#: ../../language/error_codes/E3019.md:1
msgid "E3019"
msgstr ""

#: ../../language/error_codes/E3019.md:3
msgid "Inclusive range pattern `a..=b` cannot have `_` as upper bound."
msgstr "包含的范围模式 `a..=b` 的上界不能是 `_`。"

#: ../../language/error_codes/E3019.md:5
msgid ""
"Writing `a..=_` does not make sense, because `_` is a wildcard that "
"matches any value. It is unclear what does \"equals to any value\" mean. "
"If you want to express the meaning of \"greater than or equal to `a`\", "
"you can use `a..<_` instead."
msgstr ""
"书写 `a..=_` 没有意义，因为 `_` 是一个通配符，可以匹配任何值。\"等于任何值\" 的含义不明确。如果你想表达 \"大于或等于 "
"`a`\" 的含义，你可以使用 `a..<_`。"

#: ../../language/error_codes/E3019.md:12
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..=_ => println(\"Big than or equal to 0\")\n"
"    //  ^\n"
"    // Error: Inclusive range pattern `a..=b` cannot have `_` as upper "
"bound\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3019.md:25
msgid "Replace `=` with `<`:"
msgstr "将 `=` 替换为 `<`："

#: ../../language/error_codes/E3019.md:27
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..<_ => println(\"Big than or equal to 0\")\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3020.md:1
msgid "E3020"
msgstr ""

#: ../../language/error_codes/E3020.md:3
msgid ""
"Unexpected `=` in struct expression. The correct syntax for struct "
"expression is `{ field: expression }`."
msgstr "结构体表达式中出现了意外的 `=`。结构体表达式的正确语法是 `{ field: expression }`。"

#: ../../language/error_codes/E3020.md:8
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2 }\n"
"  let ss = { ..s, a = 1 } // Error: Unexpected `=` in struct expression.\n"
"  ignore(ss)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3020.md:23
msgid "Change the struct expression to use the correct syntax:"
msgstr "更改结构体表达式，使用正确的语法："

#: ../../language/error_codes/E3020.md:25
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2 }\n"
"  let ss = { ..s, a : 1 }\n"
"  ignore(ss)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3800.md:1
msgid "E3800"
msgstr ""

#: ../../language/error_codes/E3800.md:3
msgid "Expecting a newline or `;` here, but encountered another delimiter."
msgstr "这里期望一个换行符或 `;`，但遇到了另一个分隔符。"

#: ../../language/error_codes/E3800.md:5
msgid ""
"Constructors in `enum` definition, fields in `struct` definition, and "
"constructors in error type `type!` definition, should be separated by a "
"newline or a `;`. It is so common for AI to generate code with a wrong "
"delimiter `,` that we specifically catch this error to help you and AI "
"fix it."
msgstr ""
"`enum` 定义中的构造器、`struct` 定义中的字段和错误类型 `type!` 定义中的构造器，应该用换行符或 `;` 分隔。AI "
"生成的代码中常常会出现错误的分隔符 `,`，因此我们特意捕获这个错误来帮助你和 AI 修复它。"

#: ../../language/error_codes/E3800.md:12
msgid ""
"enum V {\n"
"  A, // Error: Expecting a newline or `;` here, but encountered another "
"delimiter `,`.\n"
"}\n"
"\n"
"struct S {\n"
"  a : Int, // Error: Expecting a newline or `;` here, but encountered "
"another delimiter `,`.\n"
"}\n"
"\n"
"type! E {\n"
"  A, // Error: Expecting a newline or `;` here, but encountered another "
"delimiter `,`.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3800.md:28
msgid ""
"Replace `,` with a newline or `;` as appropriate. We suggest using a "
"newline since it conforms to the MoonBit style suggested by the MoonBit "
"formatter."
msgstr "将 `,` 替换为适当的换行符或 `;`。我们建议使用换行符，因为它符合 MoonBit 格式化程序建议的 MoonBit 风格。"

#: ../../language/error_codes/E3800.md:31
msgid ""
"enum V {\n"
"  A\n"
"}\n"
"\n"
"struct S {\n"
"  a : Int\n"
"}\n"
"\n"
"type! E {\n"
"  A\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:1
msgid "E4000"
msgstr ""

#: ../../language/error_codes/E4000.md:3
msgid "Generic type variable name is already used."
msgstr "类型变量名称已被使用。"

#: ../../language/error_codes/E4000.md:7
msgid ""
"struct Container[T, T] {\n"
"  value : T\n"
"}\n"
"\n"
"fn transform[A, A](x : A) -> A {\n"
"  x\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:19
msgid "Use different names for type variables:"
msgstr "使用不同的类型变量名称："

#: ../../language/error_codes/E4000.md:21
msgid ""
"struct Container[T1, T2] {\n"
"  value : T1\n"
"}\n"
"\n"
"fn transform[A, B](x : A) -> B {\n"
"  // ... implementation\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:31
msgid "Or remove the duplicate type parameter if you meant to use the same type:"
msgstr "或者如果你想使用相同的类型，移除重复的类型参数："

#: ../../language/error_codes/E4000.md:33
msgid ""
"struct Container[T] {\n"
"  value : T\n"
"}\n"
"\n"
"fn transform[A](x : A) -> A {\n"
"  x\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4001.md:1
msgid "E4001"
msgstr ""

#: ../../language/error_codes/E4001.md:3
msgid "A field with incompatible visibility cannot be declared within a struct."
msgstr "结构体字段的可见性不兼容。"

#: ../../language/error_codes/E4001.md:5
msgid "The following visibility combinations are allowed:"
msgstr "以下可见性组合是允许的："

#: ../../language/error_codes/E4001.md:7
msgid ""
"A public field within a public struct, although it will emit a warning "
"[E1008](./E1008.md)."
msgstr "公开结构体和公开字段，虽然这会产生一个警告 [E1008](./E1008.md)。"

#: ../../language/error_codes/E4001.md:9
msgid "A private field within a public struct."
msgstr "公开结构体和私有字段。\n"

#: ../../language/error_codes/E4001.md:10
msgid ""
"A private field within a private struct, emitting [E1008](./E1008.md) as "
"well."
msgstr "私有结构体和私有字段，虽然也会产生 [E1008](./E1008.md) 警告。"

#: ../../language/error_codes/E4001.md:12 ../../language/error_codes/E4002.md:5
#: ../../language/error_codes/E4003.md:5 ../../language/error_codes/E4004.md:6
#: ../../language/error_codes/E4006.md:5 ../../language/error_codes/E4008.md:5
#: ../../language/error_codes/E4009.md:5 ../../language/error_codes/E4010.md:6
#: ../../language/error_codes/E4011.md:5 ../../language/error_codes/E4012.md:5
#: ../../language/error_codes/E4013.md:5 ../../language/error_codes/E4014.md:5
#: ../../language/error_codes/E4015.md:5 ../../language/error_codes/E4016.md:5
#: ../../language/error_codes/E4017.md:5 ../../language/error_codes/E4018.md:5
#: ../../language/error_codes/E4019.md:5 ../../language/error_codes/E4020.md:5
#: ../../language/error_codes/E4021.md:5 ../../language/error_codes/E4023.md:5
#: ../../language/error_codes/E4024.md:5 ../../language/error_codes/E4025.md:5
#: ../../language/error_codes/E4026.md:5 ../../language/error_codes/E4027.md:5
#: ../../language/error_codes/E4028.md:5 ../../language/error_codes/E4029.md:5
#: ../../language/error_codes/E4030.md:5 ../../language/error_codes/E4031.md:5
#: ../../language/error_codes/E4033.md:5 ../../language/error_codes/E4034.md:5
#: ../../language/error_codes/E4036.md:5 ../../language/error_codes/E4037.md:5
#: ../../language/error_codes/E4038.md:5 ../../language/error_codes/E4039.md:5
#: ../../language/error_codes/E4040.md:5 ../../language/error_codes/E4041.md:5
#: ../../language/error_codes/E4042.md:11 ../../language/error_codes/E4043.md:5
#: ../../language/error_codes/E4044.md:5 ../../language/error_codes/E4045.md:5
#: ../../language/error_codes/E4046.md:5 ../../language/error_codes/E4081.md:9
#: ../../language/error_codes/E4082.md:9 ../../language/error_codes/E4084.md:5
#: ../../language/error_codes/E4085.md:11
#: ../../language/error_codes/E4087.md:10
msgid "Erroneous Example"
msgstr "错误示例："

#: ../../language/error_codes/E4001.md:14
msgid ""
"priv struct S {\n"
"  pub field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4001.md:20
msgid ""
"This example declares a field with public visibility within a struct with"
" private visibility, which is not allowed and will give the following "
"error on line 2:"
msgstr "这个例子在一个私有结构体中声明了一个公开可见性的字段，这是不允许的，会在第 2 行报错："

#: ../../language/error_codes/E4001.md:24
msgid "A public field cannot be declared within a private struct.\n"
msgstr "一个公开字段不能在私有结构体中声明。\n"

#: ../../language/error_codes/E4001.md:30
#: ../../language/error_codes/E4002.md:22
msgid "Change the visibility of the field to match the visibility of the struct:"
msgstr "将字段的可见性修改至与结构体的可见性匹配："

#: ../../language/error_codes/E4001.md:32
msgid ""
"priv struct S {\n"
"  field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4001.md:38
msgid ""
"We could have written `priv field: Int` instead of `field: Int` as well, "
"but it is not necessary, as all fields in a private struct are private by"
" default."
msgstr "我们可以将 `field: Int` 改为 `priv field: Int`，但这并不是必要的，因为私有结构体中的所有字段默认都是私有的。"

#: ../../language/error_codes/E4002.md:1
msgid "E4002"
msgstr ""

#: ../../language/error_codes/E4002.md:3
msgid "The modifier is not supported here."
msgstr "这里不支持这个修饰符"

#: ../../language/error_codes/E4002.md:7
msgid ""
"pub struct S {\n"
"  pub(open) field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4002.md:13
msgid ""
"This example declares a field with the `pub(open)` visibility modifier, "
"which is not allowed and will give the following error on line 2:"
msgstr "这个例子在一个字段中声明了 `pub(open)` 可见性修饰符，这是不允许的，会在第 2 行报错："

#: ../../language/error_codes/E4002.md:16
msgid "The public open modifier is not supported here\n"
msgstr "这里不支持公开且开放修饰符\n"

#: ../../language/error_codes/E4002.md:24
msgid ""
"pub struct S {\n"
"  field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4002.md:30
msgid ""
"We could have written `pub field: Int` instead of `field: Int` as well, "
"but it is not necessary, as all fields in a public struct are public by "
"default."
msgstr "我们可以将 `field: Int` 改为 `pub field: Int`，但这并不是必要的，因为公开结构体中的所有字段默认都是公开的。"

#: ../../language/error_codes/E4003.md:1
msgid "E4003"
msgstr ""

#: ../../language/error_codes/E4003.md:3
msgid ""
"This is a reserved type name. Cannot declare it as a type variable, type,"
" or trait."
msgstr "这是一个保留的类型名称。不能将其声明为类型变量、类型或特性。"

#: ../../language/error_codes/E4003.md:7
msgid "struct Error {}\n"
msgstr ""

#: ../../language/error_codes/E4003.md:11
msgid ""
"`Error` is the reserved name for the built-in error type, so it cannot be"
" used for a custom type. This will give the following error on line 1:"
msgstr "`Error` 是内置错误类型的保留名称，因此不能用于自定义类型。这会在第 1 行出现如下错误："

#: ../../language/error_codes/E4003.md:14
msgid "\"Error\" is a reserved type name. Cannot declare it as type\n"
msgstr ""

#: ../../language/error_codes/E4003.md:20
msgid "Consider using another name for your type, such as `MyError` or `Error_`."
msgstr "考虑将你的类型命名为其他名称，例如 `MyError` 或 `Error_`。"

#: ../../language/error_codes/E4003.md:22
msgid "struct MyError {}\n"
msgstr ""

#: ../../language/error_codes/E4004.md:1
msgid "E4004"
msgstr ""

#: ../../language/error_codes/E4004.md:3
msgid ""
"Trait methods cannot have type parameters (be polymorphic). MoonBit "
"currently does not support generic/polymorphic methods within trait "
"definitions."
msgstr "特征方法不能有类型参数（不能是多态的）。MoonBit 目前不支持特征定义中的泛型/多态方法。"

#: ../../language/error_codes/E4004.md:8
msgid ""
"trait Stringer {\n"
"  stringify[T: Show](Self, T) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4004.md:16
msgid "Consider using dynamic dispatch instead of generics:"
msgstr "考虑使用动态分发而不是泛型："

#: ../../language/error_codes/E4004.md:18
msgid ""
"trait Stringer {\n"
"  stringify(Self, &Show) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:1
msgid "E4005"
msgstr ""

#: ../../language/error_codes/E4005.md:3
msgid ""
"This error occurs when a trait has multiple declarations of the same "
"method name. Each method in a trait must have a unique name to avoid "
"ambiguity."
msgstr "这个错误发生在一个特征有多个相同方法名的声明时。特征中的每个方法必须有一个唯一的名称，以避免歧义。"

#: ../../language/error_codes/E4005.md:7
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String\n"
"  make_sound(Self) -> String  // Error: method make_sound is declared "
"twice\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:16
msgid ""
"Remove the duplicate method declaration and keep only one definition for "
"each method name:"
msgstr "移除重复的方法声明，只保留每个方法名的一个定义："

#: ../../language/error_codes/E4005.md:18
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String  // Only declare the method once\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:24
msgid "If you need different method behaviors, use distinct method names:"
msgstr "如果你需要不同的方法行为，使用不同的方法名称："

#: ../../language/error_codes/E4005.md:26
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String\n"
"  make_loud_sound(Self) -> String  // Use a different name for different "
"behavior\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:1
msgid "E4006"
msgstr ""

#: ../../language/error_codes/E4006.md:3
msgid ""
"This error occurs when the same local function name is declared multiple "
"times within the same scope. Each local function name must be unique "
"within its scope."
msgstr "这个错误会在同一个作用域内声明多次相同的局部函数名时发生。每个局部函数名在其作用域内必须唯一。"

#: ../../language/error_codes/E4006.md:7
msgid ""
"fn main {\n"
"  fn helper() {\n"
"    1 + 1\n"
"  }\n"
"\n"
"  fn helper() { // E4006: local function 'helper' is already defined\n"
"    2 + 2\n"
"  }\n"
"\n"
"  helper()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:23
msgid "To fix this error, give each local function a unique name:"
msgstr "要修复这个错误，给每个局部函数一个唯一的名称："

#: ../../language/error_codes/E4006.md:25
msgid ""
"fn main {\n"
"  fn helper1() {\n"
"    1 + 1\n"
"  }\n"
"\n"
"  fn helper2() {\n"
"    2 + 2\n"
"  }\n"
"\n"
"  helper1()\n"
"  helper2()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:40
msgid ""
"You can also move one of the functions to a different scope or merge the "
"functionality into a single function if they serve similar purposes."
msgstr "你也可以把其中一个函数移动到别的作用域，或者将它们合并到一个函数中（如果功能类似）。"

#: ../../language/error_codes/E4007.md:1
msgid "E4007"
msgstr ""

#: ../../language/error_codes/E4007.md:3
msgid ""
"When constructing an enum, the arguments passed to the constructor cannot"
" be unit `()`. MoonBit does not allow constructors to take unit as an "
"argument because it would be redundant - a constructor without arguments "
"already represents a singleton value."
msgstr ""

#: ../../language/error_codes/E4007.md:10
msgid ""
"enum Status {\n"
"  Done\n"
"  Pending\n"
"}\n"
"\n"
"fn main {\n"
"  let status = Done() // Error: constructor can't take unit as argument\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4007.md:23
msgid "Remove the unit argument from the constructor since it adds no value:"
msgstr ""

#: ../../language/error_codes/E4007.md:25
msgid ""
"// ...\n"
"fn main {\n"
"  let status = Done\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4007.md:32
msgid ""
"If you really need the constructor to take a unit arguments, explicitly "
"use `Unit` as its argument"
msgstr ""

#: ../../language/error_codes/E4007.md:35
msgid ""
"enum Status {\n"
"  Done(Unit)\n"
"  Pending\n"
"}\n"
"\n"
"fn main {\n"
"  let status = Done(())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4008.md:1
msgid "E4008"
msgstr ""

#: ../../language/error_codes/E4008.md:3
msgid "FFI function cannot have type parameters."
msgstr "FFI 函数不能有类型参数。"

#: ../../language/error_codes/E4008.md:7
msgid "extern \"js\" fn id[T](x: T) -> T = \"(x) => x\"\n"
msgstr ""

#: ../../language/error_codes/E4008.md:11
msgid ""
"The example declares an FFI function (marked `extern`) with a type "
"parameter, which is not allowed."
msgstr "这个例子中，FFI 函数（用 `extern` 标识）带有一个类型参数，而这是不允许的。"

#: ../../language/error_codes/E4008.md:16
msgid "Consider using a concrete type that suits your needs:"
msgstr "考虑使用符合你需求的具体类型："

#: ../../language/error_codes/E4008.md:18
msgid "extern \"js\" fn int_id(x: Int) -> Int = \"(x) => x\"\n"
msgstr ""

#: ../../language/error_codes/E4008.md:22
msgid "For more complicated scenarios, consider adding an extra trait:"
msgstr "对于更复杂的场景，考虑添加一个额外的特征："

#: ../../language/error_codes/E4008.md:24
msgid ""
"///|\n"
"trait Ider {\n"
"  id(Self) -> Self\n"
"}\n"
"\n"
"///|\n"
"impl Ider for Int with id(self) { int_id(self) }\n"
msgstr ""

#: ../../language/error_codes/E4009.md:1
msgid "E4009"
msgstr ""

#: ../../language/error_codes/E4009.md:3
msgid "Match function expects a different number of arguments than provided."
msgstr "匹配函数期望的参数数量与提供的数量不同。"

#: ../../language/error_codes/E4009.md:7
msgid ""
"let f = fn {\n"
"  0 => 0\n"
"  a, b => a + b\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4009.md:14
msgid ""
"The example defines a match function that has incoherent number of "
"arguments in different branches. This will result in the following error "
"on line 3:"
msgstr "这个例子定义了一个匹配函数，但是不同分支的参数数量不一致。这会在第三行出现如下错误："

#: ../../language/error_codes/E4009.md:17
msgid "Match function expects 1 arguments, but 2 arguments are provided.\n"
msgstr ""

#: ../../language/error_codes/E4009.md:23
msgid ""
"Change the branches so that the number of arguments are exactly the same "
"in all of them:"
msgstr "修改分支使得所有分支的参数数量相同："

#: ../../language/error_codes/E4009.md:26
msgid ""
"let f = fn {\n"
"  0 => 0\n"
"  a => a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4010.md:1
msgid "E4010"
msgstr ""

#: ../../language/error_codes/E4010.md:3
msgid ""
"`pub` is not allowed on default implementation for traits. The default "
"implementation has the same visibility as the trait itself."
msgstr ""

#: ../../language/error_codes/E4010.md:8
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"pub impl Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4010.md:16
msgid ""
"In the example above, the `pub` keyword is used on the default "
"implementation of the `Stringer` trait, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4010.md:21
msgid ""
"Remove the `pub` keyword so that the default implementation has the same "
"visibility as the trait itself:"
msgstr "移除 `pub` 关键字，使默认实现与特性本身具有相同的可见性："

#: ../../language/error_codes/E4010.md:24
#: ../../language/error_codes/E4011.md:22
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"impl Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4011.md:1
msgid "E4011"
msgstr ""

#: ../../language/error_codes/E4011.md:3
msgid "Type parameters are not allowed on default implementation for traits."
msgstr "不允许在特性默认实现中使用类型参数。"

#: ../../language/error_codes/E4011.md:7
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"impl[T] Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4011.md:15
msgid ""
"The example above uses a type parameter `T` on the default implementation"
" of the `Stringer` trait, which is not allowed."
msgstr "在上述例子中，在 `Stringer` 特性的默认实现中使用了类型参数 `T`，这是不允许的。"

#: ../../language/error_codes/E4011.md:20
msgid "Remove the type parameter from the default implementation:"
msgstr "从默认实现中移除类型参数："

#: ../../language/error_codes/E4012.md:1
msgid "E4012"
msgstr ""

#: ../../language/error_codes/E4012.md:3
msgid "Mutable constructor fields are only allowed on labelled arguments."
msgstr "只有带标签的构造器字段可以是可变的。"

#: ../../language/error_codes/E4012.md:7
msgid ""
"enum E {\n"
"  F(mut x : Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4012.md:13
msgid ""
"The example above declares an unlabeled mutable field `x` in the "
"constructor of the `F` variant of the `E` enum, which is not allowed."
msgstr "上述示例在 `E` 枚举的 `F` 变体构造函数中声明了一个未标记的可变字段 `x`，这是不允许的。"

#: ../../language/error_codes/E4012.md:16
#: ../../language/error_codes/E4029.md:24
msgid "Suggestions"
msgstr "建议"

#: ../../language/error_codes/E4012.md:18
msgid "Add a label to the mutable field:"
msgstr "为可变字段添加标签："

#: ../../language/error_codes/E4012.md:20
msgid ""
"enum E {\n"
"  F(mut x~ : Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:1
msgid "E4013"
msgstr ""

#: ../../language/error_codes/E4013.md:3
msgid ""
"This function has a type which expects a different number of arguments "
"than provided."
msgstr ""

#: ../../language/error_codes/E4013.md:7
msgid ""
"fn f() -> (() -> Int) {\n"
"  fn (x: Int) { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:13
msgid ""
"The example above declares a function `f` returns a function which "
"expects no arguments, but returns a function that expects one argument. "
"This will give the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4013.md:17
msgid ""
"This function has type () -> Int, which expects 0 argument(s), but is "
"given 1 argument(s).\n"
msgstr ""

#: ../../language/error_codes/E4013.md:23
msgid ""
"Adjust the code so that the number of arguments in the function type "
"matches the number of arguments in the function definition:"
msgstr ""

#: ../../language/error_codes/E4013.md:26
msgid ""
"fn f() -> ((Int) -> Int) {\n"
"  fn (x: Int) { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:32
#: ../../language/error_codes/E4046.md:29
msgid "... or:"
msgstr "或："

#: ../../language/error_codes/E4013.md:34
msgid ""
"fn f(x: Int) -> (() -> Int) {\n"
"  fn() { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4014.md:1
msgid "E4014"
msgstr ""

#: ../../language/error_codes/E4014.md:3
msgid "Type Mismatch."
msgstr "类型不匹配。"

#: ../../language/error_codes/E4014.md:7
msgid ""
"fn fst[X, Y] (a: X, b: Y) -> X {\n"
"  b\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4014.md:13
msgid ""
"The above example returns a value `b` of type `Y` on line 2, which is not"
" the same as the return type `X` of the function."
msgstr "上述示例在第 2 行返回一个类型为 `Y` 的值 `b`，这与函数的返回类型 `X` 不同。"

#: ../../language/error_codes/E4014.md:18
msgid ""
"Please make sure to return a value of the same type as the return type of"
" the function."
msgstr "请确保返回与函数的返回类型相同的值。"

#: ../../language/error_codes/E4014.md:21
msgid "For instance, in the example above, you may write:"
msgstr "例如，在上述示例中，你可以这样写："

#: ../../language/error_codes/E4014.md:23
msgid ""
"fn fst[X, Y] (a: X, b: Y) -> X {\n"
"  a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4015.md:1
msgid "E4015"
msgstr ""

#: ../../language/error_codes/E4015.md:3
msgid "Type has no method with the specified name."
msgstr "类型没有指定名称的方法。"

#: ../../language/error_codes/E4015.md:7
msgid "let hey = \"hey\".upper()\n"
msgstr ""

#: ../../language/error_codes/E4015.md:11
msgid ""
"The above example tries to call an inexistent method `upper()` on a "
"string literal, giving the following error on line 1:"
msgstr "上述例子中，试图对字符串常量调用一个不存在的方法 `upper()`，在第 1 行报错："

#: ../../language/error_codes/E4015.md:14
msgid "Type String has no method upper.\n"
msgstr ""

#: ../../language/error_codes/E4015.md:20
msgid ""
"This is usually a typo or a misunderstanding of the methods available. "
"Please make sure to use the correct method name:"
msgstr "这通常是因为一个拼写错误或对可用方法的误解。请确保使用正确的方法名称："

#: ../../language/error_codes/E4015.md:23
msgid "let hey = \"hey\".to_upper()\n"
msgstr ""

#: ../../language/error_codes/E4016.md:1
msgid "E4016"
msgstr ""

#: ../../language/error_codes/E4016.md:3
msgid ""
"Please implement the required method for the type to use the infix "
"operator."
msgstr "请为类型实现所需的方法以使用中缀运算符。"

#: ../../language/error_codes/E4016.md:7
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s + s\n"
msgstr ""

#: ../../language/error_codes/E4016.md:14
msgid ""
"The example above tries to use the infix operator `+` on a type `S` that "
"does not implement the required method `op_add`, giving the following "
"error on line 4:"
msgstr "在上述例子中，试图在一个未实现所需方法 `op_add` 的类型 `S` 上使用中缀运算符 `+`，在第 4 行报错："

#: ../../language/error_codes/E4016.md:18
msgid ""
"Please implement the method op_add for the type S to use the infix "
"operator \"+\".\n"
msgstr "请为类型 S 实现方法 op_add 以使用中缀运算符 \"+\"。"

#: ../../language/error_codes/E4016.md:24
msgid "Implement the required method for the type `S`:"
msgstr "实现类型 `S` 所需的方法："

#: ../../language/error_codes/E4016.md:26
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s + s\n"
"\n"
"fn S::op_add(self : S, other : S) -> S {\n"
"  { v: self.v + other.v }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4017.md:1
msgid "E4017"
msgstr ""

#: ../../language/error_codes/E4017.md:3
msgid "Method of type is ambiguous, it may come from multiple traits."
msgstr "方法的类型有歧义，可能来自多个特征。"

#: ../../language/error_codes/E4017.md:7
msgid ""
"struct S { v : Int } derive(Show)\n"
"\n"
"trait Tee { to_string(Self) -> String }\n"
"\n"
"impl Tee for S with to_string(_self) { \"Tee\" }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s.to_string()\n"
msgstr ""

#: ../../language/error_codes/E4017.md:18
msgid ""
"The example above tries to call the method `to_string` on a type `S`, but"
" the method name comes from both `Show` and `Tee` traits, giving the "
"following error on line 8:"
msgstr "上述例子中，试图在类型 `S` 上调用方法 `to_string`，但方法名称来自 `Show` 和 `Tee` 两个特征，会在第 8 行报错："

#: ../../language/error_codes/E4017.md:22
msgid ""
"Method to_string of type S is ambiguous, it may come from trait Tee or "
"Show\n"
msgstr ""

#: ../../language/error_codes/E4017.md:28
msgid "Disambiguate the method by specifying the trait it comes from:"
msgstr "通过指明具体的特征对方法去歧义："

#: ../../language/error_codes/E4017.md:30
msgid ""
"struct S { v : Int } derive(Show)\n"
"\n"
"trait Tee { to_string(Self) -> String }\n"
"\n"
"impl Tee for S with to_string(_self) { \"Tee\" }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Tee::to_string(s)\n"
msgstr ""

#: ../../language/error_codes/E4018.md:1
msgid "E4018"
msgstr ""

#: ../../language/error_codes/E4018.md:3
msgid "Cannot resolve trait for the given type."
msgstr "无法为给定类型解析特征。"

#: ../../language/error_codes/E4018.md:7
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Show::to_string(s)\n"
msgstr ""

#: ../../language/error_codes/E4018.md:14
msgid ""
"The example above tries to call the method `to_string` from the `Show` "
"trait on a type `S`, but since `S` does not implement that trait, it "
"gives the following error on line 4:"
msgstr "在上述例子中，试图在类型 `S` 上调用 `Show` 特征的方法 `to_string`，但由于 `S` 没有实现该特征，会在第 4 行报错："

#: ../../language/error_codes/E4018.md:18
msgid "Type S does not implement trait Show: method output is missing\n"
msgstr ""

#: ../../language/error_codes/E4018.md:24
msgid "Implement the `Show` trait for the type `S`:"
msgstr "给类型 `S` 实现 `Show` 特征："

#: ../../language/error_codes/E4018.md:26
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Show::to_string(s)\n"
"\n"
"impl Show for S with output(self, logger) {\n"
"  logger.write_object(self.v)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4019.md:1
msgid "E4019"
msgstr ""

#: ../../language/error_codes/E4019.md:3
msgid "The label is declared twice in this function."
msgstr "这个函数中的标签声明了两次。"

#: ../../language/error_codes/E4019.md:7
msgid ""
"fn f(g~ : Int, g~ : String) -> Int {\n"
"  g\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4019.md:13
msgid ""
"The above example declares the label `g` twice in the function `f`, which"
" is not allowed and gives the following error on line 1:"
msgstr "上述例子中，在函数 `f` 中声明了标签 `g` 两次，这是不允许的，会在第 1 行报错："

#: ../../language/error_codes/E4019.md:16
msgid "The label g~ is declared twice in this function, first in <FILE>.mbt:1:6\n"
msgstr ""

#: ../../language/error_codes/E4019.md:22
msgid "Rename one of the labels to avoid the conflict:"
msgstr "重命名其中一个标签以避免冲突："

#: ../../language/error_codes/E4019.md:24
msgid ""
"fn f(g~ : Int, h~ : String) -> Int {\n"
"  g\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4020.md:1
msgid "E4020"
msgstr ""

#: ../../language/error_codes/E4020.md:3
msgid "Package not found in the loaded packages."
msgstr "未在加载的包中找到包。"

#: ../../language/error_codes/E4020.md:7
msgid "let a = @boolean.to_int(true)\n"
msgstr ""

#: ../../language/error_codes/E4020.md:11
msgid ""
"The example above tries to call the method `to_int` in a package "
"`boolean`, but this package is not present in the list of loaded "
"packages, giving the following error on line 1:"
msgstr "上述例子中，试图在包 `boolean` 中调用方法 `to_int`，但这个包不在加载的包列表中，会在第 1 行报错："

#: ../../language/error_codes/E4020.md:15
msgid "Package \"boolean\" not found in the loaded packages.\n"
msgstr ""

#: ../../language/error_codes/E4020.md:21
msgid "Make sure the package name is valid."
msgstr "确保包名是合法的。"

#: ../../language/error_codes/E4020.md:23
msgid ""
"If it is an external package, make sure that it is mentioned as one of "
"the imported packages in `moon.pkg.json` as well."
msgstr "如果是一个外部包，请确保它也在 `moon.pkg.json` 中作为导入包之一被声明。"

#: ../../language/error_codes/E4020.md:26
msgid ""
"In the above example, the package name should be `@bool` instead of "
"`@boolean`:"
msgstr ""

#: ../../language/error_codes/E4020.md:28
#: ../../language/error_codes/E4021.md:25
msgid "let a = @bool.to_int(true)\n"
msgstr ""

#: ../../language/error_codes/E4021.md:1
msgid "E4021"
msgstr ""

#: ../../language/error_codes/E4021.md:3
msgid "The value identifier is unbound."
msgstr "标识符未绑定。"

#: ../../language/error_codes/E4021.md:7
msgid "let a = @bool.to_integer(true)\n"
msgstr ""

#: ../../language/error_codes/E4021.md:11
msgid ""
"The example above tries to call the function `to_integer` in a package "
"`@bool`, but this function is not present in the package `@bool`, giving "
"the following error on line 1:"
msgstr "在上述例子中，尝试使用包 `@bool` 中的函数 `to_integer`，但这个方法不在包 `@bool` 中，会在第 1 行报错："

#: ../../language/error_codes/E4021.md:15
msgid "Value to_integer not found in package `bool`.\n"
msgstr ""

#: ../../language/error_codes/E4021.md:21
msgid "Make sure the identifier is correct."
msgstr "请确保标识符是正确的。"

#: ../../language/error_codes/E4021.md:23
msgid ""
"In the above example, the function name should be `to_int` instead of "
"`to_integer`:"
msgstr "在上述例子中，函数名称应该为 `to_int` 而不是 `to_integer`："

#: ../../language/error_codes/E4023.md:1
msgid "E4023"
msgstr ""

#: ../../language/error_codes/E4023.md:3
msgid "The trait is not found."
msgstr "未找到该特征。"

#: ../../language/error_codes/E4023.md:7
msgid "let a = true as &Sh0w\n"
msgstr ""

#: ../../language/error_codes/E4023.md:11
msgid ""
"The example above tries to cast a boolean value to an object of the "
"`Sh0w` trait, but this trait is not found in the current scope, giving "
"the following error on line 1:"
msgstr "这个例子中，试图将一个布尔值转换为一个 `Sh0w` 特征的对象，但这个特征在当前作用域中未找到，会在第 1 行报错："

#: ../../language/error_codes/E4023.md:15
msgid "The trait Sh0w is not found.\n"
msgstr ""

#: ../../language/error_codes/E4023.md:21
msgid "Make sure the trait name is correct:"
msgstr "确保特征名是正确的："

#: ../../language/error_codes/E4023.md:23
msgid "let a = true as &Show\n"
msgstr ""

#: ../../language/error_codes/E4024.md:1
msgid "E4024"
msgstr ""

#: ../../language/error_codes/E4024.md:3
msgid "The type/trait is not found."
msgstr "这个类型/特征未找到。"

#: ../../language/error_codes/E4024.md:7
msgid "let a = Sh0w::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4024.md:11
msgid ""
"The example above tries to call the method `to_string` from the `Sh0w` "
"type (or trait), but this type (or trait) is not found in the current "
"scope, given the following error on line 1:"
msgstr "在上述例子中，试图在 `Sh0w` 类型（或特征）上调用方法 `to_string`，但这个类型（或特征）在当前作用域中未找到，会在第 1 行报错："

#: ../../language/error_codes/E4024.md:15
msgid "The type/trait Sh0w is not found.\n"
msgstr ""

#: ../../language/error_codes/E4024.md:21
msgid "Make sure the type (or trait) name is correct."
msgstr "请确保类型（或特征）名是正确的。"

#: ../../language/error_codes/E4024.md:23
msgid "In the above example, you can choose to use a proper trait name `Show`:"
msgstr "在上述例子中，你可以选择使用合适的特征名称 `Show`："

#: ../../language/error_codes/E4024.md:25
msgid "let a = Show::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4024.md:29
msgid "... or a proper type name `Bool`:"
msgstr "或者使用合适的类型名称 `Bool`："

#: ../../language/error_codes/E4024.md:31
#: ../../language/error_codes/E4025.md:27
msgid "let a = Bool::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4025.md:1
msgid "E4025"
msgstr ""

#: ../../language/error_codes/E4025.md:3
msgid "Method has been defined for multiple types."
msgstr "方法已为多个类型定义。"

#: ../../language/error_codes/E4025.md:7
msgid "let a = to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4025.md:11
msgid ""
"The example above tries to call the method `to_string` on a boolean "
"value, but this method has already been defined for multiple types so "
"that the compiler cannot properly deduce which method to call, giving the"
" following error on line 1:"
msgstr "在上述例子中，试图在布尔值上调用方法 `to_string`，但这个方法已经为多个类型定义，因此编译器无法正确推断调用哪个方法，会在第 1 行报错："

#: ../../language/error_codes/E4025.md:16
msgid ""
"Method to_string has been defined for the following types:\n"
"<FILE>.mbt:<LINE>:<COLUMN> String\n"
"<FILE>.mbt:<LINE>:<COLUMN> Int64\n"
"<SNIP>\n"
msgstr ""

#: ../../language/error_codes/E4025.md:25
msgid "Disambiguate the method by specifying the type it comes from:"
msgstr "通过指定方法的类型来去歧义："

#: ../../language/error_codes/E4026.md:1
msgid "E4026"
msgstr ""

#: ../../language/error_codes/E4026.md:3
msgid "The field is not found."
msgstr "该字段未找到。"

#: ../../language/error_codes/E4026.md:7
msgid ""
"struct T { a : Int }\n"
"fn main {\n"
"  let t = { b: 42 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4026.md:14
msgid ""
"The example above tries to create a record with a field `b`, but no "
"record with such a field is found in the current scope, giving the above "
"error on line 3."
msgstr "在上述例子中，试图创建一个带有字段 `b` 的结构体，但在当前作用域中找不到带有这样字段的结构体，在第 3 行报错。"

#: ../../language/error_codes/E4026.md:20
msgid ""
"Make sure a record is available in the current scope, defined with the "
"correct field name:"
msgstr "确保在当前作用域中有一个结构体，且其定义了正确的字段名称："

#: ../../language/error_codes/E4026.md:23
msgid ""
"struct T { a : Int }\n"
"fn main {\n"
"  let t = { a: 42 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4026.md:30
msgid "... in the fix above, `t` is inferred to be of type `T`."
msgstr "在上述修复中，`t` 被推断为类型 `T`。"

#: ../../language/error_codes/E4027.md:1
msgid "E4027"
msgstr ""

#: ../../language/error_codes/E4027.md:3
msgid "Unused type parameter."
msgstr "未使用的类型参数。"

#: ../../language/error_codes/E4027.md:7
msgid "fn id[T](a: Int) -> Int { a }\n"
msgstr ""

#: ../../language/error_codes/E4027.md:11
msgid ""
"The example above declares a type parameter `T` in the identity function "
"`id`, however `T` is not used anywhere in the function signature, giving "
"the following error on line 1:"
msgstr "在上述例子中，在恒等函数 `id` 中声明了一个类型参数 `T` ，然而 `T` 在函数签名中没有被使用，在第 1 行报错："

#: ../../language/error_codes/E4027.md:15
msgid "Unused type parameter 'T'\n"
msgstr ""

#: ../../language/error_codes/E4027.md:21
msgid "Make sure the type parameter is used in the function signature:"
msgstr "确保类型参数在函数签名中被使用："

#: ../../language/error_codes/E4027.md:23
msgid "fn id[T](a: T) -> T { a }\n"
msgstr ""

#: ../../language/error_codes/E4028.md:1
msgid "E4028"
msgstr ""

#: ../../language/error_codes/E4028.md:3
msgid "This expression has a type which is not a record."
msgstr "这个表达式的类型不是一个结构体。"

#: ../../language/error_codes/E4028.md:7
msgid ""
"struct T { a : Int }\n"
"let a : Int = { a: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4028.md:12
msgid ""
"The example above tries to assign a record to a variable `a` of type "
"`Int`, which is not possible and gives the following error on line 2:"
msgstr "在上述例子中，试图将一个结构体赋值给一个类型为 `Int` 的变量 `a`，这是不可能的，会在第 2 行报错："

#: ../../language/error_codes/E4028.md:15
msgid "This expression has type Int, which is a Int type and not a record.\n"
msgstr "这个表达式类型为 Int，是一个 Int 类型而不是一个结构体。\n"

#: ../../language/error_codes/E4028.md:21
msgid "Make sure to use the correct type instead:"
msgstr "确保使用正确的类型："

#: ../../language/error_codes/E4028.md:23
msgid ""
"struct T { a : Int }\n"
"let a : T = { a: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4029.md:1
msgid "E4029"
msgstr ""

#: ../../language/error_codes/E4029.md:3
msgid "This expression has a type which is not a variant."
msgstr "这个表达式的类型不是一个枚举值。"

#: ../../language/error_codes/E4029.md:7
msgid ""
"fn main {\n"
"  fn f {\n"
"    (a, b) => a + b\n"
"  }\n"
"  let a = f(None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4029.md:16
msgid ""
"The example above tries to call a function `f` with a value `None`, which"
" is a variant of the `Option[_]` type, but `f` only accepts a tuple, "
"giving the following error on line 5:"
msgstr ""
"在上述例子中，试图对 `None` 值调用函数 `f`，这是 `Option[_]` 类型的一个枚举值，但 `f` 只接受一个元组，在第 5 "
"行报错："

#: ../../language/error_codes/E4029.md:20
msgid ""
"This expression has type (Int, Int), which is a tuple type and not a "
"variant.\n"
msgstr ""

#: ../../language/error_codes/E4029.md:26
msgid "Make sure to use a value of the correct type instead:"
msgstr "确保使用正确类型的值："

#: ../../language/error_codes/E4029.md:28
msgid ""
"fn main {\n"
"  fn f {\n"
"    (a, b) => a + b\n"
"  }\n"
"  let a = f((3, 4))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4030.md:1
msgid "E4030"
msgstr ""

#: ../../language/error_codes/E4030.md:3
msgid "The record type does not have the specified field."
msgstr "结构体没有指定的字段。"

#: ../../language/error_codes/E4030.md:7
msgid ""
"struct T { a : Int }\n"
"let t : T = { a: 42 }\n"
"let u : T = { ..t, b: 43 }\n"
msgstr ""

#: ../../language/error_codes/E4030.md:13
msgid ""
"The example above tries to assign an updated record with a field `b` to a"
" variable `u` of type `T`, but this field doesn't exist, giving the "
"following error on line 3:"
msgstr "在上述例子中，试图将一个更新后的带有字段 `b` 的结构体赋值给一个类型为 `T` 的变量 `u`，但这个字段不存在 `T` 中，在第 3 行报错："

#: ../../language/error_codes/E4030.md:17
msgid "The record type T does not have the field b.\n"
msgstr ""

#: ../../language/error_codes/E4030.md:23
msgid "Make sure to use the correct field instead:"
msgstr "确保使用正确的字段："

#: ../../language/error_codes/E4030.md:25
msgid ""
"struct T { a : Int }\n"
"let t : T = { a: 42 }\n"
"let u : T = { ..t, a: 43 }\n"
msgstr ""

#: ../../language/error_codes/E4031.md:1
msgid "E4031"
msgstr ""

#: ../../language/error_codes/E4031.md:3
msgid "The constructor is not found."
msgstr "构造器未找到。"

#: ../../language/error_codes/E4031.md:7
msgid ""
"enum U { V }\n"
"let v : U = W\n"
msgstr ""

#: ../../language/error_codes/E4031.md:12
msgid ""
"The example above tries to assign a variant `W` to a variable `v` of type"
" `U`, but this variant doesn't exist, giving the following error on line "
"2:"
msgstr "在上述例子中，试图将一个 `W` 枚举值赋值给一个类型为 `U` 的变量 `v`，但这个枚举值不存在，会在第 2 行报错："

#: ../../language/error_codes/E4031.md:15
msgid "The variant type U does not have the constructor W.\n"
msgstr ""

#: ../../language/error_codes/E4031.md:21
msgid "Make sure to use the correct constructor instead:"
msgstr "确保使用正确的构造器："

#: ../../language/error_codes/E4031.md:23
msgid ""
"enum U { V }\n"
"let v : U = V\n"
msgstr ""

#: ../../language/error_codes/E4032.md:1
msgid "E4032"
msgstr ""

#: ../../language/error_codes/E4032.md:3
msgid "The type is undefined."
msgstr "这个类型未定义。"

#: ../../language/error_codes/E4032.md:5 ../../language/error_codes/E4054.md:6
msgid "Currently, MoonBit won't emit this error."
msgstr "目前，MoonBit 不会报告这个错误。"

#: ../../language/error_codes/E4033.md:1
msgid "E4033"
msgstr ""

#: ../../language/error_codes/E4033.md:3
msgid "There is no record definition with the specified fields."
msgstr "没有定义指定字段的结构体。"

#: ../../language/error_codes/E4033.md:7
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  let c = { x: 2, w: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4033.md:14
msgid ""
"The example above tries to assign a record with fields `x` and `w` to a "
"variable `c`, but this field doesn't exist in any known record type, "
"giving the following error on line 3:"
msgstr "在上述例子中，试图将一个带有字段 `x` 和 `w` 的结构体赋值给一个变量 `c`，但这个字段在任何已知的结构体类型中都不存在，在第 3 行报错："

#: ../../language/error_codes/E4033.md:17
msgid "There is no record definition with the fields: x, w.\n"
msgstr ""

#: ../../language/error_codes/E4033.md:23
msgid "Make sure to use the correct field identifiers instead:"
msgstr "确保使用正确的字段标识符："

#: ../../language/error_codes/E4033.md:25
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  let c = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4034.md:1
msgid "E4034"
msgstr ""

#: ../../language/error_codes/E4034.md:3
msgid "Multiple possible record types detected, please add more annotation."
msgstr "发现多个可能的结构体类型，请添加更多注释。"

#: ../../language/error_codes/E4034.md:7
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  struct T { x : Int; y : Int }\n"
"  let c = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4034.md:15
msgid ""
"The example above tries to assign a record with fields `x` and `y` to a "
"variable `c`, but this field combination matches both `S` and `T` types, "
"giving the following error on line 4:"
msgstr ""
"在上述例子中，试图将一个带有字段 `x` 和 `y` 的结构体赋值给一个变量 `c`，但这个字段组合同时匹配了 `S` 和 `T` "
"两种类型，会在第 4 行报错："

#: ../../language/error_codes/E4034.md:18
msgid ""
"Multiple possible record types detected: T, S, please add more "
"annotation.\n"
msgstr ""

#: ../../language/error_codes/E4034.md:24
msgid "Disambiguate the record type by adding a type annotation:"
msgstr "通过添加类型注释来去歧义："

#: ../../language/error_codes/E4034.md:26
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  struct T { x : Int; y : Int }\n"
"  let c : S = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4036.md:1
msgid "E4036"
msgstr ""

#: ../../language/error_codes/E4036.md:3
msgid "Cannot create values of the read-only type."
msgstr "无法创建只读类型的值。"

#: ../../language/error_codes/E4036.md:7
msgid ""
"In `lib/lib.mbt`, we declare a struct `R` with a private field "
"`__private`:"
msgstr "在 `lib/lib.mbt` 中，我们声明了一个带有私有字段 `__private` 的结构体 `R`："

#: ../../language/error_codes/E4036.md:9
msgid ""
"pub(all) struct R {\n"
"  x : Int\n"
"  priv __private : Int\n"
"}\n"
"\n"
"pub fn R::new(x: Int) -> R {\n"
"  {x, __private: 42}\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4036.md:20
msgid "In `main/main.mbt`, we try to create a value of type `R`:"
msgstr "在 `main/main.mbt` 中，我们试图创建一个类型为 `R` 的值："

#: ../../language/error_codes/E4036.md:22
msgid "let r : @lib.R = { x: 1, __private: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4036.md:26
msgid "This gives the following error on line 1:"
msgstr "这会在第 1 行报错："

#: ../../language/error_codes/E4036.md:28
msgid ""
"Cannot create values of struct type @lib.R because it contains private "
"field(s).\n"
msgstr ""

#: ../../language/error_codes/E4036.md:34
msgid "Construct the value using the public constructor:"
msgstr "使用公开构造函数构造值："

#: ../../language/error_codes/E4036.md:36
msgid "let r : @lib.R = @lib.R::new(1)\n"
msgstr ""

#: ../../language/error_codes/E4037.md:1
msgid "E4037"
msgstr ""

#: ../../language/error_codes/E4037.md:3
msgid "Cannot perform action: package is not imported."
msgstr "无法完成操作：包未导入。"

#: ../../language/error_codes/E4037.md:7
msgid "In `main/main.mbt`, we try to call a function from `@middle`:"
msgstr "在 `main/main.mbt` 中，我们试图调用 `@middle` 中的一个函数："

#: ../../language/error_codes/E4037.md:9
msgid ""
"fn main {\n"
"  let a = @middle.return_Obj().m()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:15
msgid ""
"In `middle/middle.mbt`, we define a function that returns an object of a "
"trait `Obj` defined in `@ty`:"
msgstr "在 `middle/middle.mbt` 中，我们定义了一个函数，返回了一个在 `@ty` 中定义的特征 `Obj` 的对象："

#: ../../language/error_codes/E4037.md:18
msgid ""
"pub fn return_Obj() -> &@ty.Obj {\n"
"  @ty.T(42)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:24
msgid "In `ty/ty.mbt`, we define a trait `Obj` and a type `T` that implements it:"
msgstr "在 `ty/ty.mbt` 中，我们定义了一个特征 `Obj` 和一个实现它的类型 `T`："

#: ../../language/error_codes/E4037.md:27
msgid ""
"pub(all) type T Int\n"
"\n"
"pub fn f(self: T) -> Unit {\n"
"  println(self._)\n"
"}\n"
"\n"
"pub(open) trait Obj {\n"
"  f(Self) -> Unit\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:39
msgid "... but in `main/moon.pkg.json` there is no mention of `@ty`:"
msgstr "但是在 `main/moon.pkg.json` 中没有提到 `@ty`："

#: ../../language/error_codes/E4037.md:41
msgid ""
"{\n"
"  \"import\": [\"<PACKAGE>/middle\"]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:47
msgid "This gives the following error on line 2 of `main/main.mbt`:"
msgstr "这会在 `main/main.mbt` 的第 2 行报错："

#: ../../language/error_codes/E4037.md:49
msgid ""
"Cannot call method of type &@<PACKAGE>/ty.Obj: package @<PACKAGE>/ty is "
"not imported.\n"
msgstr "无法调用类型为 &@<PACKAGE>/ty.Obj 的方法：包 @<PACKAGE>/ty 未导入。\n"

#: ../../language/error_codes/E4037.md:55
msgid "Make sure that all relevant packages are imported."
msgstr "确保所有相关的包都已经导入。"

#: ../../language/error_codes/E4037.md:57
msgid ""
"In the above example, this means importing both `@middle` and `@ty` in "
"`main/moon.pkg.json`:"
msgstr "在上面的示例中，这意味着在 `main/moon.pkg.json` 中导入 `@middle` 和 `@ty`："

#: ../../language/error_codes/E4037.md:59
msgid ""
"{\n"
"  \"import\": [\"<PACKAGE>/middle\", \"<PACKAGE>/ty\"]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:1
msgid "E4038"
msgstr ""

#: ../../language/error_codes/E4038.md:3
msgid "Trait object for the type is not allowed."
msgstr "该类型的特征对象是不允许的。"

#: ../../language/error_codes/E4038.md:7
msgid ""
"fn main {\n"
"  let a = 3 as &Eq\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:13
msgid ""
"The example above tries to create an object of the `Eq` trait. This is "
"not allowed, as the trait is not object safe."
msgstr "在上述例子中，试图创建一个 `Eq` 特征的对象。这是不允许的，因为这个特征不是对象安全的。"

#: ../../language/error_codes/E4038.md:16
msgid "The `Eq` trait is defined as follows:"
msgstr "`Eq` 特征定义如下："

#: ../../language/error_codes/E4038.md:18
msgid ""
"pub(open) trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:24
msgid "... which is why the following error is given on line 2:"
msgstr "因此在第 2 行报错："

#: ../../language/error_codes/E4038.md:26
msgid ""
"Trait object for Eq is not allowed: `Self` occur multiple times in the "
"type of method op_equal\n"
msgstr ""

#: ../../language/error_codes/E4038.md:32
msgid "Use an object-safe trait to create a trait object."
msgstr "使用一个对象安全的特征来创建一个特征对象。"

#: ../../language/error_codes/E4038.md:34
msgid ""
"For a trait to be object-safe, its dispatchable functions must use and "
"only use the `Self` type as the first parameter. For example, `Show` is "
"such a trait:"
msgstr "一个特征要是类型安全的，它的可调用函数必须使用并且只能使用 `Self` 类型作为第一个参数。例如，`Show` 就是这样一个特征："

#: ../../language/error_codes/E4038.md:37
msgid ""
"pub(open) trait Show {\n"
"  output(Self, &Logger) -> Unit\n"
"  to_string(Self) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4039.md:1
msgid "E4039"
msgstr ""

#: ../../language/error_codes/E4039.md:3
msgid "There is no method with the specified name in this trait."
msgstr "在这个特征中没有指定的方法。"

#: ../../language/error_codes/E4039.md:7
msgid "let a : String = Show::to_str(42)\n"
msgstr ""

#: ../../language/error_codes/E4039.md:11
msgid ""
"The example above tries to call the method `to_str` on the `Show` trait, "
"but the method is not defined in the trait, giving the following error on"
" line 1:"
msgstr "在上述例子中，试图在 `Show` 特征上调用方法 `to_str`，但这个方法在特征中未定义，在第 1 行报错："

#: ../../language/error_codes/E4039.md:14
msgid "There is no method to_str in trait Show\n"
msgstr ""

#: ../../language/error_codes/E4039.md:20
msgid ""
"Make sure that the method name is spelled correctly and that it is "
"defined in the trait:"
msgstr "确保方法名拼写正确，并且在特征中定义："

#: ../../language/error_codes/E4039.md:23
msgid "let a : String = Show::to_string(42)\n"
msgstr ""

#: ../../language/error_codes/E4040.md:1
msgid "E4040"
msgstr ""

#: ../../language/error_codes/E4040.md:3
msgid ""
"The type constructor expects a different number of arguments than "
"provided."
msgstr "类型构造器期望的参数数量与提供的参数数量不同。"

#: ../../language/error_codes/E4040.md:7
msgid "let a : Option = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4040.md:11
msgid ""
"The example above tries to create an instance of the `Option` type. The "
"`Option` type is a generic type that expects a single type argument, but "
"the example does not provide any type arguments, giving the following "
"error on line 1:"
msgstr ""
"在上述例子中，试图创建一个 `Option` 类型的实例。`Option` "
"类型是一个泛型类型，期望一个类型参数，但是这个例子没有提供任何类型参数，在第 1 行报错："

#: ../../language/error_codes/E4040.md:16
msgid ""
"The type constructor Option expects 1 argument(s), but is here given 0 "
"argument(s).\n"
msgstr ""

#: ../../language/error_codes/E4040.md:22
msgid "Make sure to provide the correct number of type arguments:"
msgstr "确保提供正确数量的类型参数："

#: ../../language/error_codes/E4040.md:24
#: ../../language/error_codes/E4041.md:19
msgid "let a : Option[Int] = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4041.md:1
msgid "E4041"
msgstr ""

#: ../../language/error_codes/E4041.md:3
msgid "Partial type is not allowed in toplevel declarations."
msgstr "不完整的类型在顶层声明中是不允许的。"

#: ../../language/error_codes/E4041.md:7
msgid "let a : Option[_] = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4041.md:11
msgid ""
"The example above tries to create a top-level instance of the `Option[_]`"
" type. However, partial type annotations are not allowed in toplevel "
"declarations, giving the aforementioned error on line 1."
msgstr "在上述例子中，试图创建一个顶层的 `Option[_]` 类型的实例。然而，不完整的类型注释在顶层声明中是不允许的，在第 1 行报错。"

#: ../../language/error_codes/E4041.md:17
msgid "Make sure to provide a complete type annotation:"
msgstr "提供一个完整的类型注释："

#: ../../language/error_codes/E4042.md:1
msgid "E4042"
msgstr ""

#: ../../language/error_codes/E4042.md:3
msgid "Invalid stub type."
msgstr "不合法的桩类型。"

#: ../../language/error_codes/E4042.md:5
msgid ""
"When defineing a FFI, the stub type must be a valid type, namely they can"
" be represented natively at corresponding backends."
msgstr "在定义 FFI 时，桩类型必须是一个有效的类型，即它们可以在相应的后端原生地表示。"

#: ../../language/error_codes/E4042.md:8
msgid ""
"For example, you cannot use `FixedArray[T]` and `String` in FFI "
"definition on WASM linear backend."
msgstr "例如，在 WASM 线性后端的 FFI 定义中，不能使用 `FixedArray[T]` 和 `String`。"

#: ../../language/error_codes/E4042.md:13
msgid "On WASM linear backend:"
msgstr "在 WASM 线性后端："

#: ../../language/error_codes/E4042.md:15
msgid ""
"fn ffi(array : FixedArray[Int]) -> Unit = \"mod\" \"ffi\"\n"
"//             ^~~~~~~~~~~~~~~ Error: Invalid stub type.\n"
msgstr ""

#: ../../language/error_codes/E4042.md:22
msgid ""
"The way to pass non-native types through the FFI interface depends on "
"both the backend of the MoonBit compiler and the runtime you are using. "
"For example, if you wish to pass an array of int to the JS host with the "
"WASM linear backend, you can pass the int one by one to the host function"
" and store the array on the JS side."
msgstr ""
"将非原生类型通过 FFI 接口传递的方式取决于 MoonBit 编译器的后端和您使用的运行时。例如，如果你希望在 Wasm "
"线性内存后端将一个整数数组传递给 JS 宿主，可以将整数一个一个地传递给宿主函数，并在 JS 端存储数组。"

#: ../../language/error_codes/E4042.md:28
msgid ""
"type JsArray\n"
"fn make_js_array() -> JsArray = \"mod\" \"make_js_array\"\n"
"fn push_js_array(array : JsArray, value : Int) -> Unit = \"mod\" "
"\"push_js_array\"\n"
msgstr ""

#: ../../language/error_codes/E4043.md:1
msgid "E4043"
msgstr ""

#: ../../language/error_codes/E4043.md:3
msgid "The record field is defined or matched multiple times."
msgstr "结构体字段被多次定义或匹配。"

#: ../../language/error_codes/E4043.md:7
msgid ""
"struct S { a : Int }\n"
"let a : Int = match S::{ a: 2, a: 3 } {\n"
"  { a: 2, a: 3 } => 4\n"
"  _ => 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4043.md:15
msgid "The example above tries to:"
msgstr "上述例子中，试图："

#: ../../language/error_codes/E4043.md:17
msgid "Create a record with the field `a` defined multiple times."
msgstr "创建一个多次定义字段 `a` 的结构体。"

#: ../../language/error_codes/E4043.md:18
msgid "Destructure a record with the field `a` matched multiple times."
msgstr "通过多次匹配字段 `a` 解构结构体。"

#: ../../language/error_codes/E4043.md:20
msgid "... giving the following error on line 2:"
msgstr "在第 2 行给出了以下错误："

#: ../../language/error_codes/E4043.md:22
msgid "The record field a is defined several times.\n"
msgstr ""

#: ../../language/error_codes/E4043.md:26
msgid "... and the following error on line 3:"
msgstr "在第 3 行给出了以下错误："

#: ../../language/error_codes/E4043.md:28
msgid "The record field a is matched several times in this pattern.\n"
msgstr ""

#: ../../language/error_codes/E4043.md:34
msgid "Make sure that the record field is defined or matched only once:"
msgstr "确保结构体字段只被定义或匹配一次："

#: ../../language/error_codes/E4043.md:36
msgid ""
"struct S { a : Int }\n"
"let a : Int = match S::{ a: 2 } {\n"
"  { a: 2 } => 4\n"
"  _ => 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4044.md:1
msgid "E4044"
msgstr ""

#: ../../language/error_codes/E4044.md:3
msgid "Record fields are missing. Use `..` to ignore them in patterns."
msgstr "结构体字段缺失。在模式中使用 `..` 忽略它们。"

#: ../../language/error_codes/E4044.md:7
msgid ""
"struct S { a : Int; b: Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2 } => 4\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4044.md:15
msgid ""
"The example above tries to match a record with a missing field `b`, "
"giving the following error on line 3:"
msgstr "在上述例子中，试图匹配一个结构体但缺少字段 `b` ，在第 3 行报错："

#: ../../language/error_codes/E4044.md:18
msgid "Record fields b are unmatched, use `..` to ignore them.\n"
msgstr ""

#: ../../language/error_codes/E4044.md:24
msgid ""
"Make sure to provide all fields in the pattern, or simply ignore the "
"missing fields using `..`:"
msgstr "确保在模式中提供所有字段，或者使用 `..` 忽略缺失的字段："

#: ../../language/error_codes/E4044.md:27
msgid ""
"struct S { a : Int; b: Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2, b: 3 } => 4\n"
"  { a: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4045.md:1
msgid "E4045"
msgstr ""

#: ../../language/error_codes/E4045.md:3
msgid "The field is not defined in the record type."
msgstr "这个字段在结构体类型中未定义。"

#: ../../language/error_codes/E4045.md:7
msgid ""
"struct S { a : Int, b : Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { c: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4045.md:15
msgid ""
"The example above tries to match a record with a nonexistent field `c`, "
"giving the following error on line 3:"
msgstr "在上述例子中，试图匹配一个结构体的不存在的字段 `c`，在第 3 行报错："

#: ../../language/error_codes/E4045.md:18
msgid "The fields c is not defined in the record type S.\n"
msgstr ""

#: ../../language/error_codes/E4045.md:24
msgid "Make sure to provide all fields with the correct names in the pattern."
msgstr "确保在模式中提供所有字段并使用正确的名称。"

#: ../../language/error_codes/E4045.md:26
msgid ""
"struct S { a : Int, b : Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:1
msgid "E4046"
msgstr ""

#: ../../language/error_codes/E4046.md:3
msgid "A public definition cannot depend on private entities."
msgstr "一个公开的定义不能依赖私有实体。"

#: ../../language/error_codes/E4046.md:7
msgid ""
"priv trait I { m(Self) }\n"
"pub impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:12
msgid ""
"The above example tries to implement a private trait `I` for the type "
"`Int`, but the implementation itself is public, which is not allowed. "
"This gives the following error on line 2:"
msgstr "在上述例子中，试图为类型 `Int` 实现一个私有特征 `I`，但实现本身是公开的，这是不允许的。在第 2 行报错："

#: ../../language/error_codes/E4046.md:16
msgid "A public definition cannot depend on private trait\n"
msgstr ""

#: ../../language/error_codes/E4046.md:22
msgid "Adjust the visibility of the trait or the implementation to match:"
msgstr "调整特征或实现的可见性以互相匹配："

#: ../../language/error_codes/E4046.md:24
msgid ""
"trait I { m(Self) -> Unit }\n"
"pub impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:31
msgid ""
"priv trait I { m(Self) -> Unit }\n"
"impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4047.md:1
msgid "E4047"
msgstr ""

#: ../../language/error_codes/E4047.md:3
msgid "Package not found when loading packages."
msgstr "未在加载中的包中发现包。"

#: ../../language/error_codes/E4047.md:5
msgid ""
"Normally, this error should never be emitted. If you see this error, "
"please report it as a bug at:"
msgstr "通常，这个错误不应该被发出。如果你看到这个错误，请提交报告："

#: ../../language/error_codes/E4047.md:8
msgid "<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug>"
msgstr ""

#: ../../language/error_codes/E4048.md:1
msgid "E4048"
msgstr ""

#: ../../language/error_codes/E4048.md:3
msgid "The package file is in wrong format."
msgstr "包文件的格式错误。"

#: ../../language/error_codes/E4048.md:5
msgid ""
"This means your local build files are corrupted. Try to run `moon clean` "
"or remove the `target` directory manually and build again. If the error "
"persists, please submit a bug report here:"
msgstr "这意味着你本地的构建文件已经损坏。尝试运行 `moon clean` 或移除 `target` 文件夹并重新构建。如果错误依然存在，请在此报告："

#: ../../language/error_codes/E4049.md:1
msgid "E4049"
msgstr ""

#: ../../language/error_codes/E4049.md:3
msgid "Magic number mismatch for the package file."
msgstr "魔法数字不匹配包文件。"

#: ../../language/error_codes/E4049.md:5
msgid ""
"This means your local build files are corrupted or outdated. First try "
"update/reinstall your MoonBit installation as in our [Download "
"Page](https://www.moonbitlang.com/download/). Then try to run `moon "
"clean` or remove the `target` directory manually and build again. If the "
"error persists, please submit a bug report here:"
msgstr ""
"这意味着你本地的构建文件已经损坏或过失。首先尝试通过我们的 "
"[下载页](https://www.moonbitlang.cn/download/)更新/重装你的 MoonBit 工具链。然后尝试运行 "
"`moon clean` 或移除 `target` 文件夹并重新构建。如果错误依然存在，请在此报告："

#: ../../language/error_codes/E4050.md:1
msgid "E4050"
msgstr ""

#: ../../language/error_codes/E4050.md:3
msgid "Definition cycle detected in dependencies."
msgstr "发现循环依赖。"

#: ../../language/error_codes/E4050.md:5
msgid ""
"The toplevel definitions in a MoonBit package are mutually recursive. "
"This means that the definitions can refer to each other in any order. "
"However, no cycles are allowed in the dependencies between the toplevel "
"variable definitions."
msgstr "MoonBit 包中的顶层定义是相互递归的。这意味着定义可以以任何顺序相互引用。然而，在顶层变量定义之间的依赖中不允许循环。"

#: ../../language/error_codes/E4050.md:11
msgid ""
"pub let a : Int = f() // Error: Definition cycle detected : a -> f -> a\n"
"\n"
"fn f() -> Int { // Error: Definition cycle detected : a -> f -> a\n"
"  a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4050.md:21
msgid ""
"The fix to this error varies depending on the logic of the program. One "
"possible fix is to make the variable definition to use `Ref[_?]`, and "
"initialize the variable later in `init` block of the program."
msgstr "这个错误的修复取决于程序的逻辑。一个可能的修复是将变量定义为 `Ref[_?]`，并在程序的 `init` 块中初始化变量。"

#: ../../language/error_codes/E4050.md:25
msgid ""
"pub let a : Ref[Int?] = Ref::new(None)\n"
"\n"
"fn init {\n"
"  a.val = Some(f())\n"
"}\n"
"\n"
"fn f() -> Int {\n"
"  a.val.unwrap()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4051.md:1
msgid "E4051"
msgstr ""

#: ../../language/error_codes/E4051.md:3
msgid "The identifier is declared twice."
msgstr "标识符被定义了两次。"

#: ../../language/error_codes/E4051.md:5
msgid ""
"Mutually recursive definitions in MoonBit shall not have the same "
"identifier. This include:"
msgstr "MoonBit 中的相互递归的定义不应该有相同的标识符。这包括："

#: ../../language/error_codes/E4051.md:8
msgid ""
"All toplevel definitions, including variables, functions, types, traits, "
"etc."
msgstr "所有的顶层定义，包括变量、函数、类型、特征等。"

#: ../../language/error_codes/E4051.md:9
msgid "Locally named functions. (Reported as [E4006](E4006))"
msgstr "局部的命名函数。 (报告为 [E4006](E4006))"

#: ../../language/error_codes/E4051.md:10
msgid "Local types."
msgstr "局部类型。"

#: ../../language/error_codes/E4051.md:12
msgid ""
"Note, locally defined variables are not mutually recursive, so they can "
"have the same identifier, and the later definition shadows the previous "
"one."
msgstr "注意，局部定义的变量不是相互递归的，所以它们可以有相同的标识符，后一个定义会遮蔽前一个。"

#: ../../language/error_codes/E4051.md:17
msgid "Toplevel variable definition:"
msgstr "顶层变量定义："

#: ../../language/error_codes/E4051.md:19
msgid ""
"pub let a = 0\n"
"pub let a = 1 // Error: The toplevel identifier a is declared twice: it "
"was previously defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:24
msgid "Toplevel function definition:"
msgstr "顶层函数定义："

#: ../../language/error_codes/E4051.md:26
msgid ""
"pub fn f() -> Unit {}\n"
"pub fn f() -> Unit {} // Error: The toplevel identifier f is declared "
"twice: it was previously defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:31
msgid "Toplevel type definition:"
msgstr "顶层类型定义"

#: ../../language/error_codes/E4051.md:33
msgid ""
"pub enum A {}\n"
"pub struct A {} // Error: The type A is declared twice: it was previously"
" defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:38
msgid "Local type definition:"
msgstr "局部类型定义"

#: ../../language/error_codes/E4051.md:40
msgid ""
"pub fn g() -> Unit {\n"
"  struct A {}\n"
"  struct A {} // Error: The local type A is declared twice: it was "
"previously defined at ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4051.md:49
msgid "Rename the identifier to a different name."
msgstr "将标识符改为其他的名称。"

#: ../../language/error_codes/E4051.md:51
msgid ""
"pub let a = 0\n"
"pub let b = 1\n"
msgstr ""

#: ../../language/error_codes/E4051.md:56
msgid ""
"If you want to shadow the previous definition, you can use a block and "
"put the definition in the block."
msgstr "如果你希望遮蔽前一个定义，可以使用一个块并将定义放在块中。"

#: ../../language/error_codes/E4051.md:59
msgid ""
"pub let a = {\n"
"  let a = 0\n"
"  1\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4052.md:1
msgid "E4052"
msgstr ""

#: ../../language/error_codes/E4052.md:3
msgid "The type/trait name duplicates with a previously defined identifier."
msgstr "类型/特征名称与先前定义的标识符重复。"

#: ../../language/error_codes/E4052.md:5
msgid "This can happen when you define a type and a trait with the same name."
msgstr "这发生在你定义了相同名称的类型和特征时。"

#: ../../language/error_codes/E4052.md:9
msgid ""
"pub type A\n"
"pub trait A {} // Error: The trait A duplicates with type A previously "
"defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4052.md:16
msgid "Rename either the type or the trait to a different name."
msgstr "将类型或特征改为其他名称。"

#: ../../language/error_codes/E4052.md:18
msgid ""
"pub type A\n"
"pub trait B {}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:1
msgid "E4053"
msgstr ""

#: ../../language/error_codes/E4053.md:3
msgid "Invalid type for \"self\": must be a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:5
msgid ""
"This error happens when you want to define a method for implement a trait"
" for a type that is not a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:8
msgid "Types that **are** type constructors:"
msgstr ""

#: ../../language/error_codes/E4053.md:10
msgid "Tuple: `(Int, Bool)`"
msgstr ""

#: ../../language/error_codes/E4053.md:11
msgid ""
"`enum`s, `struct`s, `trait`s, new types (`type`), and error types "
"(`type!`)."
msgstr ""

#: ../../language/error_codes/E4053.md:13
msgid "Types that **are not** type constructors:"
msgstr ""

#: ../../language/error_codes/E4053.md:15
msgid "Function: `(Int) -> Bool`"
msgstr ""

#: ../../language/error_codes/E4053.md:16
msgid "Type parameter: `T` in `fn f[T](x : T) -> T`"
msgstr ""

#: ../../language/error_codes/E4053.md:20
msgid "Defining a method for a type that is not type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:22
msgid ""
"fn f[T](self : T) -> Int { // Error: Invalid type for \"self\": must be a"
" type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"fn g(self : (Int) -> Unit) -> Unit { // Error: Invalid type for \"self\":"
" must be a type constructor.\n"
"  self(0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:33
msgid "Implementing a method for a type that is not a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:35
msgid ""
"pub trait A {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"// Without constraints\n"
"impl[X] A for X with f(self : X) -> Int { // Error: Invalid type for "
"\"self\": must be a type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"// With constraints\n"
"impl[X: Default] A for X with f(self : X) -> Int { // Error: Invalid type"
" for \"self\": must be a type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:55
msgid ""
"When you want to define a method for a type that is not a type "
"constructor, you may use new type to wrap the type."
msgstr ""

#: ../../language/error_codes/E4053.md:58
msgid ""
"pub(all) type Wrap[T] T\n"
"\n"
"fn f[T](self : Wrap[T]) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"fn g(self : Wrap[(Int) -> Unit]) -> Unit {\n"
"  (self._)(0)\n"
"}\n"
"\n"
"impl[X] A for Wrap[X] with f(self : Wrap[X]) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:76
msgid ""
"However, this means you may have to wrap the value with `Wrap` every time"
" you want to call the method."
msgstr ""

#: ../../language/error_codes/E4053.md:79
msgid ""
"If you find yourself implementing a trait for a type parameter, you may "
"also want to consider using default implementation for the trait."
msgstr ""

#: ../../language/error_codes/E4053.md:82
msgid ""
"impl A with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:89
msgid ""
"If you want to provide the implementation for types with specific "
"constraints, you can add these constraints to the trait definition."
msgstr ""

#: ../../language/error_codes/E4053.md:92
msgid ""
"trait A: Default {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"impl A with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4054.md:1
msgid "E4054"
msgstr ""

#: ../../language/error_codes/E4054.md:3
msgid ""
"Cannot determine self type of extension method. [Self] does not occur in "
"the signature of the method"
msgstr ""

#: ../../language/error_codes/E4055.md:1
msgid "E4055"
msgstr ""

#: ../../language/error_codes/E4055.md:3
msgid "Field is already declared."
msgstr ""

#: ../../language/error_codes/E4055.md:7
msgid ""
"struct A {\n"
"  a : Int\n"
"  a : Double\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4055.md:16
msgid "Rename the field to a different name."
msgstr ""

#: ../../language/error_codes/E4055.md:18
msgid ""
"struct A {\n"
"  a : Int\n"
"  b : Double\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4056.md:1
msgid "E4056"
msgstr ""

#: ../../language/error_codes/E4056.md:3
msgid "Method has already been defined."
msgstr ""

#: ../../language/error_codes/E4056.md:7
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"<\" + self.x.to_string() + \",\" + self.y.to_string() + \">\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4056.md:24
msgid "Remove the duplicate method and keep only one method:"
msgstr ""

#: ../../language/error_codes/E4056.md:26
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n"
"}\n"
"\n"
"// Remove the second Point::to_string method\n"
msgstr ""

#: ../../language/error_codes/E4057.md:1
msgid "E4057"
msgstr ""

#: ../../language/error_codes/E4057.md:3
msgid "The constructor is duplicate."
msgstr ""

#: ../../language/error_codes/E4057.md:7
msgid ""
"enum E {\n"
"  A\n"
"  A(Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4057.md:16
msgid "Rename the constructor to a different name."
msgstr ""

#: ../../language/error_codes/E4057.md:18
msgid ""
"enum E {\n"
"  A\n"
"  B(Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:1
msgid "E4059"
msgstr ""

#: ../../language/error_codes/E4059.md:3
msgid "Cannot define method for foreign type."
msgstr ""

#: ../../language/error_codes/E4059.md:5
msgid ""
"Foreign types are types that is not defined in the current package. "
"MoonBit only allows defining methods or implementing traits for types "
"that are defined in the current package."
msgstr ""

#: ../../language/error_codes/E4059.md:11
msgid "In package `a`:"
msgstr ""

#: ../../language/error_codes/E4059.md:13
msgid "pub type A Int\n"
msgstr ""

#: ../../language/error_codes/E4059.md:17
msgid "In package `b`:"
msgstr ""

#: ../../language/error_codes/E4059.md:19
msgid ""
"fn f(self : @a.A) -> Int { // Error: Cannot define method f for foreign "
"type @a.A\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:25
msgid ""
"Defining methods for builtin types, or types in standard library, is "
"another frequent case of this error:"
msgstr ""

#: ../../language/error_codes/E4059.md:28
msgid ""
"fn f(self : Int) -> Int { // Error: Cannot define method f for foreign "
"type Int\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:36
msgid "You can either move the type definition to the current package:"
msgstr ""

#: ../../language/error_codes/E4059.md:38
msgid ""
"pub type A Int\n"
"\n"
"fn f(self : A) -> Int {\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:46
msgid "Or use new type to wrap the foreign type:"
msgstr ""

#: ../../language/error_codes/E4059.md:48
msgid ""
"pub type WrapA @a.A\n"
"\n"
"fn f(self : WrapA) -> Int {\n"
"  ignore(self._) // Use `._` to access the wrapped value if @a.A is "
"public\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4060.md:1
msgid "E4060"
msgstr ""

#: ../../language/error_codes/E4060.md:3
msgid "Method type mismatch."
msgstr ""

#: ../../language/error_codes/E4060.md:5
msgid ""
"We require the type of implementation to have the exactly the same type "
"as the one defined in the trait. Notably, the following types are **not**"
" considered the same."
msgstr ""

#: ../../language/error_codes/E4060.md:9
msgid ""
"Labelled arguments with different order: `(a~ : Int, b~ : Int) -> Unit` "
"and `(b~ : Int, a~ : Int) -> Unit`."
msgstr ""

#: ../../language/error_codes/E4060.md:11
msgid "Optional arguments: `(a : Int, b? : Int) -> Unit` and `(a : Int) -> Unit`."
msgstr ""

#: ../../language/error_codes/E4060.md:15
msgid ""
"trait A {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"type T Int\n"
"\n"
"impl A for T with f(self : T) -> Int {\n"
"  //              ^\n"
"  // Error: Method f of trait A is expected to have type (T) -> Int,\n"
"  //        it cannot be implemented with type (T) -> Unit\n"
"  ignore(self)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4060.md:32
msgid "Make sure the method type matches the trait method type."
msgstr ""

#: ../../language/error_codes/E4060.md:34
msgid ""
"impl A for T with f(self : T) -> Int {\n"
"  ignore(self)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:1
msgid "E4061"
msgstr ""

#: ../../language/error_codes/E4061.md:3
msgid "Cannot define method of foreign trait for foreign type."
msgstr ""

#: ../../language/error_codes/E4061.md:5
msgid ""
"Foreign here means that the type or trait is not defined in the current "
"package. MoonBit follows the orphan rule, which means that you can only:"
msgstr ""

#: ../../language/error_codes/E4061.md
msgid "Traits"
msgstr "特征"

#: ../../language/error_codes/E4061.md
msgid "Types"
msgstr "类型"

#: ../../language/error_codes/E4061.md
msgid "Allowed?"
msgstr ""

#: ../../language/error_codes/E4061.md
msgid "Native"
msgstr ""

#: ../../language/error_codes/E4061.md
#, fuzzy
msgid "Yes"
msgstr "字节"

#: ../../language/error_codes/E4061.md
msgid "Foreign"
msgstr ""

#: ../../language/error_codes/E4061.md
msgid "No"
msgstr ""

#: ../../language/error_codes/E4061.md:15
msgid ""
"See the [Access control of methods and trait "
"implementations](../packages.md#access-control-of-methods-and-trait-"
"implementations) section of the MoonBit documentation for more "
"information."
msgstr ""

#: ../../language/error_codes/E4061.md:20
msgid ""
"Suppose you have type `A` and trait `B` defined in package `a` in module "
"`username/hello`:"
msgstr ""

#: ../../language/error_codes/E4061.md:23
#: ../../language/error_codes/E4073.md:16
#: ../../language/error_codes/E4074.md:29
#: ../../language/error_codes/E4094.md:18
#: ../../language/error_codes/E4145.md:18
msgid "`a/a.mbt`:"
msgstr ""

#: ../../language/error_codes/E4061.md:25
msgid ""
"pub(all) type A Int\n"
"pub(open) trait B {\n"
"  to_int(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:32
#: ../../language/error_codes/E4094.md:12
#: ../../language/error_codes/E4145.md:12
msgid "`a/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4061.md:38
msgid "Now, if you want to implement trait `@a.B` for type `@a.A`:"
msgstr ""

#: ../../language/error_codes/E4061.md:40
#: ../../language/error_codes/E4073.md:28
#: ../../language/error_codes/E4074.md:37
#: ../../language/error_codes/E4094.md:36
#: ../../language/error_codes/E4145.md:28
msgid "`b/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4061.md:42
#: ../../language/error_codes/E4073.md:30
#: ../../language/error_codes/E4074.md:39
#: ../../language/error_codes/E4145.md:30
msgid ""
"{\n"
"  \"import\": [\n"
"    \"username/hello/a\"\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:50
#: ../../language/error_codes/E4061.md:68
#: ../../language/error_codes/E4073.md:38
#: ../../language/error_codes/E4073.md:55
#: ../../language/error_codes/E4074.md:47
#: ../../language/error_codes/E4094.md:47
#: ../../language/error_codes/E4094.md:73
#: ../../language/error_codes/E4145.md:38
msgid "`b/b.mbt`:"
msgstr ""

#: ../../language/error_codes/E4061.md:52
msgid ""
"impl @a.B for @a.A with to_int(self : @a.A) -> Int {\n"
"  //                    ^~~~~~\n"
"  // Error: Cannot define method to_int of foreign trait @a.B for foreign"
" type @a.A\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:60
msgid "MoonBit will report an error."
msgstr ""

#: ../../language/error_codes/E4061.md:64
msgid ""
"You can move either the trait or type into the current package where the "
"implementation is in. If that is not possible, you can create a new type "
"over the foreign type and implement the trait for the new type:"
msgstr ""

#: ../../language/error_codes/E4061.md:70
msgid ""
"type WrapA @a.A\n"
"\n"
"impl @a.B for WrapA with to_int(self : WrapA) -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:1
msgid "E4062"
msgstr ""

#: ../../language/error_codes/E4062.md:3
msgid ""
"This `impl` shadows method previously defined. This will result in "
"different implementations for trait inside and outside current package."
msgstr ""

#: ../../language/error_codes/E4062.md:6
msgid ""
"In MoonBit, you can implicitly implement a trait for a type by defining "
"all the methods in that trait. For example, if you have trait like this:"
msgstr ""

#: ../../language/error_codes/E4062.md:9
msgid ""
"trait Coordinated { // use pub(open) when you want to implement it "
"outside current package.\n"
"  x(Self) -> Int\n"
"  y(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:16
msgid "Then, for a type `Point`, you can implement the trait like this:"
msgstr ""

#: ../../language/error_codes/E4062.md:18
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"}\n"
"\n"
"fn x(self : Point) -> Int {\n"
"  self.x\n"
"}\n"
"\n"
"fn y(self : Point) -> Int {\n"
"  self.y\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:33
msgid ""
"However, as you can implement a trait for a type explicitly with `impl`, "
"this may leads to inconsistent behavior when these two implementation "
"have different visibility."
msgstr ""

#: ../../language/error_codes/E4062.md:39
#, fuzzy
msgid "For example, in package `a`:"
msgstr "例如，对于一个枚举"

#: ../../language/error_codes/E4062.md:41
msgid ""
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"pub type A Int\n"
"\n"
"pub fn A::f(self : A) -> Int {\n"
"  println(\"A::f\")\n"
"  self._\n"
"}\n"
"\n"
"impl T for A with f(self : A) -> Int {\n"
"  //              ^\n"
"  // Error: This `impl` shadows method f of A previously defined at ...\n"
"  //        This will result in different implementations for T inside "
"and outside current package.\n"
"  println(\"impl T for A with f\")\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:62
msgid ""
"If these code were able to pass compilation, then for the function "
"defined in another package:"
msgstr ""

#: ../../language/error_codes/E4062.md:65
msgid ""
"fn probe[T : @a.T](t : T) -> Unit {\n"
"  ignore(t.f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:71
msgid ""
"The output will be `A::f`. However, if the `probe` function is defined in"
" the package `a`:"
msgstr ""

#: ../../language/error_codes/E4062.md:73
msgid ""
"fn probe[T : T](t : T) -> Unit {\n"
"  ignore(t.f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:79
msgid "The output will be `impl T for A with f`."
msgstr ""

#: ../../language/error_codes/E4062.md:83
msgid ""
"To fix this error, you need to make sure both the implicitly (`A::f`) and"
" explicitly implementation (`impl`) of the trait have the same "
"visibility."
msgstr ""

#: ../../language/error_codes/E4062.md:86
msgid ""
"// ...\n"
"pub impl T for A with f(self : A) -> Int {\n"
"  println(\"impl T for A with f\")\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4063.md:1
msgid "E4063"
msgstr ""

#: ../../language/error_codes/E4063.md:3
msgid "Type does not implement trait, although an `impl` is defined."
msgstr ""

#: ../../language/error_codes/E4063.md:5
msgid "This error can be further divided into 5 cases:"
msgstr ""

#: ../../language/error_codes/E4063.md:7 ../../language/error_codes/E4063.md:15
#, fuzzy
msgid "Method is missing"
msgstr "方法系统"

#: ../../language/error_codes/E4063.md:8
#, fuzzy
msgid "Implementation is private"
msgstr "实现细节"

#: ../../language/error_codes/E4063.md:9
msgid "Method type mismatch"
msgstr ""

#: ../../language/error_codes/E4063.md:10
msgid "Constraints are not satisfied"
msgstr ""

#: ../../language/error_codes/E4063.md:11
msgid "Method contains unresolved type parameters"
msgstr ""

#: ../../language/error_codes/E4063.md:17
msgid ""
"trait Number {\n"
"  to_int(Self) -> Int\n"
"  to_float(Self) -> Float\n"
"}\n"
"\n"
"type A Int\n"
"\n"
"impl Number for A with to_int(self : A) -> Int {\n"
"//^~~~~~~~~~~~~~~\n"
"// Error: Type A does not implement trait Number, although an `impl` is "
"defined.\n"
"// hint:\n"
"//   method to_float is missing.\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4063.md:36
msgid ""
"Modify the code according to the hint provided along with the error "
"message. For the example above, you can add the missing method `to_float`"
" to type `A`."
msgstr ""

#: ../../language/error_codes/E4063.md:39
msgid ""
"impl Number for A with to_float(self : A) -> Float {\n"
"  self._.to_float()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4065.md:1
msgid "E4065"
msgstr ""

#: ../../language/error_codes/E4065.md:3
msgid "Overloaded operator should accept the correct number of arguments."
msgstr ""

#: ../../language/error_codes/E4065.md:5
msgid ""
"You can refer to the [Operator Overloading](../methods.md#operator-"
"overloading) section for a list of operators that can be overloaded, and "
"here is a list of number of arguments that each operator should accept:"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "Operator"
msgstr "管道运算符"

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "Method Name"
msgstr "方法名称"

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "Number of Arguments"
msgstr "自动填充参数"

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`+`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_add`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "2"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`-`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_sub`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`*`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_mul`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`/`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_div`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`%`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_mod`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`==`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_equal`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`<<`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_shl`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`>>`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_shr`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`-` (unary)"
msgstr "`-`（一元）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_neg`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "1"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "`_[_]`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_get`"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "`_[_] = _`"
msgstr "`_[_] = _`（设置项）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_set`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "3"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "`_[_:_]`"
msgstr "`_[_:_]`（视图）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`op_as_view`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`&`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`land`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`|`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`lor`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`^`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:91
msgid "`lxor`"
msgstr ""

#: ../../language/error_codes/E4065.md:29
msgid ""
"type A Int\n"
"\n"
"fn A::op_add(self : A, other : A, opt? : A) -> A {\n"
"  //  ^~~~~~\n"
"  // Error: overloaded operator \"op_add\" should accept 2 arguments, but"
" it accepts 3 arguments\n"
"  let opt = match opt {\n"
"    None => 0\n"
"    Some(opt) => opt._\n"
"  }\n"
"  return self._ + other._ + opt\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4065.md:45
msgid ""
"Modify the method to match the expected number of arguments of the "
"operator."
msgstr ""

#: ../../language/error_codes/E4065.md:47
#: ../../language/error_codes/E4066.md:24
msgid ""
"fn A::op_add(self : A, other : A) -> A {\n"
"  self._ + other._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4066.md:1
msgid "E4066"
msgstr ""

#: ../../language/error_codes/E4066.md:3
msgid "Overloaded operator has inconsistent parameter type."
msgstr ""

#: ../../language/error_codes/E4066.md:5
msgid ""
"You can refer to the [Operator Overloading](../methods.md#operator-"
"overloading) section for a list of operators that can be overloaded, and "
"respectively their expected signature."
msgstr ""

#: ../../language/error_codes/E4066.md:11
msgid ""
"type A Int\n"
"fn A::op_add(self : A, other : Int) -> A {\n"
"  return self._ + other\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4066.md:20
msgid ""
"Modify the method to match the expected parameter type of the operator. "
"If you use the name for overloaded operators by accident, you can rename "
"the method to a different name."
msgstr ""

#: ../../language/error_codes/E4067.md:1
msgid "E4067"
msgstr ""

#: ../../language/error_codes/E4067.md:3
msgid "Missing main function in the main package."
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:5
msgid ""
"In MoonBit, packages are divided into two types: main packages and non-"
"main packages. Non-main packages are often used as libraries to provide "
"functionality to other packages. Main packages, on the other hand, are "
"the entry points of the program. Therefore, main package should contains "
"a `main` function serving as the entry point of the program."
msgstr ""

#: ../../language/error_codes/E4067.md:13
#: ../../language/error_codes/E4068.md:13
msgid "Suppose in package `main`:"
msgstr ""

#: ../../language/error_codes/E4067.md:17
#, fuzzy
msgid ""
"{ // Error: Missing main function in the main package.\n"
"  \"is-main\": true\n"
"}\n"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:25
msgid ""
"type A Int\n"
"\n"
"pub fn A::to_int(self : A) -> Int {\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4067.md:35
#, fuzzy
msgid "You can add a `main` function to the main package:"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:39
msgid ""
"// ...\n"
"fn main {\n"
"  let a : A = 42\n"
"  println(a.to_int())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4067.md:47
msgid ""
"Alternatively, you can set the package to be a non-main package by "
"setting `\"is-main\"` to `false` in the package configuration file."
msgstr ""

#: ../../language/error_codes/E4067.md:52
msgid ""
"{\n"
"  \"is-main\": false\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:1
msgid "E4068"
msgstr ""

#: ../../language/error_codes/E4068.md:3
msgid "Main function is already defined."
msgstr ""

#: ../../language/error_codes/E4068.md:5
msgid ""
"In MoonBit, a `main` package contains a single `main` function that "
"serves as the entry point of the program. Therefore, you cannot define "
"more than one `main` function in the main package. If you want to have "
"multiple programs to be built as separate binaries, you can use multiple "
"`main` packages within the same module."
msgstr ""

#: ../../language/error_codes/E4068.md:25
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
"\n"
"fn main { // Error: Main function is already defined at ...\n"
"  println(\"Hello, World! Again!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:37
msgid "You can either remove the extra `main` function:"
msgstr ""

#: ../../language/error_codes/E4068.md:39
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
"// Remove the extra main function\n"
"//- fn main {\n"
"//-   println(\"Hello, World! Again!\")\n"
"//- }\n"
msgstr ""

#: ../../language/error_codes/E4068.md:49
msgid ""
"Or you can move the extra `main` function to a different package, say "
"`main2`:"
msgstr ""

#: ../../language/error_codes/E4068.md:51
msgid "`main2/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4068.md:59
msgid "`main2/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E4068.md:61
msgid ""
"fn main {\n"
"  println(\"Hello, World! Again!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:67
msgid "while keeping the `main/main.mbt` contains only one main function:"
msgstr ""

#: ../../language/error_codes/E4068.md:69
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4069.md:1
msgid "E4069"
msgstr ""

#: ../../language/error_codes/E4069.md:3
msgid "Unexpected main function in the non-main package."
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:5
msgid ""
"In MoonBit, packages are divided into two types: main packages and non-"
"main packages. Non-main packages are often used as libraries to provide "
"functionality to other packages. Main packages, on the other hand, are "
"the entry points of the program. Therefore, non-main packages should not "
"contain a `main` function."
msgstr ""

#: ../../language/error_codes/E4069.md:10
msgid ""
"Sometimes, people use the main function for testing. In such cases, we "
"recommend using the `test` block to write tests, instead of using the "
"`main` function. See the [test](../introduction.md#test) section of the "
"MoonBit documentation for more information."
msgstr ""

#: ../../language/error_codes/E4069.md:17
msgid "Suppose in package `lib`:"
msgstr ""

#: ../../language/error_codes/E4069.md:21
msgid "{} // \"is-main\" is by default false\n"
msgstr ""

#: ../../language/error_codes/E4069.md:25
msgid "`lib/lib.mbt`:"
msgstr ""

#: ../../language/error_codes/E4069.md:27
#, fuzzy
msgid ""
"fn main { // Error: Unexpected main function in the non-main package.\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:35
#, fuzzy
msgid "You can remove the `main` function from the non-main package:"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:37
msgid ""
"// Remove the main function\n"
"//- fn main {\n"
"//-   println(\"Hello, world!\")\n"
"//- }\n"
msgstr ""

#: ../../language/error_codes/E4069.md:44
msgid ""
"Alternatively, you can set the package to be a main package by setting "
"`\"is-main\"` to `true` in the package configuration file."
msgstr ""

#: ../../language/error_codes/E4069.md:55
msgid "You can also move the `main` function to a different package, say `main`:"
msgstr ""

#: ../../language/error_codes/E4070.md:1
msgid "E4070"
msgstr ""

#: ../../language/error_codes/E4070.md:3
msgid "Unknown intrinsic. This intrinsic is not known to the MoonBit compiler."
msgstr ""

#: ../../language/error_codes/E4070.md:5 ../../language/error_codes/E4071.md:6
msgid ""
"Note all intrinsic is not intended for external use and is subject to "
"change without notice, and we highly recommend **against** using them."
msgstr ""

#: ../../language/error_codes/E4070.md:10
msgid ""
"pub fn my_abort(message : String) -> Unit = \"%abort\"\n"
"// Error: Unknown intrinsic: %abort\n"
"\n"
"fn main {\n"
"  my_abort(\"Abort!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4070.md:21
#, fuzzy
msgid ""
"You may probably want to use the `abort` function from the "
"`moonbitlang/core`:"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4070.md:23
msgid ""
"fn main {\n"
"  abort(\"Abort!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4070.md:29
msgid ""
"If you really need to use the intrinsic, you can check the source code of"
" `moonbitlang/core` for further usage of the corresponding intrinsic."
msgstr ""

#: ../../language/error_codes/E4071.md:1
msgid "E4071"
msgstr ""

#: ../../language/error_codes/E4071.md:3
msgid ""
"Multiple intrinsic is not supported. You have defined a function to use "
"multiple intrinsics."
msgstr ""

#: ../../language/error_codes/E4071.md:11
#, python-format
msgid ""
"type MyArray[T] Array[T]\n"
"\n"
"/// @intrinsic %array.get\n"
"/// @intrinsic %fixedarray.get\n"
"fn MyArray::get[T](self : MyArray[T], index : Int) -> T { // Error: "
"Multiple intrinsic is not unsupported.\n"
"  return self._[index]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4071.md:23
msgid "Remove the extra intrinsic and use only one intrinsic:"
msgstr ""

#: ../../language/error_codes/E4071.md:25
msgid ""
"/// @intrinsic %array.get\n"
"fn MyArray::get[T](self : MyArray[T], index : Int) -> T {\n"
"  return self._[index]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4071.md:32
msgid ""
"Avoid directly using intrinsics as much as possible, as we may change or "
"remove them in the future. If you really need to use the intrinsic, you "
"can check the source code of `moonbitlang/core` for further usage of the "
"corresponding intrinsic."
msgstr ""

#: ../../language/error_codes/E4072.md:1
msgid "E4072"
msgstr ""

#: ../../language/error_codes/E4072.md:3
msgid "Method of trait already has a default implementation."
msgstr ""

#: ../../language/error_codes/E4072.md:7
msgid ""
"trait T {\n"
"  to_int(Self) -> Int\n"
"}\n"
"\n"
"type A Int\n"
"\n"
"impl T with to_int(self : Self) -> Int {\n"
"  0\n"
"}\n"
"\n"
"impl T with to_int(self : Self) -> Int { // Error: Method to_int of trait"
" T already has a default implementation at\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4072.md:25
#, fuzzy
msgid "Remove the duplicated default implementation of the trait."
msgstr "不能为外来特征定义默认实现。"

#: ../../language/error_codes/E4072.md:27
msgid ""
"impl T with to_int(self : Self) -> Int {\n"
"  0\n"
"}\n"
"\n"
"// Remove this implementation\n"
"// impl T with to_int(self : Self) -> Int {\n"
"//   0\n"
"// }\n"
msgstr ""

#: ../../language/error_codes/E4073.md:1
msgid "E4073"
msgstr ""

#: ../../language/error_codes/E4073.md:3
msgid "Cannot provide default implementation for foreign trait."
msgstr "不能为外来特征定义默认实现。"

#: ../../language/error_codes/E4073.md:5
msgid ""
"This is a corollary of the [orphan rules of traits and types in "
"MoonBit](../packages.md#access-control-of-methods-and-trait-"
"implementations). Default implementation can be seen as implementing the "
"trait for all possible types, which include foreign and native types. "
"Therefore, it is only possible for default implementation to be defined "
"in the package of the trait, otherwise it would violate the orphan rules."
msgstr ""

#: ../../language/error_codes/E4073.md:14
msgid ""
"Suppose you have a trait `T` defined in package `a` in module "
"`username/hello`:"
msgstr ""

#: ../../language/error_codes/E4073.md:18
msgid ""
"// We need the trait to be pub(open) so that it can be implemented from "
"outside.\n"
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4073.md:25
msgid ""
"And when you want to define a default implementation for the trait in "
"another package, say `b`:"
msgstr ""

#: ../../language/error_codes/E4073.md:40
msgid ""
"impl @a.T with f(self : Self) -> Int {\n"
"  //           ^\n"
"  // Error: Cannot provide default implementation for foreign trait @a.T\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4073.md:51
msgid ""
"To fix this error, you can move the definition of the trait and the "
"default implementation of this trait into the same package. Say you can "
"move the trait definition into package `b`:"
msgstr ""

#: ../../language/error_codes/E4073.md:57
msgid ""
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"impl T with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4074.md:1
msgid "E4074"
msgstr ""

#: ../../language/error_codes/E4074.md:3
msgid "This error code is shared by the following two error messages:"
msgstr ""

#: ../../language/error_codes/E4074.md:5
msgid "Cannot infer the type of variable, please add more type annotation."
msgstr ""

#: ../../language/error_codes/E4074.md:6
msgid "Public definition a must be annotated with its type."
msgstr ""

#: ../../language/error_codes/E4074.md:8
msgid ""
"When defining a toplevel variable using `let`, MoonBit will try to infer "
"its type when the value is literal:"
msgstr ""

#: ../../language/error_codes/E4074.md:11
msgid ""
"pub let forty_two = 42\n"
"pub let float = 1.0\n"
"pub let string = \"Hello, world!\"\n"
"pub let array = [1, 2, 3]\n"
msgstr ""

#: ../../language/error_codes/E4074.md:20
msgid ""
"For \"Cannot infer the type of variable a, please add more type "
"annotation\":"
msgstr ""

#: ../../language/error_codes/E4074.md:22
msgid ""
"let a = 1 + 1 // Error: Cannot infer the type of variable a, please add "
"more type annotation.\n"
msgstr ""

#: ../../language/error_codes/E4074.md:26
msgid ""
"The other error message is more subtle. Say if you have module "
"`username/hello` and package `a`:"
msgstr ""

#: ../../language/error_codes/E4074.md:31
msgid "pub let value = 1.0\n"
msgstr ""

#: ../../language/error_codes/E4074.md:35
#, fuzzy
msgid "And package `b`:"
msgstr "例如，对于一个枚举"

#: ../../language/error_codes/E4074.md:49
msgid ""
"pub let value = @a.value // Error: Public definition a must be annotated "
"with its type.\n"
msgstr ""

#: ../../language/error_codes/E4074.md:55
msgid ""
"These two error can be fixed by explicitly annotating the type of the "
"variable:"
msgstr ""

#: ../../language/error_codes/E4074.md:57
msgid "let a : Int = 1 + 1\n"
msgstr ""

#: ../../language/error_codes/E4074.md:61
msgid "pub let value : Double = @a.value\n"
msgstr ""

#: ../../language/error_codes/E4075.md:1
msgid "E4075"
msgstr ""

#: ../../language/error_codes/E4075.md:3
msgid "Missing type annotation for the parameter."
msgstr ""

#: ../../language/error_codes/E4075.md:5
#, fuzzy
msgid "MoonBit requires all toplevel function to have full type annotation."
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E4075.md:9
msgid ""
"fn f(param) -> Unit { // Error: Missing type annotation for the parameter"
" param.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4075.md:16
msgid "Add type annotation for the parameter:"
msgstr ""

#: ../../language/error_codes/E4075.md:18
msgid ""
"fn f(param: Int) -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4075.md:23
msgid "Or if the parameter should be generic:"
msgstr ""

#: ../../language/error_codes/E4075.md:25
msgid ""
"fn f[T](param: T) -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4076.md:1
msgid "E4076"
msgstr ""

#: ../../language/error_codes/E4076.md:3
msgid "Missing type annotation for the return value."
msgstr ""

#: ../../language/error_codes/E4076.md:5
msgid ""
"MoonBit requires all toplevel function to have full type annotation. It "
"is a common mistake for people to forget to include the return type of a "
"function, especially when the function returns `Unit`."
msgstr ""

#: ../../language/error_codes/E4076.md:11
msgid ""
"fn f() { // Error: Missing type annotation for the return value.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4076.md:18
msgid "Add the return type of the function:"
msgstr ""

#: ../../language/error_codes/E4076.md:20
msgid ""
"fn f() -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4077.md:1
msgid "E4077"
msgstr ""

#: ../../language/error_codes/E4077.md:3
msgid "Don't know how to derive trait for type."
msgstr ""

#: ../../language/error_codes/E4077.md:5
msgid ""
"MoonBit allows you to derive implementation of some pre-defined traits "
"for your types. It means that you cannot have MoonBit automatically "
"derive a trait that you defined yourself."
msgstr ""

#: ../../language/error_codes/E4077.md:11
msgid ""
"trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"type A Int derive(T) // Error: Don't know how to derive trait T for type "
"A\n"
msgstr ""

#: ../../language/error_codes/E4077.md:21
#: ../../language/error_codes/E4078.md:17
msgid "You can implement the trait manually:"
msgstr ""

#: ../../language/error_codes/E4077.md:23
msgid ""
"trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"// Remove derive(T)\n"
"type A Int\n"
"\n"
"impl T for A with f(self : A) -> Int {\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4078.md:1
msgid "E4078"
msgstr ""

#: ../../language/error_codes/E4078.md:3
msgid "Cannot derive trait for type."
msgstr ""

#: ../../language/error_codes/E4078.md:5
msgid ""
"MoonBit allows you to derive implementation of some traits for your "
"types. However, not all types can be automatically derived. For example, "
"you cannot derive a trait for an abstract type."
msgstr ""

#: ../../language/error_codes/E4078.md:11
msgid ""
"type T derive(Hash) // Error: Cannot derive trait Hash for type T: target"
" type is abstract\n"
msgstr ""

#: ../../language/error_codes/E4078.md:19
msgid ""
"type T\n"
"\n"
"impl Hash for T with hash_combine(self : T, hasher: Hasher) {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4079.md:1
msgid "E4079"
msgstr ""

#: ../../language/error_codes/E4079.md:3
msgid "Cannot derive trait: method is already defined."
msgstr ""

#: ../../language/error_codes/E4079.md:5
msgid ""
"This error occurs when you try to derive a trait for a type that already "
"has a implementation for the trait."
msgstr ""

#: ../../language/error_codes/E4079.md:10
msgid ""
"impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"  logger.write_object(self._)\n"
"}\n"
"\n"
"type A Int derive(Hash, Show) // Error: Cannot derive trait Show for A: "
"method output is already defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4079.md:20
msgid ""
"You can pick either the manual implementation or the derived "
"implementation for the type by removing the other one."
msgstr ""

#: ../../language/error_codes/E4079.md:23
msgid "To use the derived implementation:"
msgstr ""

#: ../../language/error_codes/E4079.md:25
msgid ""
"// Remove the manual implementation\n"
"// impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"//   logger.write_object(self._)\n"
"// }\n"
"\n"
"type A Int derive(Hash, Show)\n"
msgstr ""

#: ../../language/error_codes/E4079.md:34
msgid "Or to use the manual implementation:"
msgstr ""

#: ../../language/error_codes/E4079.md:36
msgid ""
"impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"  logger.write_object(self._)\n"
"}\n"
"\n"
"type A Int derive(Hash)\n"
msgstr ""

#: ../../language/error_codes/E4080.md:1
msgid "E4080"
msgstr ""

#: ../../language/error_codes/E4080.md:3
msgid "Arity mismatch: incorrect number of arguments provided."
msgstr ""

#: ../../language/error_codes/E4080.md:7 ../../language/error_codes/E4080.md:37
msgid "Function arity mismatch:"
msgstr ""

#: ../../language/error_codes/E4080.md:9
msgid ""
"fn f(x : Int, y : Double) -> Unit {\n"
"  ignore((x, y))\n"
"}\n"
"\n"
"fn main {\n"
"  f(0) // Error: This function has type (Int, Double) -> Unit, which "
"requires 2 arguments, but is given 1 argument.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4080.md:19
#: ../../language/error_codes/E4080.md:45
msgid "Constructor arity mismatch:"
msgstr ""

#: ../../language/error_codes/E4080.md:21
msgid ""
"enum E {\n"
"  A(Int, Double, String)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(0, 1.0) { // Error: This function has type (Int, Double, "
"String) -> E, which requires 3 arguments, but is given 2 arguments.\n"
"    A(_, _) => ... // Error: The constructor A requires 3 arguments, but "
"is given 2 arguments.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4080.md:35
#, fuzzy
msgid "Provide the correct number of arguments."
msgstr "自动填充参数"

#: ../../language/error_codes/E4080.md:39
msgid ""
"fn main {\n"
"  f(0, 1.0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4080.md:47
msgid ""
"fn main {\n"
"  match A(0, 1.0, \"foo\") {\n"
"    A(_, _, _) => ...\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4081.md:1
msgid "E4081"
msgstr ""

#: ../../language/error_codes/E4081.md:3
msgid "The identifier is bound more than once in the same pattern."
msgstr ""

#: ../../language/error_codes/E4081.md:5
msgid ""
"It is not possible to bind to values into one identifier because they "
"might have different values. If you want to shadow the first identifier, "
"you can use `_` to discard it."
msgstr ""

#: ../../language/error_codes/E4081.md:11
msgid ""
"fn f(a : Int?, b : Int?) -> Unit {\n"
"  match (a, b) {\n"
"    (Some(a), Some(a)) => println(\"Some(\\{a})\")\n"
"    //    ^ Error: The identifier a is bound more than once in the same "
"pattern.\n"
"    _ => println(\"None\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4081.md:23
msgid "Use a different name for the second identifier."
msgstr ""

#: ../../language/error_codes/E4081.md:25
msgid ""
"fn f(a : Int?, b : Int?) -> Unit {\n"
"  match (a, b) {\n"
"    (Some(a), Some(b)) => println(\"Some(\\{a}), Some(\\{b})\")\n"
"    _ => println(\"None\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4081.md:34
msgid ""
"If you want a shadow-like behavior here, you can explicitly discard the "
"first `a` using `_`:"
msgstr ""

#: ../../language/error_codes/E4081.md:37
msgid ""
"fn f(a : Int?, b : Int?) -> Unit {\n"
"  match (a, b) {\n"
"    (Some(_), Some(a)) => println(\"Some(\\{a})\")\n"
"    _ => println(\"None\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4082.md:1
msgid "E4082"
msgstr ""

#: ../../language/error_codes/E4082.md:3
msgid "Variable is not bound in all patterns."
msgstr ""

#: ../../language/error_codes/E4082.md:5
msgid ""
"When using the `|` operator in a pattern, all variables must be bound in "
"all patterns. If a variable were not bound in all patterns, it would be "
"free variable when the pattern is matched, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4082.md:11
msgid ""
"enum E {\n"
"  A(Int, Double)\n"
"  B(Int)\n"
"}\n"
"\n"
"fn f(value : E) -> Unit {\n"
"  match value {\n"
"    A(a, _) | B(_) => println(\"Hello\") // Error: Variable a is not "
"bound in all patterns.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4082.md:26
msgid ""
"fn f(value : E) -> Unit {\n"
"  match value {\n"
"    A(a, _) | B(a) => println(\"Hello\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4083.md:1
msgid "E4083"
msgstr ""

#: ../../language/error_codes/E4083.md:3
msgid "The type does not implement `op_as_view` method."
msgstr ""

#: ../../language/error_codes/E4083.md:5
msgid ""
"This error code shall not be emitted when you are not developing the core"
" library. If you see this error, please report it as a bug to the core "
"library here:"
msgstr ""

#: ../../language/error_codes/E4083.md:9
msgid "<https://github.com/moonbitlang/core/issues/new>"
msgstr ""

#: ../../language/error_codes/E4084.md:1
msgid "E4084"
msgstr ""

#: ../../language/error_codes/E4084.md:3
msgid ""
"The label is supplied twice when calling a function with labelled "
"parameters."
msgstr ""

#: ../../language/error_codes/E4084.md:7
msgid ""
"pub fn f(a~ : Int) -> Unit {\n"
"  println(\"Hello, \\{a}\")\n"
"}\n"
"\n"
"fn main {\n"
"  f(a=0, a=1) // Error: The label a~ is supplied twice.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4084.md:19
msgid ""
"As there is only one labelled parameter in the function call, you can "
"simply provide a single value."
msgstr ""

#: ../../language/error_codes/E4084.md:22
msgid ""
"fn main {\n"
"  f(a=0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4084.md:28
msgid ""
"When there are multiple labelled parameters in the function call, and you"
" made a typo to make this error, then you can change the name of the "
"label supplied to the correct one."
msgstr ""

#: ../../language/error_codes/E4084.md:32
msgid ""
"fn main {\n"
"  f(a=0, b=1)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4085.md:1
msgid "E4085"
msgstr ""

#: ../../language/error_codes/E4085.md:3
msgid "This has no parameter with the given label."
msgstr "给定标签没有参数。"

#: ../../language/error_codes/E4085.md:5
msgid "This error happens when:"
msgstr ""

#: ../../language/error_codes/E4085.md:7
msgid "You made a typo in the label name;"
msgstr ""

#: ../../language/error_codes/E4085.md:8
#, fuzzy
msgid "You mistakenly treat a positional argument as a labelled argument."
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E4085.md:9
msgid "You provided extra labelled arguments to the function."
msgstr ""

#: ../../language/error_codes/E4085.md:13
msgid ""
"pub fn f(name : String) -> Unit {\n"
"  println(\"Hello, \\{name}\")\n"
"}\n"
"\n"
"fn main {\n"
"  f(\"John\", age=20) // Error: This function has no parameter with label"
" age~.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4085.md:25
msgid ""
"Check the signature of the function and provide the correct label name or"
" remove the extra labelled argument."
msgstr ""

#: ../../language/error_codes/E4085.md:28
msgid ""
"pub fn f(name : String) -> Unit {\n"
"  println(\"Hello, \\{name}\")\n"
"}\n"
"\n"
"fn main {\n"
"  f(\"John\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4086.md:1
msgid "E4086"
msgstr ""

#: ../../language/error_codes/E4086.md:3
msgid "The labels are required by this function, but not supplied."
msgstr ""

#: ../../language/error_codes/E4086.md:5
msgid ""
"Sometimes this error occurs when you mistakenly treat a labelled argument"
" as a positional argument. There are some common functions that require "
"labelled arguments, such as:"
msgstr ""

#: ../../language/error_codes/E4086.md:9
msgid "`@test.snapshot`. Remember to supply `filename` as a labelled argument."
msgstr ""

#: ../../language/error_codes/E4086.md:10
msgid "`@test.inspect`. Remember to supply `content` as a labelled argument."
msgstr ""

#: ../../language/error_codes/E4086.md:14
msgid ""
"pub fn f(name~ : String) -> Unit {\n"
"  println(\"Hello, \\{name}\")\n"
"}\n"
"\n"
"fn main {\n"
"  f(\"John\") // Error: The labels name~ are required by this function, "
"but not supplied.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4086.md:26
msgid ""
"Check the signature of the function and provide the correct labelled "
"argument."
msgstr ""

#: ../../language/error_codes/E4086.md:28
msgid ""
"pub fn f(name~ : String) -> Unit {\n"
"  println(\"Hello, \\{name}\")\n"
"}\n"
"\n"
"fn main {\n"
"  f(name=\"John\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4087.md:1
msgid "E4087"
msgstr ""

#: ../../language/error_codes/E4087.md:3
msgid "The variable is not mutable."
msgstr ""

#: ../../language/error_codes/E4087.md:5
msgid ""
"MoonBit requires programmers to explicitly declare mutable variables. "
"Notice that mutability in MoonBit only refers to the variable itself, not"
" the value it holds. This means for `Array[T]`, `Ref[T]`, and mutable "
"fields in `struct`, you don't have to declare them as mutable."
msgstr ""

#: ../../language/error_codes/E4087.md:12
msgid ""
"fn main {\n"
"  let a = 0\n"
"  a = 1 // Error: The variable a is not mutable.\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4087.md:22
msgid ""
"To fix this error, you need to declare the variable as mutable by adding "
"the `mut` keyword before the variable name."
msgstr ""

#: ../../language/error_codes/E4087.md:25
msgid ""
"fn main {\n"
"  let mut a = 0\n"
"  a = 1\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4088.md:1
msgid "E4088"
msgstr ""

#: ../../language/error_codes/E4088.md:3
msgid "The record field is immutable."
msgstr ""

#: ../../language/error_codes/E4088.md:5
msgid ""
"MoonBit requires programmers to explicitly annotate which fields in a "
"record they wish to be mutable. By default, all fields in a record are "
"immutable. To make a field mutable, you need to add the `mut` keyword "
"before the field."
msgstr ""

#: ../../language/error_codes/E4088.md:11
msgid ""
"struct S {\n"
"  value : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s = { value: 42 }\n"
"  s.value = 43 // Error: The record field value is immutable.\n"
"  println(s.value)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4088.md:25
msgid ""
"To fix this error, you need to declare the field as mutable by adding the"
" `mut` keyword before the field name."
msgstr ""

#: ../../language/error_codes/E4088.md:28
msgid ""
"struct S {\n"
"  mut value : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s = { value: 42 }\n"
"  s.value = 43\n"
"  println(s.value)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4089.md:1
msgid "E4089"
msgstr ""

#: ../../language/error_codes/E4089.md:3
msgid "Tuple has no field with the given index."
msgstr ""

#: ../../language/error_codes/E4089.md:5
msgid ""
"In MoonBit, one can access the element in a tuple using index accessor, "
"like `tuple.0`, `tuple.1`, and so on. **The index starts with 0**, and "
"the compiler will emit this error if you try to access an element that "
"does not exist in the tuple, for example, accessing the third element "
"(`tuple.2`) in a tuple with only two elements."
msgstr ""

#: ../../language/error_codes/E4089.md:13
msgid ""
"fn main {\n"
"  let tuple = (1, 2)\n"
"  println(tuple.2)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4089.md:22
msgid ""
"To fix this error, you need to access the element within the tuple that "
"exists."
msgstr ""

#: ../../language/error_codes/E4089.md:24
msgid ""
"fn main {\n"
"  let tuple = (1, 2)\n"
"  println(tuple.1)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4090.md:1
msgid "E4090"
msgstr ""

#: ../../language/error_codes/E4090.md:3
msgid ""
"Tuples are not mutable. You cannot change the value of a field in a tuple"
" using assignment."
msgstr ""

#: ../../language/error_codes/E4090.md:8
msgid ""
"fn main {\n"
"  let a = (1, 2, 3)\n"
"  a.2 = 4 // Error: tuples are not mutable\n"
"  println(a.2)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4090.md:18
msgid ""
"If you need to change the value of a field in a tuple, you should use a "
"struct instead."
msgstr ""

#: ../../language/error_codes/E4090.md:21
msgid ""
"pub struct MyStruct {\n"
"  a: Int\n"
"  b: Int\n"
"  mut c: Int\n"
"}\n"
"\n"
"fn main {\n"
"  let a : MyStruct = { a : 1, b : 2, c : 3 }\n"
"  a.c = 4\n"
"  println(a.c)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4091.md:1
msgid "E4091"
msgstr ""

#: ../../language/error_codes/E4091.md:3
msgid "The type has no field with the given name."
msgstr ""

#: ../../language/error_codes/E4091.md:5
msgid ""
"It is possible that you made a typo and use a wrong field name to access "
"the field of a struct."
msgstr ""

#: ../../language/error_codes/E4091.md:10
msgid ""
"struct Point {\n"
"  x : Double\n"
"  y : Double\n"
"}\n"
"\n"
"fn main {\n"
"  let point = Point::{ x : 1.0, y : 2.0 }\n"
"  println(point.z) // Error: The type Point has no field z.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4091.md:24
msgid ""
"You can either add the missing field to the struct, or use an existing "
"field to access the struct."
msgstr ""

#: ../../language/error_codes/E4091.md:27
msgid ""
"struct Point {\n"
"  x : Double\n"
"  y : Double\n"
"}\n"
"\n"
"fn main {\n"
"  let point = Point::{ x : 1.0, y : 2.0 }\n"
"  println(point.x)\n"
"  println(point.y)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4092.md:1
msgid "E4092"
msgstr ""

#: ../../language/error_codes/E4092.md:3
msgid "Missing annotation for this empty record."
msgstr ""

#: ../../language/error_codes/E4092.md:5
msgid ""
"Currently, the MoonBit compiler does not emit this error, as it is "
"impossible to create an empty record without using `T::{ .. }` syntax."
msgstr ""

#: ../../language/error_codes/E4093.md:1
msgid "E4093"
msgstr ""

#: ../../language/error_codes/E4093.md:3
msgid "The type is not a record type."
msgstr ""

#: ../../language/error_codes/E4093.md:5
msgid ""
"This error occurs when you try to construct a type that is not a `struct`"
" using the `T::{ .. }` syntax."
msgstr ""

#: ../../language/error_codes/E4093.md:10
msgid ""
"enum Point {\n"
"  D2(Double, Double)\n"
"  D3(Double, Double, Double)\n"
"}\n"
"\n"
"fn main {\n"
"  let a = Point::{ x : 1.0, y : 2.0 }\n"
"  //      ^~~~~\n"
"  // Error: The type Point is not a record type\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4093.md:25
msgid "You should use the correct syntax to construct the type."
msgstr ""

#: ../../language/error_codes/E4093.md:27
msgid ""
"fn main {\n"
"  let a = Point::D2(1.0, 2.0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4094.md:1
msgid "E4094"
msgstr ""

#: ../../language/error_codes/E4094.md:3
msgid "Cannot modify a read-only field."
msgstr ""

#: ../../language/error_codes/E4094.md:5
msgid ""
"For a read-only `struct`, you cannot modify the value of a field using "
"assignment outside of the package where the type is defined."
msgstr ""

#: ../../language/error_codes/E4094.md:10
msgid "Suppose you have a package `a` in module `username/hello`:"
msgstr ""

#: ../../language/error_codes/E4094.md:20
msgid ""
"pub struct T {\n"
"  mut value : Int\n"
"}\n"
"\n"
"pub fn T::new() -> T {\n"
"  T::{ value: 0 }\n"
"}\n"
"\n"
"pub fn T::set(self : T, value : Int) -> Unit {\n"
"  self.value = value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4094.md:34
msgid "And you have another package `b` in the same module:"
msgstr ""

#: ../../language/error_codes/E4094.md:38
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    \"username/hello/a\"\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4094.md:49
msgid ""
"fn main {\n"
"  let a = @a.T::new()\n"
"  a.value = 3 // Error: Cannot modify a read-only field: value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4094.md:58
msgid ""
"If you have control over the package where the type is defined, you can "
"simply make the struct has `pub(all)` visibility."
msgstr ""

#: ../../language/error_codes/E4094.md:61
msgid "`a/a.mbt"
msgstr ""

#: ../../language/error_codes/E4094.md:63
#, fuzzy
msgid ""
"pub(all) struct T {\n"
"  mut value : Int\n"
"}\n"
msgstr "对于结构体字段"

#: ../../language/error_codes/E4094.md:69
msgid ""
"However, this might not be the best solution if you want to hide the "
"implementation details of the struct or protect the invariant of the "
"struct. We recommend using getter/setter pattern to guard the access to "
"the struct fields."
msgstr ""

#: ../../language/error_codes/E4094.md:75
msgid ""
"fn main {\n"
"  let a = @a.T::new()\n"
"  a.set(3)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4095.md:1
msgid "E4095"
msgstr ""

#: ../../language/error_codes/E4095.md:3
msgid "Integer literal is out of range."
msgstr ""

#: ../../language/error_codes/E4095.md:5
msgid ""
"Integer literals can be used to initialize `Byte`, `Int16`, `Int`, "
"`Int64` and their unsigned variants. The range of these types are as "
"follows:"
msgstr ""

#: ../../language/error_codes/E4095.md
#, fuzzy
msgid "Type"
msgstr "类型"

#: ../../language/error_codes/E4095.md
#, fuzzy
msgid "Minimum value"
msgstr "映射值"

#: ../../language/error_codes/E4095.md
#, fuzzy
msgid "Maximum value"
msgstr "映射值"

#: ../../language/error_codes/E4095.md
#, fuzzy
msgid "Byte"
msgstr "字节"

#: ../../language/error_codes/E4095.md
msgid "0"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "255"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "Int16"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "-32768"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "32767"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "UInt16"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "65536"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "Int"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "-2147483648"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "2147483647"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "UInt"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "4294967295"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "Int64"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "-9223372036854775808"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "9223372036854775807"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "UInt64"
msgstr ""

#: ../../language/error_codes/E4095.md
msgid "18446744073709551615"
msgstr ""

#: ../../language/error_codes/E4095.md:20
msgid ""
"fn main {\n"
"  let byte : Byte = 256\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4095.md:28
msgid ""
"You should either use a value that falls into the range of corresponding "
"type, or adjust the type to accommodate the value."
msgstr ""

#: ../../language/error_codes/E4095.md:30
msgid ""
"fn main {\n"
"  let int : Int = 256\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4100.md:1
msgid "E4100"
msgstr ""

#: ../../language/error_codes/E4100.md:3
msgid "The type is not a trait."
msgstr ""

#: ../../language/error_codes/E4100.md:5
msgid ""
"This error occurs when you try to use the `typealias` syntax to define a "
"alias for a type and use it as a trait. As it is impossible to use a type"
" as a trait, this error might hint at a typo in your code."
msgstr ""

#: ../../language/error_codes/E4100.md:11
msgid ""
"type Original Int\n"
"\n"
"typealias Alias = Original\n"
"\n"
"trait Trait: Alias {\n"
"  //         ^~~~~\n"
"  // Error: The type Alias is not a trait\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4100.md:24
msgid ""
"If there is a typo, the use a correct trait or alias of trait at where "
"the error occurs."
msgstr ""

#: ../../language/error_codes/E4100.md:27
msgid ""
"trait Original {\n"
"  to_int(Self) -> Int\n"
"}\n"
"\n"
"typealias Alias = Original\n"
"\n"
"trait Trait: Alias {\n"
"  to_int(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4100.md:39
msgid ""
"We recommend using `traitalias` for defining aliases for traits, as this "
"will detect errors like this earlier."
msgstr ""

#: ../../language/error_codes/E4101.md:1
msgid "E4101"
msgstr ""

#: ../../language/error_codes/E4101.md:3
msgid "Unsupported expression after the pipe operator."
msgstr ""

#: ../../language/error_codes/E4101.md:5
msgid ""
"This error occurs when the expression after the pipe operator (`|>`) is "
"not in a supported form. The pipe operator allows you to chain function "
"calls in a more readable way, but only supports specific forms on its "
"right-hand side."
msgstr ""

#: ../../language/error_codes/E4101.md:9
msgid "The following forms are allowed after the pipe operator:"
msgstr ""

#: ../../language/error_codes/E4101.md:11
msgid "A single identifier (function name)"
msgstr ""

#: ../../language/error_codes/E4101.md:12
msgid "A regular function application (but not method calls)"
msgstr ""

#: ../../language/error_codes/E4101.md:13
#, fuzzy
msgid "A constructor name"
msgstr "运算符名称"

#: ../../language/error_codes/E4101.md:14
#, fuzzy
msgid "A constructor application"
msgstr "函数应用"

#: ../../language/error_codes/E4101.md:18
msgid ""
"type T Int\n"
"\n"
"fn m(self: T, x: Int) -> Unit {\n"
"  println(self._ + x)\n"
"}\n"
"\n"
"pub fn f(t: T, x: Int) -> Unit {\n"
"  x |> fn(x: Int) { println(x)}\n"
"//     ^^^^^^^^^^^^^^^^^^^^^^^^ Error: Unsupported expression after the "
"pipe operator.\n"
"  x |> t.m()\n"
"//     ^^^^ Error: Unsupported expression after the pipe operator.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4101.md:35
msgid ""
"To fix this error, you can change the invalid pipe expression to normal "
"function or method application."
msgstr ""

#: ../../language/error_codes/E4101.md:38
msgid ""
"type T Int\n"
"\n"
"fn m(self: T, x: Int) -> Unit {\n"
"  println(self._ + x)\n"
"}\n"
"\n"
"pub fn f(t: T, x: Int) -> Unit {\n"
"  fn(x: Int) { println(x)}(x)\n"
"  t.m(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4102.md:1
msgid "E4102"
msgstr ""

#: ../../language/error_codes/E4102.md:3
msgid "Outside of a loop."
msgstr ""

#: ../../language/error_codes/E4102.md:5
msgid ""
"This error occurs when using `break` or `continue` statements outside of "
"a loop construct. These control flow statements can only be used within "
"loops."
msgstr ""

#: ../../language/error_codes/E4102.md:8
msgid "`break` is used to exit a loop early"
msgstr ""

#: ../../language/error_codes/E4102.md:9
msgid "`continue` is used to skip to the next iteration of a loop"
msgstr ""

#: ../../language/error_codes/E4102.md:11
msgid ""
"Using these statements outside of a loop context is invalid since there "
"is no loop to break from or continue to the next iteration."
msgstr ""

#: ../../language/error_codes/E4102.md:16
msgid ""
"pub fn f(xs: Array[Int]) -> Int {\n"
"  for i in xs {\n"
"    ignore(i)\n"
"  } else {\n"
"    break 42\n"
"//  ^^^^^^^^ Error: 'break' outside of a loop\n"
"  }\n"
"}\n"
"\n"
"pub fn g(x: Int) -> Int {\n"
"  continue x\n"
"// ^^^^^^^^ Error: 'continue' outside of a loop\n"
"}\n"
"\n"
"fn main {\n"
"  let x = { break }\n"
"//          ^^^^^ Error: 'break' outside of a loop\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4102.md:40
msgid ""
"To fix this error, ensure that `break` and `continue` are used within a "
"loop construct."
msgstr ""

#: ../../language/error_codes/E4103.md:1
msgid "E4103"
msgstr ""

#: ../../language/error_codes/E4103.md:3
msgid "This loop has incorrect number of patterns supplied."
msgstr ""

#: ../../language/error_codes/E4103.md:5
msgid ""
"This error occurs when the number of patterns in a loop arm does not "
"match the number of loop arguments. In a loop construct, each arm must "
"have the same number of patterns as there are loop arguments."
msgstr ""

#: ../../language/error_codes/E4103.md:9
msgid ""
"For example, if a loop takes 2 arguments, each arm must have exactly 2 "
"patterns to match against those arguments. Having too few or too many "
"patterns will trigger this error."
msgstr ""

#: ../../language/error_codes/E4103.md:15
msgid ""
"pub fn f(x: Int, y: Int) -> Int {\n"
"  loop x, y {\n"
"    0, 0 => 0\n"
"    a => continue a - 1, 0\n"
"//  ^ Error: This loop has 2 arguments, but 1 patterns are supplied\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4103.md:27
msgid ""
"To fix this error, ensure that each arm in the loop has the correct "
"number of patterns to match the loop arguments. For example,"
msgstr ""

#: ../../language/error_codes/E4103.md:30
msgid ""
"pub fn f(x: Int, y: Int) -> Int {\n"
"  loop x, y {\n"
"    0, 0 => 0\n"
"    a, b => continue a - 1, b - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4104.md:1
msgid "E4104"
msgstr ""

#: ../../language/error_codes/E4104.md:3
msgid ""
"Current loop expects different number of arguments than supplied with "
"`continue`."
msgstr ""

#: ../../language/error_codes/E4104.md:5
msgid ""
"This error occurs when the number of arguments provided to a `continue` "
"statement does not match the number of arguments expected by the loop. In"
" a `loop` construct, when using `continue`, you must provide the same "
"number of arguments as declared in the loop header."
msgstr ""

#: ../../language/error_codes/E4104.md:10
msgid ""
"For example, if a `loop` takes 2 arguments, any `continue` statement "
"within that `loop` must also provide exactly 2 arguments. Providing too "
"few or too many arguments will trigger this error."
msgstr ""

#: ../../language/error_codes/E4104.md:14
msgid ""
"Note that in a `for` loop, you can omit all arguments in a `continue` "
"statement. In this case, the loop will use the default update expressions"
" specified in the loop header. However, if you do provide arguments to "
"`continue`, the number of arguments must match the number of loop "
"variables."
msgstr ""

#: ../../language/error_codes/E4104.md:19
msgid "For example, in a `for` loop with two variables:"
msgstr ""

#: ../../language/error_codes/E4104.md:21
msgid "`continue` (with no arguments) will use the default updates"
msgstr ""

#: ../../language/error_codes/E4104.md:22
msgid "`continue x, y` (with two arguments) is valid"
msgstr ""

#: ../../language/error_codes/E4104.md:23
msgid "`continue x` or `continue x, y, z` will trigger this error"
msgstr ""

#: ../../language/error_codes/E4104.md:27
msgid ""
"pub fn f(x: Int, y: Int) -> Int {\n"
"  loop x, y {\n"
"    0, 0 => 0\n"
"    a, _ => continue a - 1\n"
"//          ^^^^^^^^^^^^^^ Error: Current loop expects 2 arguments, but\n"
"//                                `continue` is supplied with 1 arguments"
"\n"
"  }\n"
"}\n"
"\n"
"pub fn g(x : Int, y : Int) -> Int {\n"
"  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {\n"
"    if i < j {\n"
"      continue i + 2, j + 1, i + j\n"
"//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: Current loop expects 2 "
"arguments, but\n"
"//                                       `continue` is supplied with 3 "
"arguments\n"
"    }\n"
"  } else {\n"
"    42\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4104.md:52
msgid ""
"To fix this error, ensure that the number of arguments provided to "
"`continue` matches the number of loop variables. For example,"
msgstr ""

#: ../../language/error_codes/E4104.md:55
msgid ""
"pub fn f(x: Int, y: Int) -> Int {\n"
"  loop x, y {\n"
"    0, 0 => 0\n"
"    a, b => continue a - 1, b - 1\n"
"  }\n"
"}\n"
"\n"
"pub fn g(x : Int, y : Int) -> Int {\n"
"  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {\n"
"    if i < j {\n"
"      continue i + 2, j + 1\n"
"    } else {\n"
"      continue\n"
"    }\n"
"  } else {\n"
"    42\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4105.md:1
msgid "E4105"
msgstr ""

#: ../../language/error_codes/E4105.md:3
msgid "Current loop has result type mismatch with `break` argument."
msgstr ""

#: ../../language/error_codes/E4105.md:5
msgid ""
"This error occurs when the type of the argument provided to a `break` "
"statement does not match the expected result type of the loop. In "
"MoonBit, loops can have result types, and when using `break` with an "
"argument, that argument's type must match the loop's result type. When an"
" argument is not provided, the loop's result type must be `Unit`."
msgstr ""

#: ../../language/error_codes/E4105.md:11
msgid "This mismatch can happen in two ways:"
msgstr ""

#: ../../language/error_codes/E4105.md:13
msgid ""
"The loop expects a value of a certain type, but `break` is called with no"
" argument"
msgstr ""

#: ../../language/error_codes/E4105.md:15
msgid ""
"The loop expects a value of type A, but `break` is called with an "
"argument of type B"
msgstr ""

#: ../../language/error_codes/E4105.md:18
msgid "For loops with result types, you must ensure that:"
msgstr ""

#: ../../language/error_codes/E4105.md:20
msgid "All `break` statements provide an argument of the correct type"
msgstr ""

#: ../../language/error_codes/E4105.md:21
msgid "The `else` branch (if present) returns a value of the correct type"
msgstr ""

#: ../../language/error_codes/E4105.md:25
msgid ""
"pub fn g(x: Int) -> Int {\n"
"  for i in 0..=x {\n"
"    if i == 42 {\n"
"      break\n"
"//    ^^^^^ Error: Current loop has result type Int, but `break` is "
"supplied\n"
"//                 with no arguments.\n"
"    }\n"
"  } else {\n"
"    0\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4105.md:41
#: ../../language/error_codes/E4108.md:45
#: ../../language/error_codes/E4110.md:35
msgid "To fix this error, you can:"
msgstr ""

#: ../../language/error_codes/E4105.md:43
msgid ""
"Add an argument to the `break` statement that matches the loop's result "
"type. For example,"
msgstr ""

#: ../../language/error_codes/E4105.md:46
msgid ""
"pub fn g(x: Int) -> Int {\n"
"  for i in 0..=x {\n"
"    if i == 42 {\n"
"      break i\n"
"    }\n"
"  } else {\n"
"    0\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4105.md:58
msgid ""
"Remove the `else` branch if you don't need to return a value from the "
"loop."
msgstr ""

#: ../../language/error_codes/E4105.md:60
msgid ""
"pub fn g(x: Int) -> Unit {\n"
"  for i in 0..=x {\n"
"    if i == 42 {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4106.md:1
msgid "E4106"
msgstr ""

#: ../../language/error_codes/E4106.md:3
msgid ""
"Unknown binder in the for-loop steps. Binders in the steps must be "
"declared in the initialization block of the for-loop."
msgstr ""

#: ../../language/error_codes/E4106.md:6
msgid ""
"This error occurs when a variable name used in the update expressions "
"(steps) of a for-loop is not declared in the initialization block of that"
" loop. In a for-loop, you can only use variables in the update "
"expressions that were previously declared when initializing the loop."
msgstr ""

#: ../../language/error_codes/E4106.md:13
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"  let mut j = 0\n"
"  for i = 0; i < x; i = i + 1, j = j + 1 {\n"
"//                             ^ --- Error: Unknown binder j in the for-"
"loop\n"
"//                                          steps. Binders in the steps "
"must be\n"
"//                                          declared in the "
"initialization\n"
"//                                          block of the for-loop.\n"
"    println(i)\n"
"    println(j)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4106.md:29
msgid "To fix this error, you can"
msgstr ""

#: ../../language/error_codes/E4106.md:31
msgid ""
"declare the variable `j` in the initialization block of the for-loop. For"
" example,"
msgstr ""

#: ../../language/error_codes/E4106.md:34
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"   for i = 0, j = 0; i < x; i = i + 1, j = j + 1 {\n"
"    println(i)\n"
"    println(j)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4106.md:43
msgid "remove the variable `j` from the update expressions. For example,"
msgstr ""

#: ../../language/error_codes/E4106.md:45
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"  let mut j = 0\n"
"  for i = 0; i < x; i = i + 1 {\n"
"    println(i)\n"
"    println(j)\n"
"    j = j + 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4107.md:1
msgid "E4107"
msgstr ""

#: ../../language/error_codes/E4107.md:3
msgid "Name is declared multiple times in this for-loop."
msgstr ""

#: ../../language/error_codes/E4107.md:5
msgid ""
"This error occurs when the same variable name is declared multiple times "
"in the initialization block of a for-loop. In a for-loop's "
"initialization, each variable must have a unique name to avoid ambiguity "
"about which value should be used."
msgstr ""

#: ../../language/error_codes/E4107.md:12
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"   for i = 0, i = 1; i < x; i = i + 1 {\n"
"//            ^ --- Error: i is declared multiple times in this for-loop\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4107.md:23
msgid ""
"To fix this error, you can change the variable name in the initialization"
" block:"
msgstr ""

#: ../../language/error_codes/E4107.md:25
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"  for i = 0, j = 1; i < x; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4108.md:1
msgid "E4108"
msgstr ""

#: ../../language/error_codes/E4108.md:3
msgid "The loop is expected to yield a value, please add an `else` branch."
msgstr ""

#: ../../language/error_codes/E4108.md:5
msgid ""
"This error occurs when the compiler infers that a for-loop is expected to"
" yield a non-Unit value based on its context (such as the function's "
"return type), but the loop lacks an `else` branch to provide that value."
msgstr ""

#: ../../language/error_codes/E4108.md:9
msgid ""
"In MoonBit, when a for-loop is used in a context where a value is "
"expected (for example, when the function returns a non-Unit type), the "
"loop must have an `else` branch that specifies what value to return when "
"the loop completes normally. This is because:"
msgstr ""

#: ../../language/error_codes/E4108.md:14
msgid "The loop body itself cannot yield a value (unlike `loop` expressions)"
msgstr ""

#: ../../language/error_codes/E4108.md:15
msgid ""
"Without an `else` branch, there's no way to determine what value should "
"be returned when the loop finishes without breaking"
msgstr ""

#: ../../language/error_codes/E4108.md:18
msgid "This commonly occurs in two situations:"
msgstr ""

#: ../../language/error_codes/E4108.md:20
msgid ""
"When the for-loop is the last expression in a function that returns a "
"non-Unit type"
msgstr ""

#: ../../language/error_codes/E4108.md:22
msgid ""
"When the for-loop's result is assigned to a variable or used in an "
"expression that expects a non-Unit value"
msgstr ""

#: ../../language/error_codes/E4108.md:27
msgid ""
"pub fn f(x: Int) -> Int {\n"
"  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {\n"
"//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: The for "
"loop is\n"
"//                                                      not expected to "
"yield a\n"
"//                                                      value, please add"
" an\n"
"//                                                      `else` branch.\n"
"  }\n"
"}\n"
"\n"
"pub fn g(x: Int) -> Int {\n"
"  for i in 0..=x {\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4108.md:47
msgid "add an `else` branch to the for-loop:"
msgstr ""

#: ../../language/error_codes/E4108.md:49
msgid ""
"pub fn f(x: Int) -> Int {\n"
"  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {\n"
"  } else {\n"
"    acc\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4108.md:58
msgid ""
"change the function's return type to `Unit` if you don't need to return a"
" value from the loop:"
msgstr ""

#: ../../language/error_codes/E4108.md:61
msgid ""
"pub fn g(x: Int) -> Unit {\n"
"  for i in 0..=x {\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4109.md:1
msgid "E4109"
msgstr ""

#: ../../language/error_codes/E4109.md:3
msgid "Return must be inside a function."
msgstr ""

#: ../../language/error_codes/E4109.md:5
msgid ""
"This error occurs when a `return` statement is used outside of a "
"function. In MoonBit, `return` statements must be inside a function body."
msgstr ""

#: ../../language/error_codes/E4109.md:10
msgid ""
"pub let x: Int = { return 42 }\n"
"//                 ^^^^^^^^^ Error: Return must be inside a function.\n"
"pub let y: Int = {\n"
"  if x == 42 {\n"
"    x + 1\n"
"  } else {\n"
"    return 0\n"
"//  ^^^^^^^^ Error: Return must be inside a function.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4109.md:25
msgid ""
"To fix this error, you can remove the return statement from the let "
"binding:"
msgstr ""

#: ../../language/error_codes/E4109.md:27
msgid ""
"pub let x: Int = 42\n"
"pub let y: Int = {\n"
"  if x == 42 {\n"
"    x + 1\n"
"  } else {\n"
"    0\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4110.md:1
msgid "E4110"
msgstr ""

#: ../../language/error_codes/E4110.md:3
msgid ""
"The loop is not expected to yield a value, please remove the argument of "
"the `break` or add an `else` branch."
msgstr ""

#: ../../language/error_codes/E4110.md:6
msgid ""
"This error occurs when using a `break` statement with an argument in a "
"loop that is not expected to yield a value. This applies to:"
msgstr ""

#: ../../language/error_codes/E4110.md:9
#, fuzzy
msgid "`while` loops"
msgstr "While 循环"

#: ../../language/error_codes/E4110.md:10
msgid "`for` loops with update expressions"
msgstr ""

#: ../../language/error_codes/E4110.md:11
#, fuzzy
msgid "`for .. in ..` iteration loops"
msgstr "`for .. in` 循环"

#: ../../language/error_codes/E4110.md:13
msgid ""
"These loop constructs do not have a mechanism to return a value from the "
"loop body. If you need to break with a value, you must either:"
msgstr ""

#: ../../language/error_codes/E4110.md:16
msgid ""
"Remove the argument from the `break` statement if you don't need to "
"return a value, or"
msgstr ""

#: ../../language/error_codes/E4110.md:18
msgid ""
"Add an `else` branch to handle the case when the loop completes normally "
"and provide a return value"
msgstr ""

#: ../../language/error_codes/E4110.md:23
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"  for i in 0..=x {\n"
"    break i\n"
"//  ^^^^^^^^ Error: The for loop is not expected to yield a value, please"
"\n"
"//                  remove the argument of the `break` or add an `else` "
"branch.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4110.md:37
msgid "Remove the argument from the `break` statement. For example,"
msgstr ""

#: ../../language/error_codes/E4110.md:39
msgid ""
"pub fn f(x: Int) -> Unit {\n"
"  for i in 0..=x {\n"
"    break\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4110.md:47
msgid ""
"Add an `else` branch to handle the case when the loop completes normally "
"and provide a return value. For example,"
msgstr ""

#: ../../language/error_codes/E4110.md:50
msgid ""
"pub fn f(x: Int) -> Int {\n"
"  for i in 0..=x {\n"
"    break i\n"
"  } else {\n"
"    42\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4111.md:1
msgid "E4111"
msgstr ""

#: ../../language/error_codes/E4111.md:3
msgid "The usage of break statement is invalid."
msgstr ""

#: ../../language/error_codes/E4111.md:5
msgid ""
"This error happens when you use a `break` statement in the "
"initialization, condition, or update statement of a loop."
msgstr ""

#: ../../language/error_codes/E4111.md:10
msgid ""
"pub fn f(x: Int, y: Int) -> Unit {\n"
"  for i = 0; i < x; i = i + 1 {\n"
"    for j = { break }; j < y; j = j + 1 {\n"
"//            ^^^^^ Error: The usage of break statement is invalid.\n"
"        println(i + j)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4111.md:23
msgid ""
"Do not write `break` statement in the initialization, condition, or "
"update statement of a loop."
msgstr ""

#: ../../language/error_codes/E4112.md:1
msgid "E4112"
msgstr ""

#: ../../language/error_codes/E4112.md:3
msgid "The usage of continue statement is invalid."
msgstr ""

#: ../../language/error_codes/E4112.md:5
msgid ""
"This error happens when you use a `continue` statement in the "
"initialization, condition, or update statement of a loop."
msgstr ""

#: ../../language/error_codes/E4112.md:10
msgid ""
"pub fn f(x: Int, y: Int) -> Unit {\n"
"  for i = 0; i < x; i = i + 1 {\n"
"    for j = { continue }; j < y; j = j + 1 {\n"
"//            ^^^^^^^^ Error: The usage of continue statement is invalid."
"\n"
"        println(i + j)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4112.md:23
msgid ""
"Do not write `continue` statement in the initialization, condition, or "
"update statement of a loop."
msgstr ""

#: ../../language/error_codes/E4113.md:1
msgid "E4113"
msgstr ""

#: ../../language/error_codes/E4113.md:3
msgid "Constructor has no field with the given name."
msgstr ""

#: ../../language/error_codes/E4113.md:5
msgid ""
"This error occurs when trying to access a field that doesn't exist in a "
"constructor pattern. In MoonBit, when pattern matching with constructors "
"that have named fields, you can only access fields that were defined in "
"the constructor's declaration."
msgstr ""

#: ../../language/error_codes/E4113.md:10
msgid "This commonly happens when:"
msgstr ""

#: ../../language/error_codes/E4113.md:12
msgid "Misspelling a field name"
msgstr ""

#: ../../language/error_codes/E4113.md:13
msgid "Trying to access a field that exists in a different constructor"
msgstr ""

#: ../../language/error_codes/E4113.md:14
msgid ""
"Trying to access a field that was removed or renamed in the type "
"definition"
msgstr ""

#: ../../language/error_codes/E4113.md:18
msgid ""
"pub enum E {\n"
"  A(a~: Int)\n"
"}\n"
"\n"
"pub fn f(x: E) -> Unit {\n"
"  match x {\n"
"    A(..) as a => {\n"
"      println(a.a)\n"
"      println(a.b)\n"
"//            ^^^ Error: Constructor A of type E has no field b.\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4113.md:36
#: ../../language/error_codes/E4114.md:22
msgid "To fix this error, you can either:"
msgstr ""

#: ../../language/error_codes/E4113.md:38
msgid "add the missing field to the constructor"
msgstr ""

#: ../../language/error_codes/E4113.md:40
msgid ""
"pub enum E {\n"
"  A(a~: Int, b~: Bool)\n"
"}\n"
"\n"
"pub fn f(x: E) -> Unit {\n"
"  match x {\n"
"    A(..) as a => {\n"
"      println(a.a)\n"
"      println(a.b)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4113.md:55
msgid "remove the incorrect field access"
msgstr ""

#: ../../language/error_codes/E4114.md:1
msgid "E4114"
msgstr ""

#: ../../language/error_codes/E4114.md:3
msgid "Only toplevel functions can have labelled arguments."
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E4114.md:5
msgid ""
"This error occurs when trying to use labelled arguments in a local "
"function or anonymous function."
msgstr ""

#: ../../language/error_codes/E4114.md:10
msgid ""
"pub fn f() -> Unit {\n"
"  fn h(x~: Int) -> Unit {\n"
"//     ^^ Error: Only toplevel functions can have labelled arguments.\n"
"    println(x)\n"
"  }\n"
"  h(x=42)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4114.md:24
msgid "Move the function to the top level of the module"
msgstr ""

#: ../../language/error_codes/E4114.md:26
msgid ""
"fn h(x~: Int) -> Unit {\n"
"  println(x)\n"
"}\n"
"\n"
"pub fn f() -> Unit {\n"
"  h(x=42)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4114.md:36
#, fuzzy
msgid "Remove the labelled arguments"
msgstr "带标签的参数"

#: ../../language/error_codes/E4114.md:38
msgid ""
"pub fn f() -> Unit {\n"
"  fn h(x: Int) -> Unit {\n"
"    println(x)\n"
"  }\n"
"  h(42)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4115.md:1
msgid "E4115"
msgstr ""

#: ../../language/error_codes/E4115.md:3
msgid "Cannot auto-fill parameter of this type."
msgstr ""

#: ../../language/error_codes/E4115.md:5
msgid ""
"MoonBit supports and auto-filling `SourceLoc` and `ArgsLoc` parameters in"
" functions. Leaving the default value of parameter of other types will "
"result in this error."
msgstr ""

#: ../../language/error_codes/E4115.md:11
msgid ""
"fn f(parameter~ : Int = _) -> Unit {\n"
"  // ^~~~~~~~~ Error: Cannot auto-fill parameter of type Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4115.md:19
msgid "Use a default value for the parameter:"
msgstr ""

#: ../../language/error_codes/E4115.md:21
msgid ""
"fn f(parameter~ : Int = 0) -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4116.md:1
msgid "E4116"
msgstr ""

#: ../../language/error_codes/E4116.md:3
msgid "Found hole _."
msgstr ""

#: ../../language/error_codes/E4116.md:5
msgid ""
"If you want to represent unfinished code, we recommend using `...` "
"instead. Using `...` allows the program to be compiled and run, while `_`"
" will cause a compilation error."
msgstr ""

#: ../../language/error_codes/E4116.md:11
msgid ""
"fn main {\n"
"  _ // Error: Found hole _\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4116.md:19
msgid "Use `...` instead:"
msgstr ""

#: ../../language/error_codes/E4116.md:21
msgid ""
"fn main {\n"
"  ... // Warning: unfinished code\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4117.md:1
msgid "E4117"
msgstr ""

#: ../../language/error_codes/E4117.md:3
msgid "Function with labelled arguments can only be applied directly."
msgstr ""

#: ../../language/error_codes/E4117.md:5
msgid ""
"This means you cannot pass a function with labelled arguments as an "
"argument to another function."
msgstr ""

#: ../../language/error_codes/E4117.md:9
msgid ""
"pub fn func_takes_closure[F](f : F) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"pub fn accumulate(acc~ : Int, value : Int) -> Int {\n"
"  acc + value\n"
"}\n"
"\n"
"fn main {\n"
"  func_takes_closure(accumulate)\n"
"  //                 ^~~~~~~~~~\n"
"  // Error: Function with labelled arguments can only be applied "
"directly.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4118.md:1
msgid "E4118"
msgstr ""

#: ../../language/error_codes/E4118.md:3
msgid "Cannot match type with map pattern."
msgstr ""

#: ../../language/error_codes/E4118.md:5
msgid ""
"You can use map patterns on custom types, as long as they have a method "
"`op_get` that returns an optional value for a given key."
msgstr ""

#: ../../language/error_codes/E4118.md:10
msgid ""
"type MyMap[K, V] Map[K, V]\n"
"\n"
"fn main {\n"
"  let map : MyMap[String, Int] = { \"a\": 1, \"b\": 2, \"c\": 3 }\n"
"  match map {\n"
"    { \"a\": a, .. } => println(\"a: \\{a}\")\n"
"  //^~~~~~~~~~~~~~\n"
"  // Error: Please implement method `op_get` for type MyMap[String, Int] "
"to match it with map pattern.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4118.md:25
msgid "Implement the `op_get` method as suggested in the error message."
msgstr ""

#: ../../language/error_codes/E4118.md:27
msgid ""
"pub fn MyMap::op_get[K: Eq + Hash, V](self : MyMap[K, V], key : K) -> V? "
"{\n"
"  self._[key]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4119.md:1
msgid "E4119"
msgstr ""

#: ../../language/error_codes/E4119.md:3
msgid ""
"This function is not a toplevel function, so it cannot have labelled "
"arguments."
msgstr "这个函数不是顶层函数，因此不能有带标签的参数。"

#: ../../language/error_codes/E4119.md:7
msgid ""
"fn main {\n"
"  fn greet(name~ : String) -> Unit {\n"
"    println(\"Hello, \\{name}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4119.md:17
msgid ""
"You can either remove the labelled argument, using positional argument "
"instead:"
msgstr ""

#: ../../language/error_codes/E4119.md:19
msgid ""
"fn main {\n"
"  fn greet(name : String) -> Unit {\n"
"    println(\"Hello, \\{name}\")\n"
"  }\n"
"  greet(\"world\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4119.md:28
#, fuzzy
msgid "Or you can make the function a toplevel function:"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4119.md:30
msgid ""
"fn greet(name~ : String) -> Unit {\n"
"  println(\"Hello, \\{name}\")\n"
"}\n"
"\n"
"fn main {\n"
"  greet(name=\"World\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4120.md:1
msgid "E4120"
msgstr ""

#: ../../language/error_codes/E4120.md:3
msgid ""
"The application might raise errors, but it's not handled. Try adding an "
"infix operator `!` or `?` to the application."
msgstr ""

#: ../../language/error_codes/E4120.md:6
msgid ""
"In MoonBit, we require programmers to explicitly annotate which functions"
" may raise errors. This is done by adding an infix operator `!` or `?` to"
" the function application. The `!` operator to re-raise the error, and "
"the `?` operator is to materialize the error to a `Result[T, E]` type."
msgstr ""

#: ../../language/error_codes/E4120.md:13
msgid ""
"fn may_raise_error(input : Int) -> Unit! {\n"
"  if input == 42 {\n"
"    return\n"
"  }\n"
"  fail!(\"failed\")\n"
"}\n"
"\n"
"fn main {\n"
"  may_raise_error(42)\n"
"  // Error: The application might raise errors of type Error, but it's "
"not handled.\n"
"  // Try adding a infix operator `!` or `?` to the application, so that "
"it looks like `...!(...)` or `...?(...)`.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4120.md:30
msgid "You can either re-raise the error:"
msgstr ""

#: ../../language/error_codes/E4120.md:32
msgid ""
"fn main {\n"
"  try {\n"
"    may_raise_error!(42)\n"
"  } catch {\n"
"    error => println(\"Error: \\{error}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4120.md:42
msgid "Or materialize the error to a `Result[T, E]` type:"
msgstr ""

#: ../../language/error_codes/E4120.md:44
msgid ""
"fn main {\n"
"  let result = may_raise_error?(42)\n"
"  println(\"Result: \\{result}\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4121.md:1
msgid "E4121"
msgstr ""

#: ../../language/error_codes/E4121.md:3
msgid "The attribute (`!`, `?`, `!!` mark) cannot be used on this application."
msgstr ""

#: ../../language/error_codes/E4121.md:5
msgid "This error occurs when:"
msgstr ""

#: ../../language/error_codes/E4121.md:7
msgid "The attribute (`!`, `?`, `!!` mark) is used on a constructor."
msgstr ""

#: ../../language/error_codes/E4121.md:8
msgid "The attribute (`!`, `?`, `!!` mark) is used on a function that does fit."
msgstr ""

#: ../../language/error_codes/E4121.md:9
msgid "`!` and `?` must be annotated on a function that may raise errors."
msgstr ""

#: ../../language/error_codes/E4121.md:10
msgid ""
"`!!` must be annotated on an async function (this will be reported as "
"[E4150](E4150.md) though)."
msgstr ""

#: ../../language/error_codes/E4121.md:15
msgid ""
"enum Err {\n"
"  IntErr(Int)\n"
"}\n"
"\n"
"fn square(x: Int) -> Int {\n"
"  x * x\n"
"}\n"
"\n"
"fn main {\n"
"  IntErr!(1) |> ignore() // Error: The attribute `!` cannot be used on "
"constructors.\n"
"  IntErr?(2) |> ignore() // Error: The attribute `?` cannot be used on "
"constructors.\n"
"  IntErr!!(3) |> ignore() // Error: The attribute `!!` cannot be used on "
"constructors.\n"
"  square!(1) |> ignore() // Error: The attribute `!` cannot be used on "
"application that does not raise errors\n"
"  square?(2) |> ignore() // Error: The attribute `?` cannot be used on "
"application that does not raise errors\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4121.md:35
msgid "Remove the attribute (`!`, `?`, `!!` mark) from the application."
msgstr ""

#: ../../language/error_codes/E4121.md:37
msgid ""
"fn main {\n"
"  IntErr(1) |> ignore()\n"
"  IntErr(2) |> ignore()\n"
"  IntErr(3) |> ignore()\n"
"  square(1) |> ignore()\n"
"  square(2) |> ignore()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4122.md:1
msgid "E4122"
msgstr ""

#: ../../language/error_codes/E4122.md:3
msgid ""
"Invalid raise operation. Can only be used inside a function with error "
"types in its signature."
msgstr ""

#: ../../language/error_codes/E4122.md:6
msgid ""
"There are 3 raise operations in MoonBit, and they must be used inside a "
"function with error types in its signature or a try block."
msgstr ""

#: ../../language/error_codes/E4122.md:9
msgid "Use the `raise` keyword to raise an error directly."
msgstr ""

#: ../../language/error_codes/E4122.md:10
msgid ""
"Re-raise an error by annotating the function application with the `!` "
"operator."
msgstr ""

#: ../../language/error_codes/E4122.md:11
msgid ""
"Explicitly handle the error using the `try ... catch! ...` block. The "
"`catch!` means re-raise all the errors that are not handled in the catch "
"block."
msgstr ""

#: ../../language/error_codes/E4122.md:16
#, fuzzy
msgid "Raise the error directly:"
msgstr "默认错误类型"

#: ../../language/error_codes/E4122.md:18
msgid ""
"type! ArithmeticError {\n"
"  DivisionByZero\n"
"}\n"
"\n"
"pub fn checked_div(a : Double, b : Double) -> Double {\n"
"  if b == 0.0 {\n"
"    raise DivisionByZero // Error: raise can only be used inside ...\n"
"  }\n"
"  return a / b\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4122.md:31
#, fuzzy
msgid "Re-raise the error:"
msgstr "默认错误类型"

#: ../../language/error_codes/E4122.md:33
msgid ""
"pub fn rethrow() -> Unit {\n"
"  fail!(\"throwing\") // Error: `!` operator will rethrow the error "
"raised in the function application, and can only be used inside ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4122.md:39
msgid "Catch all errors using `catch!`:"
msgstr ""

#: ../../language/error_codes/E4122.md:41
msgid ""
"pub fn catch_all() -> Double {\n"
"  try {\n"
"    fail!(\"Failed\") // Error: catch! will rethrow unhandled error, and "
"can only be used inside ...\n"
"  } catch! {\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4122.md:52
msgid ""
"You can either modify the surrounding function to have error types in its"
" signature:"
msgstr ""

#: ../../language/error_codes/E4122.md:55
msgid ""
"pub fn checked_div(a : Double, b : Double) -> Double!ArithmeticError {\n"
"  ...\n"
"}\n"
"\n"
"pub fn rethrow() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"pub fn catch_all() -> Double! {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4122.md:69
#, fuzzy
msgid "Or use the `try ... catch ...` block to handle the error:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error_codes/E4122.md:71
msgid ""
"pub fn checked_div(a : Double, b : Double) -> Double {\n"
"  try {\n"
"    if b == 0.0 {\n"
"      raise DivisionByZero // Error: raise can only be used inside ...\n"
"    }\n"
"    return a / b\n"
"  } catch {\n"
"    _ => {\n"
"      println(\"DivisionByZero\")\n"
"      @double.not_a_number\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4124.md:1
msgid "E4124"
msgstr ""

#: ../../language/error_codes/E4124.md:3
msgid "The constructor is ambiguous: it may come from multiple types."
msgstr ""

#: ../../language/error_codes/E4124.md:7
msgid ""
"enum A {\n"
"  A(Int)\n"
"  B(Bool)\n"
"  C(Double)\n"
"}\n"
"\n"
"enum B {\n"
"  A(Double)\n"
"  B(Int)\n"
"  C(Bool)\n"
"}\n"
"\n"
"fn main {\n"
"  let a = A(1) // Error: The constructor A is ambiguous: it may come from"
" type B or A.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4124.md:27
msgid "Add `T::` before the constructor:"
msgstr ""

#: ../../language/error_codes/E4124.md:29
msgid ""
"fn main {\n"
"  let a = A::A(1)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4125.md:1
msgid "E4125"
msgstr ""

#: ../../language/error_codes/E4125.md:3
msgid "`?` operator cannot be used with `..`."
msgstr ""

#: ../../language/error_codes/E4125.md:5
msgid ""
"`..` operator allows chaining of method call that returns `Unit`. This is"
" especially useful when the method performs side-effects, like modifying "
"the object itself, and thus returns `Unit`."
msgstr ""

#: ../../language/error_codes/E4125.md:9
msgid ""
"Using `?` materializes the error that will be raised by the method to "
"`Result[T, E]`. If one combine the `?` with `..`, the method call will "
"return `Result[T, E]` instead of `Unit`, which is not allowed by the `..`"
" operator."
msgstr ""

#: ../../language/error_codes/E4125.md:15
msgid ""
"type A Double derive(Show)\n"
"\n"
"pub fn A::check(self : A) -> Unit! {\n"
"  if self._.is_nan() {\n"
"    fail!(\"NaN\")\n"
"  }\n"
"}\n"
"\n"
"pub fn A::div(self : A, other : A) -> A {\n"
"  A(self._ / other._)\n"
"}\n"
"\n"
"fn main {\n"
"  let a : A = 1.0\n"
"  let b : A = 2.0\n"
"  println(a.div(b)..check?())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4125.md:37
msgid ""
"Use the single dot syntax to call the method, and store the result in a "
"variable."
msgstr ""

#: ../../language/error_codes/E4125.md:40
msgid ""
"fn main {\n"
"  let a : A = 1.0\n"
"  let b : A = 2.0\n"
"  println(a.div(b).check?())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4127.md:1
msgid "E4127"
msgstr ""

#: ../../language/error_codes/E4127.md:3
msgid "Type is not an error type."
msgstr "类型不是错误类型。"

#: ../../language/error_codes/E4127.md:5
msgid ""
"MoonBit only allow error types (defined with `type!` keyword) to appear "
"after the exclamation mark (`!`) in the return type of a function."
msgstr ""

#: ../../language/error_codes/E4127.md:10
msgid ""
"pub fn may_raise_error() -> Unit!String {\n"
"  //                             ^~~~~~\n"
"  // Error: Type String is not an error type.\n"
"  raise \"Failed\" // Error: Type String is not an error type.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4127.md:20
msgid "You can wrap the type you wish to raise in a error type:"
msgstr ""

#: ../../language/error_codes/E4127.md:22
msgid ""
"type! StringError String\n"
"\n"
"pub fn may_raise_error() -> Unit!StringError {\n"
"  raise StringError(\"Failed\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4128.md:1
msgid "E4128"
msgstr ""

#: ../../language/error_codes/E4128.md:3
msgid "Target of type alias must not be a type parameter."
msgstr ""

#: ../../language/error_codes/E4128.md:7
msgid ""
"typealias Wrap[T] = T // Error: Target of type alias must not be a type "
"parameter.\n"
msgstr ""

#: ../../language/error_codes/E4128.md:13
msgid "Use the type directly without using a typealias:"
msgstr ""

#: ../../language/error_codes/E4129.md:1
msgid "E4129"
msgstr ""

#: ../../language/error_codes/E4129.md:3
msgid "Found cycle in type alias."
msgstr ""

#: ../../language/error_codes/E4129.md:7
msgid ""
"typealias A = B // Found cycle A -> B -> A in type alias.\n"
"typealias B = A\n"
msgstr ""

#: ../../language/error_codes/E4129.md:14
msgid "You can break cycle using new type:"
msgstr ""

#: ../../language/error_codes/E4129.md:16
msgid ""
"type A B\n"
"typealias B = A\n"
msgstr ""

#: ../../language/error_codes/E4129.md:21
msgid "However, this is equivalent to writing"
msgstr ""

#: ../../language/error_codes/E4129.md:23
#, fuzzy
msgid "type A A\n"
msgstr "类型别名"

#: ../../language/error_codes/E4129.md:27
msgid ""
"And this might not be want to want to do. Therefore, we recommend using "
"newtypes instead of typealiases in most of times:"
msgstr ""

#: ../../language/error_codes/E4129.md:30
msgid ""
"type A B\n"
"type B A\n"
msgstr ""

#: ../../language/error_codes/E4130.md:1
msgid "E4130"
msgstr ""

#: ../../language/error_codes/E4130.md:3
msgid "`derive` is not allowed for type alias."
msgstr ""

#: ../../language/error_codes/E4130.md:5
msgid ""
"Aliases of a type can be used interchangeably with the type itself, so it"
" is not possible to derive traits for an alias without also deriving them"
" for the type it aliases. Therefore, MoonBit disallows deriving traits "
"for type aliases. Instead, one should derive the traits for the type "
"itself."
msgstr ""

#: ../../language/error_codes/E4130.md:12
msgid ""
"struct MyStruct {\n"
"  field: Int\n"
"}\n"
"\n"
"typealias StructAlias = MyStruct derive(Show) // Error: `derive` is not "
"allowed for type alias\n"
msgstr ""

#: ../../language/error_codes/E4130.md:22
msgid "Move the `derive` attribute to the type itself:"
msgstr ""

#: ../../language/error_codes/E4130.md:24
msgid ""
"struct MyStruct {\n"
"  field: Int\n"
"} derive(Show)\n"
"\n"
"typealias StructAlias = MyStruct // Remove `derive`\n"
msgstr ""

#: ../../language/error_codes/E4130.md:32
msgid ""
"If you do not have control over the type, you can create a new type that "
"wraps the original type. However, deriving traits for a new type requires"
" the wrapped type to also implement the trait, which is likely not the "
"case if you were using a type alias in the first place. In this case, you"
" will need to implement the trait manually."
msgstr ""

#: ../../language/error_codes/E4130.md:38
msgid ""
"type StructWrapper MyStruct\n"
"\n"
"impl Show for StructWrapper with output(self, logger) {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4131.md:1
msgid "E4131"
msgstr ""

#: ../../language/error_codes/E4131.md:3
msgid "The type alias is a function type, not a type constructor."
msgstr ""

#: ../../language/error_codes/E4131.md:5
msgid ""
"This error occurs when you try to define a method for a type alias. "
"Aliases of a type can be used interchangeably with the type itself, and "
"it is not possible to define method for function types. Therefore, "
"MoonBit disallows defining methods for type aliases of function types."
msgstr ""

#: ../../language/error_codes/E4131.md:12
msgid ""
"typealias FuncAlias = (Int) -> Unit\n"
"\n"
"pub fn FuncAlias::call(self : FuncAlias) -> Unit {\n"
"  //   ^~~~~~~~~\n"
"  // Error: The type alias FuncAlias is a function type, not a type "
"constructor.\n"
"  self(0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4131.md:24
msgid ""
"If you want to define a method for a function type, you should define a "
"new type that wraps the function type:"
msgstr ""

#: ../../language/error_codes/E4131.md:27
msgid ""
"type FuncWrap (Int) -> Unit\n"
"\n"
"pub fn FuncWrap::call(self : FuncWrap) -> Unit {\n"
"  (self._)(0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4132.md:1
msgid "E4132"
msgstr ""

#: ../../language/error_codes/E4132.md:3
msgid "Invalid test parameter. Only one parameter with type `@test.T` is allowed."
msgstr ""

#: ../../language/error_codes/E4132.md:7
msgid ""
"test (name : String) {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4132.md:15
msgid ""
"It is not yet possible to pass custom parameters to tests, and you have "
"to use the predefined `@test.T` type."
msgstr ""

#: ../../language/error_codes/E4132.md:18
msgid ""
"test (it : @test.T) {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4132.md:24
msgid "Or you can remove the parameter if it is not needed:"
msgstr ""

#: ../../language/error_codes/E4132.md:26
msgid ""
"test {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4133.md:1
msgid "E4133"
msgstr ""

#: ../../language/error_codes/E4133.md:3
msgid "This `for .. in` loop has incorrect number of loop variables."
msgstr ""

#: ../../language/error_codes/E4133.md:5
msgid "MoonBit supports only one or two loop variables in `for .. in` loop."
msgstr ""

#: ../../language/error_codes/E4133.md:7
msgid "One loop variable is used for the content of the iterable."
msgstr ""

#: ../../language/error_codes/E4133.md:8
msgid ""
"Two loop variables are used for the index and the content of the iterable"
" respectively."
msgstr ""

#: ../../language/error_codes/E4133.md:13
msgid ""
"fn main {\n"
"  for a, b, c in [1, 2, 3] { // Error: This `for .. in` loop has 3 loop "
"variables, but at most 2 is expected.\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4133.md:23
msgid ""
"If you want to iterate over the index and the content of the iterable, "
"you can use two loop variables:"
msgstr ""

#: ../../language/error_codes/E4133.md:26
msgid ""
"fn main {\n"
"  for i, v in [1, 2, 3] {\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4133.md:34
msgid ""
"If you want to iterate over a iterable of tuples, then you need to "
"explicitly destructure the tuple inside the loop body:"
msgstr ""

#: ../../language/error_codes/E4133.md:37
msgid ""
"fn main {\n"
"  for v in [(1, 2, 3), (4, 5, 6)] {\n"
"    let (a, b, c) = v\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4134.md:1
msgid "E4134"
msgstr ""

#: ../../language/error_codes/E4134.md:3
msgid ""
"The return type of this anonymous function is expected to include an "
"error type. Please add the error type to the return type annotation or "
"use `fn!` instead."
msgstr ""

#: ../../language/error_codes/E4134.md:8
msgid ""
"fn main {\n"
"  let draw : (Int) -> Int! = fn(luck : Int) -> Int {\n"
"    //                                         ^~~\n"
"    // Error: The return type of this anonymous function is expected "
"include an\n"
"    // error type. Please add the error type to the return type "
"annotation or\n"
"    // use `fn!` instead.\n"
"    if luck == 7 {\n"
"      return 42\n"
"    }\n"
"    fail!(\"Bad luck\") // E4122 as well\n"
"  }\n"
"  try {\n"
"    println(\"Draw: \\{draw!(7)}\")\n"
"  } catch {\n"
"    error => println(\"Error: \\{error}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4134.md:30
msgid "Add the error type to the return type annotation:"
msgstr ""

#: ../../language/error_codes/E4134.md:32
msgid ""
"fn main {\n"
"  let draw : (Int) -> Int! = fn(luck : Int) -> Int! {\n"
"    if luck == 7 {\n"
"      return 42\n"
"    }\n"
"    fail!(\"Bad luck\")\n"
"  }\n"
"  try {\n"
"    println(\"Draw: \\{draw!(7)}\")\n"
"  } catch {\n"
"    error => println(\"Error: \\{error}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4135.md:1
msgid "E4135"
msgstr ""

#: ../../language/error_codes/E4135.md:3
msgid "Inconsistent `impl` of trait: implementations have different constraints."
msgstr ""

#: ../../language/error_codes/E4135.md:5
msgid ""
"When implementing a trait for a type, all implementations must have the "
"same constraints. If the two constraints has intersection, then it would "
"be unclear which implementation to use for types that satisfy both "
"constraints."
msgstr ""

#: ../../language/error_codes/E4135.md:11
msgid ""
"trait ByteSize { byte_size() -> Int}\n"
"impl ByteSize for Byte with byte_size() { 1 }\n"
"impl ByteSize for Int with byte_size() { 4 }\n"
"\n"
"trait WordSize { word_size() -> Int }\n"
"impl WordSize for Float with word_size() { 1 }\n"
"impl WordSize for Double with word_size() { 2 }\n"
"\n"
"trait Size { size(Self) -> Int }\n"
"\n"
"impl[T : ByteSize] Size for Array[T] with size(self) {\n"
"  self.length() * T::byte_size()\n"
"}\n"
"\n"
"impl[T : WordSize] Size for Array[T] with size(self) {\n"
"//<~~~~~~~~~~~~~~~\n"
"// Error: Inconsistent `impl` of trait Size for Array at 11:1 and 15:1:\n"
"//   type parameters of implementations have different constraints\n"
"  self.length() * T::word_size() * 4\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4135.md:36
msgid ""
"One way to resolve this issue is to pick one of the implementations and "
"remove the other:"
msgstr ""

#: ../../language/error_codes/E4135.md:39
msgid ""
"// Remove the implementation for WordSize\n"
"// impl[T : WordSize] Size for Array[T] with size(self) {\n"
"//   self.length() * T::word_size() * 4\n"
"// }\n"
msgstr ""

#: ../../language/error_codes/E4135.md:46
msgid ""
"If you want to implementation for both constraints, you can create a new "
"trait that combines the constraints:"
msgstr ""

#: ../../language/error_codes/E4135.md:49
msgid ""
"trait ByteWordSize {\n"
"  byte_size() -> Int\n"
"  word_size() -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4135.md:56
msgid ""
"And manually implement the trait for all the types that satisfy the "
"constraints (`ByteSize` or `WordSize`)."
msgstr ""

#: ../../language/error_codes/E4136.md:1
msgid "E4136"
msgstr ""

#: ../../language/error_codes/E4136.md:3
msgid "This expression has type that is not a newtype."
msgstr ""

#: ../../language/error_codes/E4136.md:5
msgid ""
"In MoonBit, you can access the field of underlying struct of a newtype by"
" using the dot access operator (`.`). However, you cannot access the "
"field of a struct if it is not wrapped in a newtype."
msgstr ""

#: ../../language/error_codes/E4136.md:11
msgid ""
"struct Inner {\n"
"  value : Int\n"
"}\n"
"\n"
"type! ErrorOuter Inner\n"
"\n"
"enum EnumOuter {\n"
"  Outer(Inner)\n"
"}\n"
"\n"
"fn main {\n"
"  let outer : ErrorOuter = ErrorOuter(Inner::{ value: 1 })\n"
"  println(outer.value) // Error: This expression has type ErrorOuter, "
"which is a error type type and not a record.\n"
"  let outer : EnumOuter = Outer(Inner::{ value: 2 })\n"
"  println(outer.value) // Error: This expression has type EnumOuter, "
"which is a variant type and not a record.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4136.md:32
msgid ""
"If you want to access the field of the underlying struct, you should wrap"
" the in a newtype:"
msgstr ""

#: ../../language/error_codes/E4136.md:35
msgid ""
"type Outer Inner\n"
"\n"
"fn main {\n"
"  let outer : Outer = Inner::{ value: 1 }\n"
"  println(outer.value)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4137.md:1
msgid "E4137"
msgstr ""

#: ../../language/error_codes/E4137.md:3
msgid "Range operators are currently only supported in `for .. in` loops."
msgstr ""

#: ../../language/error_codes/E4137.md:5
msgid ""
"This means you cannot save the range operator in a variable or use it "
"later in other contexts."
msgstr ""

#: ../../language/error_codes/E4137.md:10
msgid ""
"fn main {\n"
"  let range = 0..<10 // Error: Range operators are currently only "
"supported in `for .. in` loops.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4137.md:18
msgid "One can use the `until` method to generate a range of numbers:"
msgstr ""

#: ../../language/error_codes/E4137.md:20
msgid ""
"fn main {\n"
"  let range = (0).until(10)\n"
"  for i in range {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4138.md:1
msgid "E4138"
msgstr ""

#: ../../language/error_codes/E4138.md:3
msgid ""
"Range operators only support builtin integer types, they cannot be used "
"on this type."
msgstr ""

#: ../../language/error_codes/E4138.md:8
msgid "For example, you cannot use `Float` nor `Double` with range operators."
msgstr ""

#: ../../language/error_codes/E4138.md:10
msgid ""
"fn main {\n"
"  for f in 0.0..<1.0 {\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4138.md:19
msgid ""
"Use integer types for the range operators, and genearte floats from these"
" integers instead:"
msgstr ""

#: ../../language/error_codes/E4138.md:22
msgid ""
"fn main {\n"
"  for i in 0..<10 {\n"
"    println(i.to_float())\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4138.md:30
msgid "You can also use `until` to construct a range of numbers:"
msgstr ""

#: ../../language/error_codes/E4138.md:32
msgid ""
"fn main {\n"
"  let range : Iter[Double] = (0.0).until(10.0)\n"
"  for i in range {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4139.md:1
msgid "E4139"
msgstr ""

#: ../../language/error_codes/E4139.md:3
msgid ""
"This expression has type that cannot be implicitly ignored. Use "
"`ignore(...)` or `let _ = ...` to explicitly ignore it."
msgstr ""

#: ../../language/error_codes/E4139.md:6
msgid "`Unit` type can be implicitly ignored."
msgstr ""

#: ../../language/error_codes/E4139.md:10
#, fuzzy
msgid "For example,"
msgstr "示例"

#: ../../language/error_codes/E4139.md:12
msgid ""
"fn main {\n"
"  1 + 1 // This expression has type Int, its value cannot be implicitly "
"ignored.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4139.md:18
msgid ""
"The code here show a deeper problem of the logic of the code: discarding "
"the result makes the computation useless."
msgstr ""

#: ../../language/error_codes/E4139.md:23
msgid ""
"If you do want to discard the result, use `ignore(..)` or `let _ =` to "
"explicitly discard the value."
msgstr ""

#: ../../language/error_codes/E4139.md:26
msgid ""
"fn main {\n"
"  ignore(1 + 1)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4140.md:1
msgid "E4140"
msgstr ""

#: ../../language/error_codes/E4140.md:3
msgid "Invalid C function name in extern \"C\" declaration."
msgstr ""

#: ../../language/error_codes/E4140.md:5
msgid ""
"When binding a C function with the `extern \"C\"` declaration, the "
"function name must be a valid C identifier. This means that the name must"
" satisfy the following regex:"
msgstr ""

#: ../../language/error_codes/E4140.md:9
msgid "[a-zA-Z_$][a-zA-Z0-9_$]*\n"
msgstr ""

#: ../../language/error_codes/E4140.md:15
msgid ""
"extern \"C\" fn f1() = \"1\" // Error: Invalid C function name in extern "
"\"C\" declaration\n"
msgstr ""

#: ../../language/error_codes/E4140.md:21
msgid "Change the function name to a valid C identifier:"
msgstr ""

#: ../../language/error_codes/E4140.md:23
msgid "extern \"C\" fn f1() = \"f1\"\n"
msgstr ""

#: ../../language/error_codes/E4141.md:1
msgid "E4141"
msgstr ""

#: ../../language/error_codes/E4141.md:3
msgid ""
"This form of application is invalid for the argument, because it is not "
"declared as optional."
msgstr ""

#: ../../language/error_codes/E4141.md:6
msgid ""
"This error happens when you try to forward an optional value to an "
"argument to a function. This is only allowed when the argument is "
"declared as optional argument. Even if the argument is declared as a "
"labelled argument with default value, it is not allowed to forward an "
"optional value to it."
msgstr ""

#: ../../language/error_codes/E4141.md:13
msgid ""
"fn f(opt~ : Int = 4) -> Unit {\n"
"  println(\"opt: \\{opt}\")\n"
"}\n"
"\n"
"fn main {\n"
"  let opt = Some(42)\n"
"  f(opt?) // Error: This form of application is invalid for argument "
"opt~, because it is not declared with opt? : _.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4141.md:26
msgid ""
"If you have control over the function you wish to call, you can change "
"the argument to be optional."
msgstr ""

#: ../../language/error_codes/E4141.md:29
msgid ""
"fn f(opt? : Int) -> Unit {\n"
"  let opt = match opt {\n"
"    Some(opt) => opt\n"
"    None => 4\n"
"  }\n"
"  println(\"opt: \\{opt}\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4141.md:39
msgid ""
"However, if you does not have control over the function, you can unwrap "
"the optional value before passing it to the function."
msgstr ""

#: ../../language/error_codes/E4141.md:42
msgid ""
"fn main {\n"
"  let opt = Some(42)\n"
"  let opt = match opt {\n"
"    Some(opt) => opt\n"
"    None => 4\n"
"  }\n"
"  f(opt~)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4142.md:1
msgid "E4142"
msgstr ""

#: ../../language/error_codes/E4142.md:3
msgid "This 'const' declaration is not constant."
msgstr ""

#: ../../language/error_codes/E4142.md:5 ../../language/error_codes/E4143.md:5
msgid ""
"In MoonBit, you can use `const` to declare a constant value. Only literal"
" value of immutable primitive types can be assigned to `const`."
msgstr ""

#: ../../language/error_codes/E4142.md:8
msgid "These are constant values: `1`, `\"String\"`, `1.0`, `true`, `false`, etc."
msgstr ""

#: ../../language/error_codes/E4142.md:9
msgid "These are not constant values: `[1, 2, 3]`, `1 + 1`, `fn() { 1 }`, etc."
msgstr ""

#: ../../language/error_codes/E4142.md:13
msgid ""
"const A : Int = 1 + 1 // Error: This 'const' declaration is not constant."
"\n"
msgstr ""

#: ../../language/error_codes/E4142.md:19
msgid ""
"As it is not possible to run the computation at compile time and assign "
"the result to a `const`, you can use a `let` declaration to calculate "
"these result at initialization time instead."
msgstr ""

#: ../../language/error_codes/E4142.md:23
msgid "let a : Int = 1 + 1 // These will be computed at initialization time.\n"
msgstr ""

#: ../../language/error_codes/E4142.md:27
msgid ""
"If you can compute the value yourself by using, say a calculator, you can"
" simply assign the result to the `const`."
msgstr ""

#: ../../language/error_codes/E4142.md:30
msgid "const A : Int = 2 // This is a constant value.\n"
msgstr ""

#: ../../language/error_codes/E4143.md:1
msgid "E4143"
msgstr ""

#: ../../language/error_codes/E4143.md:3
msgid "Not a valid constant type, only immutable primitive types are allowed."
msgstr ""

#: ../../language/error_codes/E4143.md:8
msgid ""
"These are valid constant types: `Int`, `String`, `Byte`, `Char`, `Float`,"
" `Bool`, etc."
msgstr ""

#: ../../language/error_codes/E4143.md:10
msgid ""
"These are not valid constant types: `Array[Int]`, `(Int) -> Int`, "
"`Ref[Int]`, etc."
msgstr ""

#: ../../language/error_codes/E4143.md:15
msgid ""
"const A : Array[Int] = [1, 2, 3] // Error: Not a valid constant type, "
"only immutable primitive types are allowed.\n"
msgstr ""

#: ../../language/error_codes/E4143.md:21
#, fuzzy
msgid "You can bind the value to a variable using `let` instead."
msgstr "不能是可变的（使用 `Ref` 代替）"

#: ../../language/error_codes/E4143.md:23
msgid "let a : Array[Int] = [1, 2, 3]\n"
msgstr ""

#: ../../language/error_codes/E4144.md:1
msgid "E4144"
msgstr ""

#: ../../language/error_codes/E4144.md:3
msgid "This is a constant, not a constructor, it cannot be applied to arguments."
msgstr ""

#: ../../language/error_codes/E4144.md:5
msgid ""
"This error occurs when you try to use a constant as a constructor in "
"pattern. One possible reason for this error is that you have a constant "
"with the same name as an external constructor, and in such case you need "
"to either use qualified name or type annotations to disambiguate."
msgstr ""

#: ../../language/error_codes/E4144.md:12
msgid ""
"pub const Value : Int = 1\n"
"\n"
"fn main {\n"
"  match { ... } {\n"
"    Value(_) => println(\"Value\")\n"
"  //^~~~~\n"
"  // Error: 'Value' is a constant, not a constructor, it cannot be "
"applied to arguments.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4144.md:26
msgid ""
"If you want to match against the constant, you can remove the playload "
"from the pattern."
msgstr ""

#: ../../language/error_codes/E4144.md:29
msgid ""
"fn main {\n"
"  match { ... } {\n"
"    Value => println(\"Value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4144.md:37
msgid ""
"Or if the constant has the same name as an external constructor, you can "
"use qualified name or type annotations to disambiguate."
msgstr ""

#: ../../language/error_codes/E4144.md:40
msgid ""
"fn main {\n"
"  match { ... } {\n"
"    @a.Value(_) => println(\"Value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4145.md:1
msgid "E4145"
msgstr ""

#: ../../language/error_codes/E4145.md:3
msgid "Cannot implement trait because it is sealed."
msgstr ""

#: ../../language/error_codes/E4145.md:5
msgid ""
"Sealed trait means the trait is not allowed to be implemented in other "
"packages. Use `pub(open)` to make the trait open to be implemented by "
"other packages."
msgstr ""

#: ../../language/error_codes/E4145.md:10
msgid "Suppose there is a package `a` in module `username/hello`:"
msgstr ""

#: ../../language/error_codes/E4145.md:20
msgid ""
"pub trait Sealed {\n"
"  to_int() -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4145.md:26
#, fuzzy
msgid "While in package `b`:"
msgstr "例如，对于一个枚举"

#: ../../language/error_codes/E4145.md:40
msgid ""
"type A Int\n"
"\n"
"impl @a.Sealed for A with to_int(self : A) -> Int { // Error: Cannot "
"implement trait '@a.Sealed' because it is readonly.\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4145.md:50
msgid ""
"You can change the visibility of the trait to `pub(open)`, so that it can"
" be implemented by other packages."
msgstr ""

#: ../../language/error_codes/E4145.md:53
msgid ""
"pub(open) trait Sealed {\n"
"  to_int() -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4146.md:1
msgid "E4146"
msgstr ""

#: ../../language/error_codes/E4146.md:3
msgid "Type is not supported by range pattern."
msgstr ""

#: ../../language/error_codes/E4146.md:5
msgid ""
"MoonBit only support range pattern for integer types. This error occurs "
"when you try to use a type that is not an integer in a range pattern."
msgstr ""

#: ../../language/error_codes/E4146.md:10
msgid ""
"fn main {\n"
"  let value = 1.0\n"
"  match value {\n"
"    _..<0.0 => println(\"negative\") // Error: Type Double is not "
"supported by range pattern.\n"
"    _ => println(\"zero or positive\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4146.md:22
msgid ""
"For type that is not an integer but implements the `Compare` trait, you "
"can use multiple `if-else` expression to achieve the same effect."
msgstr ""

#: ../../language/error_codes/E4146.md:25
msgid ""
"fn main {\n"
"  let value = 1.0\n"
"  if value < 0.0 {\n"
"    println(\"negative\")\n"
"  } else {\n"
"    println(\"zero or positive\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4147.md:1
msgid "E4147"
msgstr ""

#: ../../language/error_codes/E4147.md:3
msgid "Range pattern bounds must satisfy the ordering constraints:"
msgstr ""

#: ../../language/error_codes/E4147.md
#, fuzzy
msgid "Pattern"
msgstr "Map 模式"

#: ../../language/error_codes/E4147.md
#, fuzzy
msgid "Constraint"
msgstr "常量"

#: ../../language/error_codes/E4147.md
msgid "`a..=b`"
msgstr ""

#: ../../language/error_codes/E4147.md
msgid "`a <= b`"
msgstr ""

#: ../../language/error_codes/E4147.md
msgid "`a..<b`"
msgstr ""

#: ../../language/error_codes/E4147.md
msgid "`a < b`"
msgstr ""

#: ../../language/error_codes/E4147.md:12
msgid ""
"fn main {\n"
"  let value = 1\n"
"  match value {\n"
"    0..<-10 => println(\"0..<-10\")\n"
"  //^~~~~~~\n"
"  // Error: Range pattern `a..<b` must satisfy `a < b`.\n"
"    _ => println(\"_\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4147.md:26
msgid ""
"Make sure the range pattern bounds satisfy the ordering constraints. This"
" can be usually achieved by swapping the bounds."
msgstr ""

#: ../../language/error_codes/E4147.md:29
msgid ""
"fn main {\n"
"  let value = 1\n"
"  match value {\n"
"    -10..<0 => println(\"0..=10\")\n"
"    _ => println(\"_\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4148.md:1
msgid "E4148"
msgstr ""

#: ../../language/error_codes/E4148.md:3
#, fuzzy
msgid "The loop label is undeclared."
msgstr "可选参数未被提供"

#: ../../language/error_codes/E4148.md:5
msgid ""
"MoonBit allows programmers to continue to or break from a loop with a "
"label. The label must be declared at the beginning of one of the loops "
"the `continue` or `break` statement is in."
msgstr ""

#: ../../language/error_codes/E4148.md:11
msgid ""
"fn read() -> @bytes.View {\n"
"  ...\n"
"}\n"
"\n"
"fn main {\n"
"  loop read() {\n"
"    [] => break\n"
"    _ => continue read~ read()\n"
"    //            ^~~~~\n"
"    // Error: The label read is undeclared.\n"
"  }\n"
"  // Defining the label here does not work since continue cannot jump to "
"a different loop.\n"
"  read~: loop read() {\n"
"    [] => break\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4148.md:32
msgid ""
"Make sure the label is declared at the beginning of the loop the "
"`continue` or `break` statement is in."
msgstr ""

#: ../../language/error_codes/E4148.md:35
msgid ""
"fn main {\n"
"  read~: loop read() {\n"
"    [] => break\n"
"    _ => continue read~ read()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4149.md:1
msgid "E4149"
msgstr ""

#: ../../language/error_codes/E4149.md:3
msgid "Cannot call async function in this context."
msgstr ""

#: ../../language/error_codes/E4149.md:5
#, fuzzy
msgid "Async functions can only be called in async functions."
msgstr "异步函数可以用 `async` 关键字声明："

#: ../../language/error_codes/E4149.md:9
msgid ""
"async fn f() -> Int {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Int {\n"
"  f!!()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4149.md:21
#, fuzzy
msgid "You can change the containing function to an async function:"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4149.md:23
#: ../../language/error_codes/E4150.md:25
msgid ""
"async fn g() -> Int {\n"
"  f!!()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4150.md:1
msgid "E4150"
msgstr ""

#: ../../language/error_codes/E4150.md:3
#, fuzzy
msgid "Async function call must be marked with `!!`."
msgstr "调用异步函数时，必须用 `!!` 操作符来标记这是一次异步函数调用："

#: ../../language/error_codes/E4150.md:5
msgid ""
"MoonBit require all async function calls to be marked with `!!`, as a way"
" to to inform the programmer that the function call is async and the "
"control flow will be suspended here."
msgstr ""

#: ../../language/error_codes/E4150.md:11
msgid ""
"async fn f() -> Int {\n"
"  ...\n"
"}\n"
"\n"
"async fn g() -> Int {\n"
"  f() // Error: async function call must be marked with `!!`\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4150.md:23
#, fuzzy
msgid "Mark the async function call with `!!`:"
msgstr "调用异步函数时，必须用 `!!` 操作符来标记这是一次异步函数调用："

#: ../../language/error_codes/index.md:1
msgid "Error Codes Index"
msgstr "错误代码索引"

#: ../../language/error_codes/index.md:4
msgid "The error codes index is currently WIP."
msgstr "该错误代码索引目前正在编写中"

#: ../../language/error_codes/index.md:6
msgid ""
"Many of the entries contains only verify brief description of the error "
"code. You are more than welcomed to expand any of the entries by "
"submitting a PR to [moonbitlang/moonbit-"
"docs](https://github.com/moonbitlang/moonbit-docs)."
msgstr ""
"许多错误条目只有非常简单的描述。我们非常欢迎您通过向 [moonbitlang/moonbit-"
"docs](https://github.com/moonbitlang/moonbit-docs) 提交 Pull Request "
"的方式来扩充条目内容。"

#: ../../language/error_codes/index.md:11
msgid "This page lists all error codes produced by the MoonBit compiler."
msgstr "此页面列出了所有 MoonBit 编译器会报告的错误"

#: ../../language/ffi-and-wasm-host.md:1
msgid "Foreign Function Interface(FFI)"
msgstr "外部函数接口(FFI)"

#: ../../language/ffi-and-wasm-host.md:3
msgid ""
"What we've introduced is about describing pure computation. In reality, "
"you'll need to interact with the real world. However, the \"world\" is "
"different for each backend (C, JS, Wasm, WasmGC) and is sometimes based "
"on runtime ([Wasmtime](https://wasmtime.dev/), Deno, Browser, etc.)."
msgstr "我们已经介绍的是纯粹的计算。在现实中，需要与真实世界互动。然而，对于每个后端（C、JS、Wasm、WasmGC），“世界”是不同的，并且基于运行时（[Wasmtime](https://wasmtime.dev/)、Deno、浏览器等）。"

#: ../../language/ffi-and-wasm-host.md:7
msgid ""
"You can use foreign function in MoonBit through FFI to interact with the "
"hosting runtime when embedded inside the browser or command line "
"applications through [Wasmtime](https://wasmtime.dev/) or similar "
"projects."
msgstr ""
"当嵌入到浏览器，或通过 [Wasmtime](https://wasmtime.dev/) "
"嵌入到命令行应用程序中时，可以通过外部函数接口(FFI)在 MoonBit 中使用外部函数与宿主运行时进行交互。"

#: ../../language/ffi-and-wasm-host.md:9
msgid "Init function"
msgstr "`init` 函数"

#: ../../language/ffi-and-wasm-host.md:11
msgid ""
"For WebAssembly backend, it is compiled as [start "
"function](https://webassembly.github.io/spec/core/syntax/modules.html"
"#start-function), meaning that it will be executed **before** the "
"instance is available, and the FFIs that relies on the instance's "
"exportations can not be used at this stage; for JavaScript backend, it "
"means that it will be executed during the importation stage."
msgstr ""
"对于 WebAssembly 后端，它被编译为 [start "
"函数](https://webassembly.github.io/spec/core/syntax/modules.html#start-"
"function)，这意味着它将在实例可用之前执行，并且依赖于实例的导出的外部函数接口(FFI)在这个阶段不能使用；对于 JavaScript "
"后端，这意味着它将在导入阶段执行。"

#: ../../language/ffi-and-wasm-host.md:14
msgid "Declare Foreign Reference"
msgstr "声明外部引用"

#: ../../language/ffi-and-wasm-host.md:16
msgid "You can declare a foreign reference type like this:"
msgstr "您可以像这样声明一个外部引用类型："

#: ../../language/ffi-and-wasm-host.md:18
msgid "extern type Canvas_ctx\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:22
msgid ""
"This will be a type that represents a reference to a foreign object, a "
"`CanvasRenderingContext2D` object held by the hosting JavaScript runtime "
"in this example."
msgstr ""
"这将是一个表示对外部对象的引用的类型，在这个例子中，它是由宿主 JavaScript 运行时持有的 "
"`CanvasRenderingContext2D` 对象。"

#: ../../language/ffi-and-wasm-host.md:24
msgid "Declare Foreign Function"
msgstr "声明外部函数"

#: ../../language/ffi-and-wasm-host.md:26
msgid ""
"You can either import a function with module name and function name or "
"writing an inline function."
msgstr "您可以通过模块名和函数名导入一个函数，也可以编写一个内联函数。"

#: ../../language/ffi-and-wasm-host.md:28
msgid "Import function"
msgstr "导入函数"

#: ../../language/ffi-and-wasm-host.md:30
msgid "You can declare a foreign function like this:"
msgstr "您可以像这样声明一个外部函数："

#: ../../language/ffi-and-wasm-host.md:32
msgid "fn cos(d : Double) -> Double = \"Math\" \"cos\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:36
msgid ""
"It's similar to a normal function definition except that the function "
"body is replaced with two strings."
msgstr "它与普通函数定义类似，只是函数体被替换为两个字符串。"

#: ../../language/ffi-and-wasm-host.md:38
msgid ""
"For Wasm(GC) backend, these two strings are used to identify the specific"
" function from a Wasm import object, the first string is the module name,"
" and the second string is the function name."
msgstr "对于 Wasm(GC) 后端，这两个字符串用于从 Wasm 导入对象中识别特定函数，第一个字符串是模块名，第二个字符串是函数名。"

#: ../../language/ffi-and-wasm-host.md:40
msgid ""
"For JS backend, these two strings are used to call a static function in "
"the global namespace. The example above becomes similar to `const cos = "
"(d) => Math.cos(d)`."
msgstr "对于 JS 后端，这两个字符串用于调用全局命名空间中的静态函数。上面的例子类似于 `const cos = (d) => Math.cos(d)`。"

#: ../../language/ffi-and-wasm-host.md:42
msgid "Inline function"
msgstr "内联函数"

#: ../../language/ffi-and-wasm-host.md:44
msgid ""
"You can also declare inline functions where the function body is replaced"
" with one string."
msgstr "您还可以声明内联函数，其中函数体被替换为一个字符串。"

#: ../../language/ffi-and-wasm-host.md:46
msgid ""
"For Wasm(GC) backend, you may declare it as a Wasm function without name "
"(which will be generated afterwards):"
msgstr "对于 Wasm(GC) 后端，您可以将其声明为一个没有名称的 Wasm 函数（稍后将生成名称）："

#: ../../language/ffi-and-wasm-host.md:48
msgid ""
"extern \"wasm\" fn abs(d : Double) -> Double =\n"
"  #|(func (param f64) (result f64))\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:53
msgid "and for JS backend, you may declare it as a lambda expression:"
msgstr "对于 JS 后端，您可以将其声明为一个 lambda 表达式："

#: ../../language/ffi-and-wasm-host.md:55
msgid ""
"extern \"js\" fn abs(d : Double) -> Double =\n"
"  #|(d) => Math.abs(d)\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:60
msgid "After declaration, you can use foreign functions like regular functions."
msgstr "声明后，您可以像普通函数一样使用外部函数。"

#: ../../language/ffi-and-wasm-host.md:62
msgid ""
"For multi-backend project, you may implement backend specific code in the"
" files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`. Check out"
" [link options](</toolchain/moon/package.md#link-options>) for details."
msgstr ""
"对于多后端项目，您可以在以 `.wasm.mbt` `.wasm-gc.mbt` 和 `.js.mbt` "
"结尾的文件中实现特定于后端的代码。有关详细信息，请查看[链接选项](</toolchain/moon/package.md#link-"
"options>)。"

#: ../../language/ffi-and-wasm-host.md:64
msgid ""
"You may also declare a foreign function that will be invoked upon a "
"foreign object by using the foreign reference type like this:"
msgstr "您还可以声明一个外部函数，该函数将通过使用外部引用类型在外部对象上调用，如下所示："

#: ../../language/ffi-and-wasm-host.md:66
msgid "fn begin_path(self: Canvas_ctx) = \"canvas\" \"begin_path\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:70
msgid ""
"and apply it to a previously owned reference normally such as "
"`context.begin_path()`."
msgstr "然后将其应用于以前拥有的引用，例如 `context.begin_path()`。"

#: ../../language/ffi-and-wasm-host.md:72
msgid "Export functions"
msgstr "导出函数"

#: ../../language/ffi-and-wasm-host.md:74
msgid ""
"Functions that are not methods nor polymorphic functions can be exported "
"if they are public and if the link configuration appears in the "
"`moon.pkg.json` of the package:"
msgstr "如果函数既不是方法也不是多态函数，则可以导出它们，前提是它们是公开的，并且链接配置出现在包的 `moon.pkg.json` 中："

#: ../../language/ffi-and-wasm-host.md:76
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"js\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ],\n"
"      \"format\": \"esm\"\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:93
msgid ""
"Each backend has a separate definition. For JS backend, a `format` option"
" is used to specify whether the generated JavaScript file should be "
"released as an ES Module (`esm`), a CommonJS module (`cjs`), or an "
"immediately invoked function expression (`iife`)."
msgstr ""
"每个后端都有单独的定义。对于 JS 后端，`format` 选项用于指定生成的 JavaScript 文件是作为 ES 模块 "
"(`esm`)、CommonJS 模块 (`cjs`) 还是立即调用的函数表达式 (`iife`) 发布。"

#: ../../language/ffi-and-wasm-host.md:95
msgid ""
"The example above will export function `add` and `fib`, and the function "
"`fib` will be exported with the name of `test`."
msgstr "上面的例子将导出函数 `add` 和 `fib`，函数 `fib` 将以 `test` 的名称导出。"

#: ../../language/ffi-and-wasm-host.md:97
msgid "Use compiled Wasm"
msgstr "使用编译后的 Wasm"

#: ../../language/ffi-and-wasm-host.md:99
msgid ""
"To use the compiled Wasm, you need to initialize the Wasm module with the"
" host functions so as to meet the needs of the foreign functions, and "
"then use the exported functions provided by the Wasm module."
msgstr "要使用编译后的 Wasm，您需要使用宿主函数初始化 Wasm 模块，以满足外部函数的需求，然后使用 Wasm 模块提供的导出函数。"

#: ../../language/ffi-and-wasm-host.md:101
msgid "Provide host functions"
msgstr "提供宿主函数"

#: ../../language/ffi-and-wasm-host.md:103
msgid ""
"To use the compiled Wasm, you must provide **All** declared foreign "
"functions in Wasm import object."
msgstr "要使用编译后的 Wasm，您必须在 Wasm 导入对象中提供**所有**声明的外部函数。"

#: ../../language/ffi-and-wasm-host.md:105
msgid "For example, to use wasm compiled from above code snippet in JavaScript:"
msgstr "例如，在 JavaScript 中使用上面代码片段编译的 wasm："

#: ../../language/ffi-and-wasm-host.md:107
msgid ""
"WebAssembly.instantiateStreaming(fetch(\"xxx.wasm\"), {\n"
"  Math: {\n"
"    cos: (d) => Math.cos(d),\n"
"  },\n"
"});\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:115
msgid ""
"Check out the documentation such as [MDN](https://developer.mozilla.org"
"/en-US/docs/WebAssembly) or the manual of runtime that you're using to "
"embed the Wasm."
msgstr ""
"查看文档，例如 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) "
"或您用于嵌入 Wasm 的运行时的手册。"

#: ../../language/ffi-and-wasm-host.md:118
msgid ""
"In order to passing closure to host, we need to add `make_closure` into "
"`moonbit:ffi`. e.g. "
"[onclick](https://html.spec.whatwg.org/multipage/webappapis.html#handler-"
"onclick)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:121
msgid ""
"extern type MouseEvent\n"
"extern type Window\n"
"fn onclick(self : Window, e : (MouseEvent) -> Unit) = \"Window\" "
"\"onclick\"\n"
"pub fn print_hello(self : Window) -> Unit {\n"
"  self.onclick(fn (_){ println(\"hello\")})\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:130
msgid ""
"let importObject = { \n"
"  Window : {\n"
"    onclick : (w : Window, f : (e : MouseEvent) => void ) => w.onclick = "
"f \n"
"  },\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"  \"moonbit:ffi\": {\n"
"    make_closure: (funcref, closure) => funcref.bind(null, closure)\n"
"  } \n"
"}\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    obj.instance.exports[\"print_hello\"](window);\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:149
msgid "Example: Smiling face"
msgstr "示例：笑脸"

#: ../../language/ffi-and-wasm-host.md:151
msgid ""
"Let's walk through a full example to draw a smiling face using Canvas API"
" in MoonBit. Suppose you created a new project with `moon new draw`"
msgstr ""
"让我们通过一个完整的示例来使用 Canvas API 在 MoonBit 中绘制一个笑脸。假设您使用 `moon new draw` "
"创建了一个新项目"

#: ../../language/ffi-and-wasm-host.md:153
msgid ""
"// We first declare a type representing the context of canvas\n"
"extern type Canvas_ctx\n"
"\n"
"// We then declare the foreign function interfaces\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// We then apply these functions to define the drawing function upon the "
"context\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// We also demonstrate the `println` functionality here\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"
msgstr ""
"// 我们首先定义一个表示画布的上下文的类型\n"
"extern type Canvas_ctx\n"
"\n"
"// 然后定义外部函数接口\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// 然后应用这些函数来定义在画布上绘制的函数\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// 我们也在此展示 `println` 功能\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"

#: ../../language/ffi-and-wasm-host.md:186
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:199
msgid ""
"Build the project using `moon build`. We recommend using Wasm with GC "
"integration whenever possible (which is the default). If the environment "
"does not support the GC feature, use the `--target wasm` option instead."
msgstr ""
"使用 `moon build` 构建项目。我们建议尽可能使用 Wasm GC（这是默认值）。如果环境不支持 GC 特性，请改用 `--target"
" wasm` 选项。"

#: ../../language/ffi-and-wasm-host.md:201
msgid "We now can use it from JavaScript."
msgstr "现在我们可以从 JavaScript 中使用它。"

#: ../../language/ffi-and-wasm-host.md:203
msgid ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // import object for defining the FFI\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // Pass the JS object as parameter to draw the smiling face\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // Display the value of PI\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"
msgstr ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // 用于定义 FFI 的导入对象\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // 将 JS 对象作为参数传递以绘制笑脸\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // 显示 PI 的值\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"

#: ../../language/ffi-and-wasm-host.md:230
msgid ""
"For import object, we need to provide all the FFI used in the previously "
"defined program: the canvas rendering API, the math API and finally, an "
"API for printing to the console used by the `println` or `print` "
"function."
msgstr ""
"对于导入对象，我们需要提供先前定义的程序中使用的所有 FFI：canvas 渲染 API、math API 和最后，用于 `println` 或 "
"`print` 函数的打印到控制台的 API。"

#: ../../language/ffi-and-wasm-host.md:232
msgid ""
"As of the canvas rendering API and the math API, we can use the following"
" code to convert the methods of objects into function calls that accept "
"the object as the first parameter, and convert the constant properties of"
" objects into functions that returns the value:"
msgstr ""
"至于 canvas 渲染 API 和 math "
"API，我们可以使用以下代码将对象的方法转换为接受对象作为第一个参数的函数调用，并将对象的常量属性转换为返回值的函数："

#: ../../language/ffi-and-wasm-host.md:234
msgid ""
"function prototype_to_ffi(prototype) {\n"
"  return Object.fromEntries(\n"
"    Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"      .filter(([_key, value]) => value.value)\n"
"      .map(([key, value]) => {\n"
"        if (typeof value.value == 'function')\n"
"          return [key, Function.prototype.call.bind(value.value)]\n"
"        // TODO: it is also possible to convert properties into getters "
"and setters\n"
"        else\n"
"          return [key, () => value.value]\n"
"      })\n"
"  );\n"
"}\n"
"\n"
"const importObject = {\n"
"  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"  math: prototype_to_ffi(Math),\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:256
msgid ""
"As of the printing service, we can provide the following closure so that "
"it buffers the bytes of string until it needs to be logged to the "
"console:"
msgstr "至于打印服务，我们可以提供以下闭包，以便它缓冲字符串的字节，直到需要将其记录到控制台："

#: ../../language/ffi-and-wasm-host.md:258
msgid ""
"const [log, flush] = (() => {\n"
"  var buffer = [];\n"
"  function flush() {\n"
"    if (buffer.length > 0) {\n"
"      console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"      buffer = [];\n"
"    }\n"
"  }\n"
"  function log(ch) {\n"
"    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"    else { buffer.push(ch); }\n"
"  }\n"
"  return [log, flush]\n"
"})();\n"
"\n"
"const importObject = {\n"
"  // ...\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"}\n"
"\n"
"// ...\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    // ...\n"
"    flush()\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:291
msgid "Now, we put them together, so this is our final complete `index.html`:"
msgstr "现在，我们将它们放在一起，这是我们最终的完整 `index.html`："

#: ../../language/ffi-and-wasm-host.md:293
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"\n"
"<head></head>\n"
"\n"
"<body>\n"
"  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  <script>\n"
"    function prototype_to_ffi(prototype) {\n"
"      return Object.fromEntries(\n"
"        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"          .filter(([_key, value]) => value.value)\n"
"          .map(([key, value]) => {\n"
"            if (typeof value.value == 'function')\n"
"              return [key, Function.prototype.call.bind(value.value)]\n"
"            else\n"
"              return [key, () => value.value]\n"
"          })\n"
"      );\n"
"    }\n"
"\n"
"    const [log, flush] = (() => {\n"
"      var buffer = [];\n"
"      function flush() {\n"
"        if (buffer.length > 0) {\n"
"          console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"          buffer = [];\n"
"        }\n"
"      }\n"
"      function log(ch) {\n"
"        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"        else { buffer.push(ch); }\n"
"      }\n"
"      return [log, flush]\n"
"    })();\n"
"\n"
"\n"
"\n"
"    const importObject = {\n"
"      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"      math: prototype_to_ffi(Math),\n"
"      spectest: {\n"
"        print_char: log\n"
"      },\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"          flush()\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</body>\n"
"\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:358
msgid ""
"Make sure that `draw.wasm` and `index.html` are in the same folder, then "
"start a http server at this folder. For example, using Python:"
msgstr "确保 `draw.wasm` 和 `index.html` 在同一个文件夹中，然后在此文件夹中启动一个 http 服务器。例如，使用 Python："

#: ../../language/ffi-and-wasm-host.md:360
msgid "python3 -m http.server 8080\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:364
msgid ""
"Goto [http://localhost:8080](http://localhost:8080) in your browser, "
"there should be a smile face on the screen and an output on the console:"
msgstr ""
"在浏览器中转到 "
"[http://localhost:8080](http://localhost:8080)，屏幕上应该有一个笑脸，控制台上应该有一个输出："

#: ../../language/ffi-and-wasm-host.md:366
msgid ""
"![A smile face webpage with browser devtools "
"open](../imgs/smile_face_with_log.png)"
msgstr "![带有笑脸的浏览器开发工具的网页](../imgs/smile_face_with_log.png)"

#: ../../language/ffi-and-wasm-host.md:366
msgid "A smile face webpage with browser devtools open"
msgstr "带有笑脸的浏览器开发工具的网页"

#: ../../language/fundamentals.md:1
msgid "Fundamentals"
msgstr "基础"

#: ../../language/fundamentals.md:3
msgid "Built-in Data Structures"
msgstr "内置数据结构"

#: ../../language/fundamentals.md:5
msgid "Boolean"
msgstr "布尔值"

#: ../../language/fundamentals.md:7
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr "MoonBit 有一个内置的布尔类型，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。"

#: ../../language/fundamentals.md:9
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/fundamentals.md:16
msgid "Number"
msgstr "数字"

#: ../../language/fundamentals.md:18
msgid "MoonBit have integer type and floating point type:"
msgstr "MoonBit 有整数类型和浮点类型："

#: ../../language/fundamentals.md:9
msgid "type"
msgstr "类型"

#: ../../language/fundamentals.md:9 ../../language/fundamentals.md:117
msgid "description"
msgstr "描述"

#: ../../language/fundamentals.md:9
msgid "example"
msgstr "示例"

#: ../../language/fundamentals.md:9
msgid "`Int16`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "16-bit signed integer"
msgstr "16 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`(42 : Int16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit signed integer"
msgstr "32 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`42`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`1000L`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt16`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "16-bit unsigned integer"
msgstr "16 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`(14 : UInt16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit unsigned integer"
msgstr "32 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14U`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14UL`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Double`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit floating point, defined by IEEE754"
msgstr "64 位浮点数，由 IEEE754 定义"

#: ../../language/fundamentals.md:9
msgid "`3.14`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Float`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit floating point"
msgstr "32 位浮点数"

#: ../../language/fundamentals.md:9
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "represents numeric values larger than other types"
msgstr "表示比其他类型更大的数值"

#: ../../language/fundamentals.md:9
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/fundamentals.md:32
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal,"
" and hexadecimal numbers."
msgstr "MoonBit 还支持数字字面量，包括十进制、二进制、八进制和十六进制数字。"

#: ../../language/fundamentals.md:34
msgid ""
"To improve readability, you may place underscores in the middle of "
"numeric literals such as `1_000_000`. Note that underscores can be placed"
" anywhere within a number, not just every three digits."
msgstr "为了提高可读性，您可以在数字字面量中间放置下划线，例如 `1_000_000`。请注意，下划线可以放在数字中的任何位置，而不仅仅是每三位数字。"

#: ../../language/fundamentals.md:36
msgid "Decimal numbers can have underscore between the numbers."
msgstr "十进制数之间可以有下划线。"

#: ../../language/fundamentals.md:38
msgid ""
"By default, an int literal is signed 32-bit number. For unsigned numbers,"
" a postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed."
msgstr "默认情况下，整数字面量是有符号的 32 位数字。对于无符号数字，需要后缀 `U`；对于 64 位数字，需要后缀 `L`。"

#: ../../language/fundamentals.md:40
msgid ""
"let a = 1234\n"
"let b : Int = 1_000_000 + a\n"
"let unsigned_num       : UInt   = 4_294_967_295U\n"
"let large_num          : Int64  = 9_223_372_036_854_775_807L\n"
"let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/fundamentals.md:47
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr "二进制数有一个前导零，后跟字母 \"B\"，即 `0b`/`0B`。请注意，`0b`/`0B` 后的数字必须是 `0` 或 `1`。"

#: ../../language/fundamentals.md:50
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/fundamentals.md:57
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from"
" `0` through `7`:"
msgstr "八进制数有一个前导零，后跟字母 \"O\"，即 `0o`/`0O`。请注意，`0o`/`0O` 后的数字必须在 `0` 到 `7` 的范围内："

#: ../../language/fundamentals.md:60
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/fundamentals.md:67
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""
"十六进制数有一个前导零，后跟字母 \"X\"，即 `0x`/`0X`。请注意，`0x`/`0X` 后的数字必须在 "
"`0123456789ABCDEF` 范围内。"

#: ../../language/fundamentals.md:70
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA_B_C\n"
msgstr ""

#: ../../language/fundamentals.md:77
msgid ""
"A floating-point number literal is 64-bit floating-point number. To "
"define a float, type annotation is needed."
msgstr "浮点数字面量是 64 位浮点数。要定义一个浮点数，需要类型注释。"

#: ../../language/fundamentals.md:79
msgid ""
"let double = 3.14 // Double\n"
"let float : Float = 3.14\n"
"let float2 = (3.14 : Float)\n"
msgstr ""

#: ../../language/fundamentals.md:86
msgid ""
"A 64-bit floating-point number can also be defined using hexadecimal "
"format:"
msgstr "64 位浮点数也可以使用十六进制格式定义："

#: ../../language/fundamentals.md:88
msgid "let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9\n"
msgstr ""

#: ../../language/fundamentals.md:95
msgid "Overloaded literal"
msgstr "重载字面量"

#: ../../language/fundamentals.md:97
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"literal, and there is no need to specify the type of number via letter "
"postfix:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型："

#: ../../language/fundamentals.md:99
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/fundamentals.md:106
msgid "String"
msgstr "字符串"

#: ../../language/fundamentals.md:108
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes"
" to create a string, or use `#|` to write a multi-line string."
msgstr "`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。"

#: ../../language/fundamentals.md:110
msgid ""
"let a = \"兔rabbit\"\n"
"println(a[0])\n"
"println(a[1])\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/fundamentals.md:117
msgid ""
"兔\n"
"r\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/fundamentals.md:121
msgid ""
"In double quotes string, a backslash followed by certain special "
"characters forms an escape sequence:"
msgstr "在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列："

#: ../../language/fundamentals.md:117
msgid "escape sequences"
msgstr "转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\n`,`\\r`,`\\t`,`\\b`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr "换行，回车，水平制表符，退格"

#: ../../language/fundamentals.md:117
msgid "`\\\\`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Backslash"
msgstr "反斜杠"

#: ../../language/fundamentals.md:117
msgid "`\\x41`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Hexadecimal escape sequence"
msgstr "十六进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\o102`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Octal escape sequence"
msgstr "八进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\u5154`,`\\u{1F600}`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Unicode escape sequence"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:131
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the "
"process of constructing dynamic strings by directly embedding variable "
"values into the text. Variables used for string interpolation must "
"support the `to_string` method."
msgstr ""
"MoonBit "
"支持字符串插值。它允许您在插值字符串中替换变量。此功能通过直接将变量值嵌入文本来简化构建动态字符串的过程。用于字符串插值的变量必须支持 "
"`to_string` 方法。"

#: ../../language/fundamentals.md:133
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/fundamentals.md:140
msgid ""
"Multi-line strings do not support interpolation by default, but you can "
"enable interpolation for a specific line by changing the leading `#|` to "
"`$|`:"
msgstr "多行字符串默认不支持插值，但您可以通过将前导 `#|` 更改为 `$|` 来为特定行启用插值："

#: ../../language/fundamentals.md:142
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/fundamentals.md:149
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/fundamentals.md:153
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals.md:155
msgid "`Char` represents a Unicode code point."
msgstr "`Char` 表示一个 Unicode 码点。"

#: ../../language/fundamentals.md:157
msgid ""
"let a : Char = 'A'\n"
"let b = '\\x41'\n"
"let c = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/fundamentals.md:164
msgid "Byte(s)"
msgstr "字节"

#: ../../language/fundamentals.md:166
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape enclosed in single quotes `'`, and preceded by the character `b`. "
"Byte literals are of type `Byte`. For example:"
msgstr ""
"MoonBit 中的字节字面量是一个 ASCII 字符或一个转义字符，用单引号 `'` 括起来，并在前面加上字符 `b`。字节字面量的类型是 "
"`Byte`。例如："

#: ../../language/fundamentals.md:168
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:176
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/fundamentals.md:180
msgid ""
"A `Bytes` is an immutable sequence of bytes. Similar to byte, bytes "
"literals have the form of `b\"...\"`. For example:"
msgstr "`Bytes` 是不可修改的字节序列。与字节类似，字节序列字面量的形式是 `b\"...\"`。例如："

#: ../../language/fundamentals.md:182
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq!(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:188
msgid ""
"A `@buffer.T` is a constructor for bytes that comes with methods for "
"writing different kinds of data. For example:"
msgstr "`@buffer.T` 是字节序列的构造器，它带有用于写入不同类型数据的方法。例如："

#: ../../language/fundamentals.md:190
msgid ""
"test \"buffer 1\" {\n"
"  let buf : @buffer.T = @buffer.new()\n"
"  buf.write_bytes(b\"Hello\")\n"
"  buf.write_byte(b'!')\n"
"  assert_eq!(buf.contents(), b\"Hello!\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:196
msgid "Tuple"
msgstr "元组"

#: ../../language/fundamentals.md:198
msgid ""
"A tuple is a collection of finite values constructed using round brackets"
" `()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. "
"Here's an example:"
msgstr ""
"元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要；例如，`(1,true)` 和 `(true,1)`"
" 有不同的类型。以下是一个示例："

#: ../../language/fundamentals.md:200
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:208
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/fundamentals.md:212
msgid "Tuples can be accessed via pattern matching or index:"
msgstr "元组可以通过模式匹配或索引访问："

#: ../../language/fundamentals.md:214
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq!(x1, x2)\n"
"  assert_eq!(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:220
msgid "Ref"
msgstr ""

#: ../../language/fundamentals.md:222
msgid "A `Ref[T]` is a mutable reference containing a value `val` of type `T`."
msgstr "`Ref[T]` 是一个包含类型 `T` 的值 `val` 的可变引用。"

#: ../../language/fundamentals.md:224
msgid ""
"It can be constructed using `{ val : x }`, and can be accessed using "
"`ref.val`. See [struct](#struct) for detailed explanation."
msgstr "可以使用 `{ val : x }` 构造它，并可以使用 `ref.val` 访问它。有关详细说明，请参见[结构体](#struct)。"

#: ../../language/fundamentals.md:226
msgid ""
"let a : Ref[Int] = { val : 100 }\n"
"\n"
"test {\n"
"  a.val = 200\n"
"  assert_eq!(a.val, 200)\n"
"  a.val += 1\n"
"  assert_eq!(a.val, 201)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:232
msgid "Option and Result"
msgstr "Option 和 Result"

#: ../../language/fundamentals.md:234
msgid ""
"`Option` and `Result` are the most common types to represent a possible "
"error or failure in MoonBit."
msgstr "`Option` 和 `Result` 是 MoonBit 中表示可能的错误或失败的最常见类型。"

#: ../../language/fundamentals.md:236
msgid ""
"`Option[T]` represents a possibly missing value of type `T`. It can be "
"abbreviated as `T?`."
msgstr "`Option[T]` 表示可能缺失的类型 `T` 的值。它可以缩写为 `T?`。"

#: ../../language/fundamentals.md:237
msgid ""
"`Result[T, E]` represents either a value of type `T` or an error of type "
"`E`."
msgstr "`Result[T, E]` 表示类型 `T` 的值或类型 `E` 的错误。"

#: ../../language/fundamentals.md:239
msgid "See [enum](#enum) for detailed explanation."
msgstr "有关详细说明，请参见[枚举](#enum)。"

#: ../../language/fundamentals.md:241
msgid ""
"test {\n"
"  let a : Option[Int] = None\n"
"  let b : Option[Int] = Some(42)\n"
"  let c : Result[Int, String] = Ok(42)\n"
"  let d : Result[Int, String] = Err(\"error\")\n"
"  match a {\n"
"    Some(_) => assert_true!(false)\n"
"    None => assert_true!(true)\n"
"  }\n"
"  match d {\n"
"    Ok(_) => assert_true!(false)\n"
"    Err(_) => assert_true!(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:247
msgid "Array"
msgstr "数组"

#: ../../language/fundamentals.md:249
msgid ""
"An array is a finite sequence of values constructed using square brackets"
" `[]`, with elements separated by commas `,`. For example:"
msgstr "数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。例如："

#: ../../language/fundamentals.md:251
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/fundamentals.md:258
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts "
"from zero."
msgstr "您可以使用 `numbers[x]` 来引用第 x 个元素。索引从零开始。"

#: ../../language/fundamentals.md:260
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq!(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:267
msgid "There are `Array[T]` and `FixedArray[T]`:"
msgstr "有 `Array[T]` 和 `FixedArray[T]`："

#: ../../language/fundamentals.md:269
msgid "`Array[T]` can grow in size, while"
msgstr "`Array[T]` 可以增长，而"

#: ../../language/fundamentals.md:270
msgid ""
"`FixedArray[T]` has a fixed size, thus it needs to be created with "
"initial value."
msgstr "`FixedArray[T]` 有固定的大小，因此需要使用初始值创建。"

#: ../../language/fundamentals.md:273
msgid "A common pitfall is creating `FixedArray` with the same initial value:"
msgstr "一个常见的陷阱是使用相同的初始值创建 `FixedArray`："

#: ../../language/fundamentals.md:275
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))"
"\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:282
msgid ""
"This is because all the cells reference to the same object (the "
"`FixedArray[Int]` in this case). One should use `FixedArray::makei()` "
"instead which creates an object for each index."
msgstr ""
"这是因为所有单元格引用相同的对象（在这种情况下是 `FixedArray[Int]`）。应该使用 "
"`FixedArray::makei()`，它为每个索引创建一个对象。"

#: ../../language/fundamentals.md:284
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::makei(\n"
"    10, \n"
"    fn (_i) { FixedArray::make(10, 0) }\n"
"  )\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:292
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"array, otherwise `Array[T]` is created:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载数组，否则将创建 `Array[T]`："

#: ../../language/fundamentals.md:295
msgid ""
"let fixed_array_1 : FixedArray[Int] = [1, 2, 3]\n"
"let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])\n"
"let array_3 = [1, 2, 3] // Array[Int]\n"
msgstr ""

#: ../../language/fundamentals.md:301
msgid "ArrayView"
msgstr ""

#: ../../language/fundamentals.md:303
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create "
"a view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""
"类似于其他语言中的 `slice`，视图是对集合的特定段的引用。您可以使用 `data[start:end]` 创建数组 `data` "
"的视图，引用从 `start` 到 `end`（不包括）的元素。`start` 和 `end` 索引都可以省略。"

#: ../../language/fundamentals.md:308
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect!(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect!(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect!(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect!(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:314
msgid "Map"
msgstr "Map"

#: ../../language/fundamentals.md:316
msgid ""
"MoonBit provides a hash map data structure that preserves insertion order"
" called `Map` in its standard library. `Map`s can be created via a "
"convenient literal syntax:"
msgstr "MoonBit 在其标准库中提供了一个保留插入顺序的哈希映射数据结构，称为 `Map`。`Map` 可以通过方便的字面量语法创建："

#: ../../language/fundamentals.md:319
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/fundamentals.md:325
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be"
" destructed elegantly with pattern matching, see [Map Pattern](#map-"
"pattern)."
msgstr "目前，映射字面量语法中的键必须是常量。`Map` 也可以通过模式匹配优雅地解构，参见 [Map 模式](#map-pattern)。"

#: ../../language/fundamentals.md:327
msgid "Json literal"
msgstr "Json 字面量"

#: ../../language/fundamentals.md:329
msgid ""
"MoonBit supports convenient json handling by overloading literals. When "
"the expected type of an expression is `Json`, number, string, array and "
"map literals can be directly used to create json data:"
msgstr ""
"MoonBit 通过重载字面量支持方便的 json 处理。当表达式的期望类型是 `Json` 时，数字、字符串、数组和映射字面量可以直接用于创建 "
"json 数据："

#: ../../language/fundamentals.md:332
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", "
"\"moonbitlang/core/coverage\"],\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:338
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr "Json 值也可以进行模式匹配，参见 [Json 模式](#json-pattern)。"

#: ../../language/fundamentals.md:340
msgid "Functions"
msgstr "函数"

#: ../../language/fundamentals.md:342
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values"
" of other functions. MoonBit's naming convention requires that function "
"names should not begin with uppercase letters (A-Z). Compare for "
"constructors in the `enum` section below."
msgstr ""
"函数接受参数并产生结果。在 MoonBit 中，函数是一等公民，这意味着函数可以是其他函数的参数或返回值。MoonBit "
"的命名约定要求函数名不应以大写字母（A-Z）开头。请参见下面的 `enum` 部分中的构造器。"

#: ../../language/fundamentals.md:344
msgid "Top-Level Functions"
msgstr "顶层函数"

#: ../../language/fundamentals.md:346
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` "
"keyword to define a top-level function that sums three integers and "
"returns the result, as follows:"
msgstr "函数可以定义为顶级或局部。我们可以使用 `fn` 关键字定义一个顶级函数，它将三个整数相加并返回结果，如下所示："

#: ../../language/fundamentals.md:348
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:354
msgid ""
"Note that the arguments and return value of top-level functions require "
"**explicit** type annotations."
msgstr "请注意，顶级函数的参数和返回值需要**显式**类型注释。"

#: ../../language/fundamentals.md:356
msgid "Local Functions"
msgstr "局部函数"

#: ../../language/fundamentals.md:358
msgid ""
"Local functions can be named or anonymous. Type annotations can be "
"omitted for local function definitions: they can be automatically "
"inferred in most cases. For example:"
msgstr "局部函数可以是命名的或匿名的。局部函数定义可以省略类型注释：在大多数情况下，它们可以自动推断。例如："

#: ../../language/fundamentals.md:360
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly applied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"
msgstr ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // 命名为 `inc`\n"
"    x + 1\n"
"  }\n"
"  // 匿名，立即应用于整数字面量 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"

#: ../../language/fundamentals.md:366
msgid ""
"There's also a form called **matrix function** that make use of [pattern "
"matching](#pattern-matching):"
msgstr "还有一种称为**矩阵函数**的形式，它使用[模式匹配](#pattern-matching)："

#: ../../language/fundamentals.md:368
msgid ""
"let extract : (Int?, Int) -> Int = fn {\n"
"  Some(x), _ => x\n"
"  None, default => default\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:374
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr "函数，无论是命名的还是匿名的，都是 _词法闭包_：没有局部绑定的任何标识符必须引用来自周围词法范围的绑定。例如："

#: ../../language/fundamentals.md:376
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:382
msgid "Function Applications"
msgstr "函数应用"

#: ../../language/fundamentals.md:384
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr "函数可以应用于括号中的参数列表："

#: ../../language/fundamentals.md:386
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/fundamentals.md:390
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown "
"below:"
msgstr "无论 `add3` 是一个使用名称定义的函数（如前面的示例）还是绑定到函数值的变量，都可以工作，如下所示："

#: ../../language/fundamentals.md:392
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq!(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:398
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that "
"evaluates to a function value is applicable:"
msgstr "表达式 `add3(1, 2, 7)` 返回 `10`。任何求值为函数值的表达式都是可应用的："

#: ../../language/fundamentals.md:400
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq!(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:407
msgid "Labelled arguments"
msgstr "带标签的参数"

#: ../../language/fundamentals.md:409
msgid ""
"**Top-level** functions can declare labelled argument with the syntax "
"`label~ : Type`. `label` will also serve as parameter name inside "
"function body:"
msgstr "**顶层**函数可以使用语法 `label~ : Type` 声明带标签的参数。`label` 也将作为函数体内的参数名："

#: ../../language/fundamentals.md:411
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:417
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. "
"`label=label` can be abbreviated as `label~`:"
msgstr "可以通过语法 `label=arg` 提供带标签的参数。`label=label` 可以缩写为 `label~`："

#: ../../language/fundamentals.md:419
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq!(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:425
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr "带标签的函数可以以任何顺序提供。参数的求值顺序与函数声明中参数的顺序相同。"

#: ../../language/fundamentals.md:427
msgid "Optional arguments"
msgstr "可选参数"

#: ../../language/fundamentals.md:429
msgid ""
"A labelled argument can be made optional by supplying a default "
"expression with the syntax `label~ : Type = default_expr`. If this "
"argument is not supplied at call site, the default expression will be "
"used:"
msgstr ""
"可以通过语法 `label~ : Type = default_expr` "
"提供默认值，使带标签的参数可以省略。如果在调用时未提供此参数，则将使用默认表达式："

#: ../../language/fundamentals.md:431
msgid ""
"fn optional(opt~ : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(optional(), 42)\n"
"  assert_eq!(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:437
msgid ""
"The default expression will be evaluated every time it is used. And the "
"side effect in the default expression, if any, will also be triggered. "
"For example:"
msgstr "默认表达式每次使用时都会被求值。并且默认表达式中的副作用（如果有）也会被触发。例如："

#: ../../language/fundamentals.md:439
msgid ""
"fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect!(incr(counter~), content=\"{val: 1}\")\n"
"  inspect!(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:445
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr "如果要在不同的函数调用之间共享默认表达式的结果，可以将默认表达式提升到顶层 `let` 声明："

#: ../../language/fundamentals.md:447
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(incr_2(), 1)\n"
"  assert_eq!(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:453
msgid ""
"Default expression can depend on the value of previous arguments. For "
"example:"
msgstr "默认表达式可以依赖于先前参数的值。例如："

#: ../../language/fundamentals.md:455
msgid ""
"fn sub_array[X](\n"
"  xs : Array[X],\n"
"  offset~ : Int,\n"
"  len~ : Int = xs.length() - offset\n"
") -> Array[X] {\n"
"  xs[offset:offset + len].iter().to_array()\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:462
msgid "Automatically insert `Some` when supplying optional arguments"
msgstr "在提供可选参数时自动插入 `Some`"

#: ../../language/fundamentals.md:464
msgid ""
"It is quite often optional arguments have type `T?` with `None` as "
"default value. In this case, passing the argument explicitly requires "
"wrapping a `Some`, which is ugly:"
msgstr "通常可选参数的类型为 `T?`，默认值为 `None`。在这种情况下，显式传递参数需要包装一个 `Some`，这很丑："

#: ../../language/fundamentals.md:468
msgid ""
"fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image"
" {\n"
"  ...\n"
"}\n"
"\n"
"let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))\n"
msgstr ""

#: ../../language/fundamentals.md:474
msgid ""
"Fortunately, MoonBit provides a special kind of optional arguments to "
"solve this problem. Optional arguments declared with `label? : T` has "
"type `T?` and `None` as default value. When supplying this kind of "
"optional argument directly, MoonBit will automatically insert a `Some`:"
msgstr ""
"幸运的是，MoonBit 提供了一种特殊类型的可选参数来解决这个问题。使用 `label? : T` 声明的可选参数的类型为 `T?`，默认值为 "
"`None`。在直接提供这种可选参数时，MoonBit 将自动插入 `Some`："

#: ../../language/fundamentals.md:478
msgid ""
"fn nice_constructor(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = nice_constructor(width=1920, height=1080)\n"
msgstr ""

#: ../../language/fundamentals.md:484
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""
"有时，直接传递类型为 `T?` 的值也很有用，例如在转发可选参数时。MoonBit 为此提供了一个语法 `label?=value`，并且 "
"`label?` 是 `label?=label` 的缩写："

#: ../../language/fundamentals.md:488
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:494
msgid "Autofill arguments"
msgstr "自动填充参数"

#: ../../language/fundamentals.md:496
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare an optional argument with "
"`_` as default value. Now if the argument is not explicitly supplied, "
"MoonBit will automatically fill it at the call site."
msgstr ""
"MoonBit 支持在调用时自动填充特定类型的参数，例如函数调用的源位置。要声明一个自动填充参数，只需将一个可选参数声明为 `_` "
"作为默认值。现在，如果未显式提供参数，MoonBit 将在调用时自动填充它。"

#: ../../language/fundamentals.md:500
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is a array containing the source location of each argument, if any:"
msgstr ""
"目前 MoonBit 支持两种类型的自动填充参数，`SourceLoc`，它是整个函数调用的源位置，以及 "
"`ArgsLoc`，它是一个数组，包含每个参数的源位置（如果有）："

#: ../../language/fundamentals.md:503
msgid ""
"fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {"
"\n"
"  $|loc of whole function call: \\{loc}\n"
"  $|loc of arguments: \\{args_loc}\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), "
"Some(<filename>:7:8-7:9), None, None]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:509
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr "自动填充参数非常有用，用于编写调试和测试工具。"

#: ../../language/fundamentals.md:511
msgid "Control Structures"
msgstr "控制结构"

#: ../../language/fundamentals.md:513
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../language/fundamentals.md:515
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr "条件表达式由条件、结果和可选的 `else` 子句或 `else if` 子句组成。"

#: ../../language/fundamentals.md:517
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:524
msgid "The curly brackets around the consequent are required."
msgstr "结果周围的大括号是必需的。"

#: ../../language/fundamentals.md:526
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and"
" the return values of the consequent and the else clause must be of the "
"same type. Here is an example:"
msgstr "请注意，条件表达式在 MoonBit 中始终返回一个值，结果和 else 子句的返回值必须是相同的类型。以下是一个示例："

#: ../../language/fundamentals.md:528
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals.md:535
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr "`else` 子句只有在返回值的类型为 `Unit`的时候省略。"

#: ../../language/fundamentals.md:537
msgid "Match Expression"
msgstr "匹配表达式"

#: ../../language/fundamentals.md:539
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](#pattern-matching) to decide which consequent to "
"evaluate and extracting variables at the same time."
msgstr "`match` 表达式类似于条件表达式，但它使用[模式匹配](#pattern-matching)来决定要评估哪个结果，并同时提取变量。"

#: ../../language/fundamentals.md:541
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:548
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, "
"and the program will terminate if that case were reached."
msgstr "如果省略了可能的条件，编译器将发出警告；如果真的出现该情况，程序将终止。"

#: ../../language/fundamentals.md:550
msgid "Guard Statement"
msgstr "卫语句"

#: ../../language/fundamentals.md:552
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing "
"the subsequent statements and returns. If the condition is not satisfied "
"(i.e., false), the code in the `else` block is executed and its "
"evaluation result is returned (the subsequent statements are skipped)."
msgstr ""
"`guard` 语句用于检查指定的不变量。如果不变量的条件得到满足，程序将继续执行后续语句。如果条件不满足（即为假），则执行 `else` "
"块中的代码且返回其值（并跳过后续语句）。"

#: ../../language/fundamentals.md:557
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect!(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:564
msgid "Guarded Let"
msgstr "卫语句与赋值绑定"

#: ../../language/fundamentals.md:566
msgid ""
"The `let` statement can be used with [pattern matching](#pattern-"
"matching). However, `let` statement can only handle one case. And `guard "
"let` can solve this issue."
msgstr ""
"`let` 语句可以与[模式匹配](#pattern-matching)一起使用。但是，`let` 语句只能处理一种情况。`guard let` "
"可以解决这个问题。"

#: ../../language/fundamentals.md:568
msgid ""
"In the following example, `getProcessedText` assumes that the input "
"`path` points to resources that are all plain text, and it uses the "
"`guard` statement to ensure this invariant. Compared to using a `match` "
"statement, the subsequent processing of `text` can have one less level of"
" indentation."
msgstr ""
"在以下示例中，`getProcessedText` 假设输入的 `path` 指向的资源都是纯文本，并使用 `guard` "
"语句来确保这个不变量。与使用 `match` 语句相比，`text` 的后续处理可以少一级缩进。"

#: ../../language/fundamentals.md:572
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String\n"
") -> String!Error {\n"
"  guard let Some(PlainText(text)) = resources[path] else {\n"
"    None => fail!(\"\\{path} not found\")\n"
"    Some(Folder(_)) => fail!(\"\\{path} is a folder\")\n"
"    Some(JsonConfig(_)) => fail!(\"\\{path} is a json config\")\n"
"  }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:578
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr "如果省略了 `else` 部分，程序将在 `guard` 语句中指定的条件不为真或无法匹配时终止。"

#: ../../language/fundamentals.md:581
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard let Some(x) = expr\n"
"// <=> guard let Some(x) = expr else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals.md:588
msgid "While loop"
msgstr "While 循环"

#: ../../language/fundamentals.md:590
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code "
"repeatedly as long as a condition is true. The condition is evaluated "
"before executing the block of code. The `while` loop is defined using the"
" `while` keyword, followed by a condition and the loop body. The loop "
"body is a sequence of statements. The loop body is executed as long as "
"the condition is true."
msgstr ""
"在 MoonBit 中，`while` 循环可用于在条件为真时重复执行一段代码块。在执行代码块之前，将评估条件。使用 `while` 关键字定义 "
"`while` 循环，后跟条件和循环体。循环体是一系列语句。只要条件为真，就会执行循环体。"

#: ../../language/fundamentals.md:592
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:600
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals.md:604
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you "
"to exit the current loop, while using `continue` skips the remaining part"
" of the current iteration and proceeds to the next iteration."
msgstr ""
"循环体支持 `break` 和 `continue`。使用 `break` 可以退出当前循环，而使用 `continue` "
"则跳过当前迭代的剩余部分并继续下一次迭代。"

#: ../../language/fundamentals.md:606
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:614
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals.md:618
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the"
" loop will end."
msgstr "`while` 循环还支持可选的 `else` 子句。当循环条件变为假时，将执行 `else` 子句，然后循环将结束。"

#: ../../language/fundamentals.md:620
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:628
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:632
msgid ""
"When there is an `else` clause, the `while` loop can also return a value."
" The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value"
" of the `else` clause."
msgstr ""
"当有 `else` 子句时，`while` 循环还可以返回一个值。返回值是 `else` 子句的评估结果。在这种情况下，如果使用 `break` "
"退出循环，需要在 `break` 后提供一个返回值，该返回值应与 `else` 子句的返回值类型相同。"

#: ../../language/fundamentals.md:634
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:642
msgid "5\n"
msgstr ""

#: ../../language/fundamentals.md:646
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:654
msgid "7\n"
msgstr ""

#: ../../language/fundamentals.md:658
msgid "For Loop"
msgstr "For 循环"

#: ../../language/fundamentals.md:660
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by"
" variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. "
"For example, the code below creates a new variable binding `i`, which has"
" a scope throughout the entire loop and is immutable. This makes it "
"easier to write clear code and reason about it:"
msgstr ""
"MoonBit 还支持 C 风格的 For 循环。关键字 `for` "
"后跟由分号分隔的变量初始化子句、循环条件和更新子句。它们不需要用括号括起来。例如，下面的代码创建了一个新的变量绑定 "
"`i`，它在整个循环中都有作用域且是不可变的。这使得编写清晰的代码并对其进行推理更容易："

#: ../../language/fundamentals.md:663
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:671
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals.md:675
msgid "The variable initialization clause can create multiple bindings:"
msgstr "变量初始化子句可以创建多个绑定："

#: ../../language/fundamentals.md:677
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:684
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In "
"other words, in the example above, the update clause does not execute `i "
"= i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at "
"the same time. Therefore, when reading the values of the binding "
"variables in the update clause, you will always get the values updated in"
" the previous iteration."
msgstr ""
"应该注意，在更新子句中，当有多个绑定变量时，语义是同时更新它们。换句话说，在上面的示例中，更新子句不会按顺序执行 `i = i + 1`，`j ="
" j + 1`，而是同时递增 `i` 和 `j`。因此，在更新子句中读取绑定变量的值时，总是会得到上一次迭代中更新的值。"

#: ../../language/fundamentals.md:686
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are "
"all optional. For example, the following two are infinite loops:"
msgstr "变量初始化子句、循环条件和更新子句都是可选的。例如，以下两个是无限循环："

#: ../../language/fundamentals.md:688
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:695
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. "
"Like the `while` loop, the `for` loop can also return a value using the "
"`break` and `else` clauses."
msgstr ""
"`for` 循环还支持 `continue`、`break` 和 `else` 子句。与 `while` 循环一样，`for` 循环也可以使用 "
"`break` 和 `else` 子句返回一个值。"

#: ../../language/fundamentals.md:697
msgid ""
"The `continue` statement skips the remaining part of the current "
"iteration of the `for` loop (including the update clause) and proceeds to"
" the next iteration. The `continue` statement can also update the binding"
" variables of the `for` loop, as long as it is followed by expressions "
"that match the number of binding variables, separated by commas."
msgstr ""
"`continue` 语句跳过当前 `for` 循环的剩余部分（包括更新子句）并继续下一次迭代。`continue` 语句还可以更新 `for` "
"循环的绑定变量，只要后面跟着与绑定变量数量匹配的表达式，用逗号分隔。"

#: ../../language/fundamentals.md:699
msgid ""
"For example, the following program calculates the sum of even numbers "
"from 1 to 6:"
msgstr "例如，以下程序计算从 1 到 6 的偶数之和："

#: ../../language/fundamentals.md:701
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:709
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals.md:713
msgid "`for .. in` loop"
msgstr "`for .. in` 循环"

#: ../../language/fundamentals.md:715
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr "MoonBit 支持通过 `for .. in` 循环语法遍历不同数据结构和序列的元素："

#: ../../language/fundamentals.md:717
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:724
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard"
" library. Any type with a method `.iter() : Iter[T]` can be traversed "
"using `for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""
"`for .. in` 循环被转换为在 MoonBit 标准库中使用 `Iter`。任何具有方法 `.iter() : Iter[T]` "
"的类型都可以使用 `for .. in` 进行遍历。有关 `Iter` 类型的更多信息，请参见下面的[迭代器](#iterator)。"

#: ../../language/fundamentals.md:727
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr "`for .. in` 循环还支持遍历整数序列，例如："

#: ../../language/fundamentals.md:729
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq!(i, 45)\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq!(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:736
msgid ""
"In addition to sequences of a single value, MoonBit also supports "
"traversing sequences of two values, such as `Map`, via the `Iter2` type "
"in MoonBit's standard library. Any type with method `.iter2() : Iter2[A, "
"B]` can be traversed using `for .. in` with two loop variables:"
msgstr ""
"除了单个值的序列外，MoonBit 还支持通过 MoonBit 标准库中的 `Iter2` 类型遍历两个值的序列，例如 `Map`。任何具有方法 "
"`.iter2() : Iter2[A, B]` 的类型都可以使用两个循环变量的 `for .. in` 进行遍历："

#: ../../language/fundamentals.md:739
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:746
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr "另一个使用两个循环变量的 `for .. in` 的示例是在遍历数组时跟踪数组索引："

#: ../../language/fundamentals.md:748
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:756
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals.md:760
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr "`for .. in` 循环的主体支持诸如 `return`、`break` 和错误处理等控制流操作："

#: ../../language/fundamentals.md:762
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:770
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals.md:774
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr "如果循环变量未使用，可以使用 `_` 忽略它。"

#: ../../language/fundamentals.md:776
msgid "Functional loop"
msgstr "函数式循环"

#: ../../language/fundamentals.md:778
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to "
"write loops in a functional style."
msgstr "函数式循环是 MoonBit 中的一个强大功能，它使您可以以函数式风格编写循环。"

#: ../../language/fundamentals.md:780
msgid ""
"A functional loop consumes arguments and returns a value. It is defined "
"using the `loop` keyword, followed by its arguments and the loop body. "
"The loop body is a sequence of clauses, each of which consists of a "
"pattern and an expression. The clause whose pattern matches the input "
"will be executed, and the loop will return the value of the expression. "
"If no pattern matches, the loop will panic. Use the `continue` keyword "
"with arguments to start the next iteration of the loop. Use the `break` "
"keyword with arguments to return a value from the loop. The `break` "
"keyword can be omitted if the value is the last expression in the loop "
"body."
msgstr ""
"函数式循环接收参数并返回一个值。它使用 `loop` "
"关键字定义，后跟其参数和循环体。循环体是一系列子句，每个子句由模式和表达式组成。与输入匹配的模式的子句将会被执行，并且循环将返回表达式的值。如果没有对应的模式，程序会中止。使用"
" `continue` 关键字和参数进入循环的下一次迭代。使用 `break` "
"关键字和参数从循环中返回一个值。如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。"

#: ../../language/fundamentals.md:782
msgid ""
"test {\n"
"  fn sum(xs : @immut/list.T[Int]) -> Int {\n"
"    loop xs, 0 {\n"
"      Nil, acc => break acc // <=> Nil, acc => acc\n"
"      Cons(x, rest), acc => continue rest, x + acc\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:789
msgid ""
"Currently in `loop exprs { ... }`, `exprs` is nonempty list, while `for {"
" ... }` is accepted for infinite loop."
msgstr "目前在 `loop exprs { ... }` 中，`exprs` 是非空列表，而 `for { ... }` 用于无限循环。"

#: ../../language/fundamentals.md:792
msgid "Labelled Continue/Break"
msgstr "带标记的 Continue/Break"

#: ../../language/fundamentals.md:794
msgid ""
"When a loop is labelled, it can be referenced from a `break` or "
"`continue` from within a nested loop. For example:"
msgstr "当一个循环被标记的时候，它可以从循环中的 `break` 或者 "
"`continue` 中引用，例如："

#: ../../language/fundamentals.md:797
msgid ""
"test \"break label\" {\n"
"  let mut count = 0\n"
"  let xs = [1, 2, 3]\n"
"  let ys = [4, 5, 6]\n"
"  let res = outer~: for i in xs {\n"
"    for j in ys {\n"
"      count = count + i\n"
"      break outer~ j\n"
"    }\n"
"  } else {\n"
"    -1\n"
"  }\n"
"  assert_eq!(res, 4)\n"
"  assert_eq!(count, 1)\n"
"}\n"
"\n"
"test \"continue label\" {\n"
"  let mut count = 0\n"
"  let init = 10\n"
"  let res =outer~: loop init {\n"
"    0 => 42\n"
"    i => {\n"
"      for {\n"
"        count = count + 1\n"
"        continue outer~ i - 1\n"
"      }\n"
"    }\n"
"  }\n"
"  assert_eq!(res, 42)\n"
"  assert_eq!(count, 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:803
msgid "Iterator"
msgstr "迭代器"

#: ../../language/fundamentals.md:805
msgid ""
"An iterator is an object that traverse through a sequence while providing"
" access to its elements. Traditional OO languages like Java's "
"`Iterator<T>` use `next()` `hasNext()` to step through the iteration "
"process, whereas functional languages (JavaScript's `forEach`, Lisp's "
"`mapcar`) provides a high-order function which takes an operation and a "
"sequence then consumes the sequence with that operation being applied to "
"the sequence. The former is called _external iterator_ (visible to user) "
"and the latter is called _internal iterator_ (invisible to user)."
msgstr ""
"迭代器是一个对象，它在遍历序列的同时提供对其元素的访问。传统的面向对象语言如 Java 的 `Iterator<T>` 使用 `next()` "
"`hasNext()` 来遍历迭代过程，而函数式语言（JavaScript 的 `forEach`，Lisp 的 "
"`mapcar`）提供了一个高阶函数，该函数接受一个操作和一个序列，然后使用该操作应用于序列。前者称为_外部迭代器_（对用户可见），后者称为_内部迭代器_（对用户不可见）。"

#: ../../language/fundamentals.md:813
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator "
"implementation. Almost all built-in sequential data structures have "
"implemented `Iter`:"
msgstr "内置类型 `Iter[T]` 是 MoonBit 的内部迭代器实现。几乎所有内置的顺序数据结构都已经实现了 `Iter`："

#: ../../language/fundamentals.md:816
msgid ""
"///|\n"
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(fn { x => (x & 1) == 0 }).collect()\n"
"}\n"
"\n"
"///|\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::op_mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:822
msgid "Commonly used methods include:"
msgstr "常用的方法包括："

#: ../../language/fundamentals.md:824
msgid ""
"`each`: Iterates over each element in the iterator, applying some "
"function to each element."
msgstr "`each`: 遍历迭代器中的每个元素，对每个元素应用某个函数。"

#: ../../language/fundamentals.md:825
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr "`fold`: 使用给定的函数，从给定的初始值开始，对迭代器的元素进行“折叠”。"

#: ../../language/fundamentals.md:826
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr "`collect`: 将迭代器的元素收集到一个数组中。"

#: ../../language/fundamentals.md:828
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a "
"predicate function."
msgstr "`filter`: （惰性）根据谓词函数过滤迭代器的元素。"

#: ../../language/fundamentals.md:829
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr "`map`: （惰性）使用映射函数转换迭代器的元素。"

#: ../../language/fundamentals.md:830
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the "
"elements of the second iterator to the first."
msgstr "`concat`: （惰性）通过将第二个迭代器的元素附加到第一个迭代器，将两个迭代器合并为一个。"

#: ../../language/fundamentals.md:832
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. "
"Array. But what makes `Iter` special is that any method that constructs a"
" new `Iter` is _lazy_ (i.e. iteration doesn't start on call because it's "
"wrapped inside a function), as a result of no allocation for intermediate"
" value. That's what makes `Iter` superior for traversing through "
"sequence: no extra cost. MoonBit encourages user to pass an `Iter` across"
" functions instead of the sequence object itself."
msgstr ""
"像 `filter` `map` 这样的方法在序列对象（例如 Array）上非常常见。但是，`Iter` 的不同之处在于，任何构造新 `Iter`"
" 的方法都是**惰性**的（即在调用时不会开始迭代，因为它被包装在一个函数内），因此不会为中间值分配内存。这就是使 `Iter` "
"优于遍历序列的原因：没有额外的成本。MoonBit 鼓励用户将 `Iter` 传递给函数，而不是传递序列对象本身。"

#: ../../language/fundamentals.md:840
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement "
"`Iter`, namely, a function that returns an `Iter[S]`. Take `Bytes` as an "
"example:"
msgstr ""
"预定义的序列结构如 `Array` 及其迭代器应该足够使用。但是，为了在自定义序列（元素类型为 `S`）中使用这些方法，我们需要实现 "
"`Iter`，即返回 `Iter[S]` 的函数。以 `Bytes` 为例："

#: ../../language/fundamentals.md:845
msgid ""
"///|\n"
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"    for byte in data {\n"
"      guard let IterContinue = visit(byte) else { x => break x }\n"
"\n"
"    } else {\n"
"      IterContinue\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:851
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the "
"only main difference being the code block that actually does the "
"iteration."
msgstr "几乎所有 `Iter` 实现都与 `Bytes` 的实现相同，唯一的主要区别是实际执行迭代的代码块。"

#: ../../language/fundamentals.md:854
msgid "Implementation details"
msgstr "实现细节"

#: ../../language/fundamentals.md:856
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration"
" which consists any of the 2 states:"
msgstr ""
"类型 `Iter[T]` 基本上是 `((T) -> IterResult) -> IterResult` "
"的类型别名，它是一个高阶函数，接受一个操作，`IterResult` 是一个枚举对象，用于跟踪当前迭代的状态，包含以下 2 种状态："

#: ../../language/fundamentals.md:861
msgid "`IterEnd`: marking the end of an iteration"
msgstr "`IterEnd`: 标记迭代结束"

#: ../../language/fundamentals.md:862
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr "`IterContinue`: 标记迭代结束尚未到达，暗示迭代将在此状态继续。"

#: ../../language/fundamentals.md:864
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use "
"it to transform `Iter[T]` itself to a new state of type `IterResult`. "
"Whether that state being `IterEnd` `IterContinue` depends on the "
"function."
msgstr ""
"简单来说，`Iter[T]` 接受一个函数 `(T) -> IterResult` 并使用它将 `Iter[T]` 本身转换为类型为 "
"`IterResult` 的新状态。"

#: ../../language/fundamentals.md:868
msgid ""
"Iterator provides a unified way to iterate through data structures, and "
"they can be constructed at basically no cost: as long as `fn(yield)` "
"doesn't execute, the iteration process doesn't start."
msgstr "迭代器提供了一种统一的遍历数据结构的方式，它们基本上可以无成本地构建：只要 `fn(yield)` 不执行，迭代过程就不会开始。"

#: ../../language/fundamentals.md:872
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all"
" sorts of `Iter` methods might be visually pleasing, but do notice the "
"heavy work underneath the abstraction."
msgstr "`Iter::run()` 在在内部触发迭代。链接各种 `Iter` 方法可能看起来很美观，但请注意抽象层下面的繁重工作。"

#: ../../language/fundamentals.md:876
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no "
"way to stop unless the end is reached. Methods such as `count()` which "
"counts the number of elements in a iterator looks like an `O(1)` "
"operation but actually has linear time complexity. Carefully use "
"iterators or performance issue might occur."
msgstr ""
"因此，与外部迭代器不同，一旦迭代开始，除非到达末尾，否则无法停止。诸如 `count()` 这样的方法，它计算迭代器中元素的数量看起来像是一个 "
"`O(1)` 操作，但实际上具有线性时间复杂度。请谨慎使用迭代器，否则可能会出现性能问题。"

#: ../../language/fundamentals.md:882
msgid "Custom Data Types"
msgstr "自定义数据类型"

#: ../../language/fundamentals.md:884
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr "创建新数据类型有两种方法：`struct` 和 `enum`。"

#: ../../language/fundamentals.md:886
msgid "Struct"
msgstr "结构体"

#: ../../language/fundamentals.md:888
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed "
"by field names. A struct can be constructed using a struct literal, which"
" is composed of a set of labeled values and delimited with curly "
"brackets. The type of a struct literal can be automatically inferred if "
"its fields exactly match the type definition. A field can be accessed "
"using the dot syntax `s.f`. If a field is marked as mutable using the "
"keyword `mut`, it can be assigned a new value."
msgstr ""
"在 MoonBit "
"中，结构体类似于元组，但其字段由字段名称索引。可以使用结构体字面量构造结构体，结构体字面量由一组带标签的值组成，并用大括号括起来。如果结构体的字段与类型定义完全匹配，那么结构体字面量的类型可以自动推断。可以使用点语法"
" `s.f` 访问字段。如果使用关键字 `mut` 标记字段为可变的，则可以为其分配新值。"

#: ../../language/fundamentals.md:890
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:896
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:904
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals.md:908
msgid "Constructing Struct with Shorthand"
msgstr "使用简写构造结构体"

#: ../../language/fundamentals.md:910
msgid ""
"If you already have some variable like `name` and `email`, it's redundant"
" to repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr "如果已经有一些变量，如 `name` 和 `email`，在构造结构体时重复这些名称是多余的。可以使用简写，它的行为完全相同："

#: ../../language/fundamentals.md:912
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:919
msgid ""
"If there's no other struct that has the same fields, it's redundant to "
"add the struct's name when constructing it:"
msgstr "如果没有其他具有相同字段的结构体，在构造结构体时添加结构体的名称是多余的："

#: ../../language/fundamentals.md:921
msgid "let u2 = { id : 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:928
msgid "Struct Update Syntax"
msgstr "结构体更新语法"

#: ../../language/fundamentals.md:930
msgid ""
"It's useful to create a new struct based on an existing one, but with "
"some fields updated."
msgstr "可以用这个语法来根据现有结构体创建一个新的结构体，但只更新部分字段。"

#: ../../language/fundamentals.md:932
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"    $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:940
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals.md:944
msgid "Enum"
msgstr "枚举"

#: ../../language/fundamentals.md:946
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr "枚举类型类似于函数式语言中的代数数据类型。熟悉 C/C++ 的用户可能更喜欢称其为标记联合。"

#: ../../language/fundamentals.md:948
msgid ""
"An enum can have a set of cases (constructors). Constructor names must "
"start with capitalized letter. You can use these names to construct "
"corresponding cases of an enum, or checking which branch an enum value "
"belongs to in pattern matching:"
msgstr "枚举可以有一组情况（构造函数）。构造函数的名称必须以大写字母开头。可以使用这些名称来构造枚举的相应情况，或在模式匹配中检查枚举值属于哪个分支："

#: ../../language/fundamentals.md:950
msgid ""
"/// An enum type that represents the ordering relation between two "
"values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""
"/// 一个枚举类型，表示两个值之间的顺序关系，\n"
"/// 有三种情况 \"Smaller\"、\"Greater\" 和 \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"

#: ../../language/fundamentals.md:956
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""
"/// 比较两个整数之间的顺序关系\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // 当创建一个枚举时，如果目标类型已知，\n"
"    // 可以直接写构造函数名称\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // 但是当目标类型未知时，\n"
"    // 你总是可以使用 `TypeName::Constructor` 来创建一个枚举\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// 输出一个类型为 `Relation` 的值\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // 使用模式匹配来决定 `r` 属于哪种情况\n"
"  match r {\n"
"    // 在模式匹配期间，如果类型已知，\n"
"    // 写构造函数的名称就足够了\n"
"    Smaller => println(\"smaller!\")\n"
"    // 但是你也可以在模式匹配中使用 `TypeName::Constructor` 语法\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:963
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:971
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals.md:975
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr "枚举情况也可以携带额外数据。以下是使用枚举定义整数列表类型的示例："

#: ../../language/fundamentals.md:977
msgid ""
"enum List {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of "
"the list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, List)\n"
"}\n"
msgstr ""
"enum List {\n"
"  Nil\n"
"  // 构造函数 `Cons` 携带额外的数据：列表的第一个元素，\n"
"  // 和列表的其余部分\n"
"  Cons(Int, List)\n"
"}\n"

#: ../../language/fundamentals.md:983
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 除了将额外数据绑定到变量之外，\n"
"// 你还可以继续匹配构造函数内部的额外数据。\n"
"// 以下是一个函数，用于判断列表是否只包含一个元素\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // 此分支仅匹配形状为 `Cons(_, Nil)` 的值，\n"
"    // 即长度为 1 的列表\n"
"    Cons(_, Nil) => true\n"
"    // 使用 `_` 匹配其他所有情况\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // 在模式匹配带有额外数据的枚举时，\n"
"  // 除了决定值属于哪种情况\n"
"  // 你还可以提取该情况内部的额外数据\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // 这里 `x` 和 `xs` 定义了新变量\n"
"    // 而不是引用现有变量，\n"
"    // 如果 `l` 是一个 `Cons`，那么 `Cons` 的额外数据\n"
"    // （第一个元素和列表的其余部分）\n"
"    // 将绑定到 `x` 和 `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:990
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""
"fn main {\n"
"  // 使用 `Cons` 创建值时，必须提供 `Cons` 的额外数据\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"

#: ../../language/fundamentals.md:998
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals.md:1002
msgid "Constructor with labelled arguments"
msgstr "构造器与带标签参数"

#: ../../language/fundamentals.md:1004
msgid "Enum constructors can have labelled argument:"
msgstr "枚举构造器可以有带标签的参数："

#: ../../language/fundamentals.md:1006
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""
"enum E {\n"
"  // `x` 和 `y` 是有标签参数\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"

#: ../../language/fundamentals.md:1012
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""
"// 使用有标签参数的构造函数进行模式匹配\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` 是 `x=x` 的缩写\n"
"    // 未匹配的有标签参数可以通过 `..` 省略\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1019
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1027
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:1031
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr "也可以像在模式匹配中访问结构体字段一样访问构造函数的有标签参数："

#: ../../language/fundamentals.md:1033
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc."
"\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // 对于通过 `Point(..) as p` 定义的变量，\n"
"    // 编译器知道它必须是构造函数 `Point`，\n"
"    // 因此可以通过 `p.x`、`p.y` 等直接访问 `Point` 的字段。\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
"\n"

#: ../../language/fundamentals.md:1039
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with!(p2))\n"
"    println(p1.distance_with!(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1047
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals.md:1051
msgid "Constructor with mutable fields"
msgstr "构造器与可变字段"

#: ../../language/fundamentals.md:1053
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr "也可以为构造器定义可变字段。这对于定义命令式数据结构特别有用："

#: ../../language/fundamentals.md:1055
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree"
"\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 使用可变二叉搜索树实现的集合。\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// 带有亲指针的可变二叉搜索树\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // 只有带标签的参数可以是可变的\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// 将一个新元素插入到二叉搜索树中。\n"
"// 返回新的树\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // 修改构造器的字段\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // 在这里创建的 `node` 和 `node.left` 之间的循环\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // 树不为空，所以新的树就是原来的树\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1061
msgid "Newtype"
msgstr "Newtype"

#: ../../language/fundamentals.md:1063
msgid "MoonBit supports a special kind of enum called newtype:"
msgstr "MoonBit 支持一种特殊的枚举称为 newtype："

#: ../../language/fundamentals.md:1065
msgid ""
"// `UserId` is a fresh new type different from `Int`, \n"
"// and you can define new methods for `UserId`, etc.\n"
"// But at the same time, the internal representation of `UserId` \n"
"// is exactly the same as `Int`\n"
"type UserId Int\n"
"\n"
"type UserName String\n"
msgstr ""
"// `UserId` 是一个与 `Int` 不同的全新类型，\n"
"// 你可以为 `UserId` 定义新方法等。\n"
"// 但与此同时，`UserId` 的内部表示\n"
"// 与 `Int` 完全相同\n"
"type UserId Int\n"
"\n"
"type UserName String\n"

#: ../../language/fundamentals.md:1071
msgid ""
"Newtypes are similar to enums with only one constructor (with the same "
"name as the newtype itself). So, you can use the constructor to create "
"values of newtype, or use pattern matching to extract the underlying "
"representation of a newtype:"
msgstr ""
"Newtype 类似于只有一个构造函数的枚举（与 newtype 本身的名称相同）。因此，可以使用构造函数创建 newtype "
"的值，或使用模式匹配提取 newtype 的底层表示："

#: ../../language/fundamentals.md:1073
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserName = UserName(\"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserName(uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1081
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals.md:1085
msgid ""
"Besides pattern matching, you can also use `._` to extract the internal "
"representation of newtypes:"
msgstr "除了模式匹配，还可以使用 `._` 提取 newtype 的内部表示："

#: ../../language/fundamentals.md:1087
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let uid : Int = id._\n"
"  println(uid)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1095
msgid "1\n"
msgstr ""

#: ../../language/fundamentals.md:1099
msgid "Type alias"
msgstr "类型别名"

#: ../../language/fundamentals.md:1100
msgid "MoonBit supports type alias via the syntax `typealias Name = TargetType`:"
msgstr "MoonBit 支持使用语法 `typealias Name = TargetType` 定义类型别名："

#: ../../language/fundamentals.md:1102
msgid ""
"pub typealias Index = Int\n"
"\n"
"// type alias are private by default\n"
"typealias MapString[X] = Map[String, X]\n"
msgstr ""
"pub typealias Index = Int\n"
"\n"
"// 类型别名默认为私有\n"
"typealias MapString[X] = Map[String, X]\n"

#: ../../language/fundamentals.md:1108
msgid ""
"Unlike all other kinds of type declaration above, type alias does not "
"define a new type, it is merely a type macro that behaves exactly the "
"same as its definition. So for example one cannot define new methods or "
"implement traits for a type alias."
msgstr "与上面所有其他类型声明不同，类型别名不定义新类型，它只是一个行为与其定义完全相同的类型宏。因此，例如，不能为类型别名定义新方法或实现特征。"

#: ../../language/fundamentals.md:1113
msgid "Type alias can be used to perform incremental code refactor."
msgstr "类型别名可用于执行增量代码重构。"

#: ../../language/fundamentals.md:1115
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you "
"can leave a type alias `typealias T = @pkgB.T` in `@pkgA`, and "
"**incrementally** port uses of `@pkgA.T` to `@pkgB.T`. The type alias can"
" be removed after all uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr ""
"例如，如果要将类型 `T` 从 `@pkgA` 移动到 `@pkgB`，可以在 `@pkgA` 中留下一个类型别名 `typealias T = "
"@pkgB.T`，"

#: ../../language/fundamentals.md:1120
msgid "Local types"
msgstr "本地类型"

#: ../../language/fundamentals.md:1122
msgid ""
"Moonbit supports declaring structs/enums/newtypes at the top of a "
"toplevel function, which are only visible within the current toplevel "
"function. These local types can use the generic parameters of the "
"toplevel function but cannot introduce additional generic parameters "
"themselves. Local types can derive methods using derive, but no "
"additional methods can be defined manually. For  example:"
msgstr ""
"Moonbit "
"支持在顶层函数的顶部声明结构体/枚举/newtype，这些类型仅在当前顶层函数中可见。这些本地类型可以使用顶层函数的泛型参数，但不能引入额外的泛型参数。本地类型可以使用"
" derive 派生方法，但不能手动定义额外的方法。例如："

#: ../../language/fundamentals.md:1129
msgid ""
"fn toplevel[T: Show](x: T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a: (String, T)\n"
"  } derive(Show)\n"
"  type LocalNewtype T derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1135
msgid "Currently, local types do not support being declared as error types."
msgstr "目前，本地类型不支持声明为错误类型。"

#: ../../language/fundamentals.md:1137
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../language/fundamentals.md:1139
msgid ""
"Pattern matching allows us to match on specific pattern and bind data "
"from data structures."
msgstr "模式匹配允许我们匹配特定模式并从数据结构中绑定数据。"

#: ../../language/fundamentals.md:1141
msgid "Simple Patterns"
msgstr "简单模式"

#: ../../language/fundamentals.md:1143
msgid "We can pattern match expressions against"
msgstr "我们可以将表达式与以下内容进行模式匹配："

#: ../../language/fundamentals.md:1145
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr "字面量，例如布尔值、数字、字符、字符串等"

#: ../../language/fundamentals.md:1146
msgid "constants"
msgstr "常量"

#: ../../language/fundamentals.md:1147
msgid "structs"
msgstr "结构体"

#: ../../language/fundamentals.md:1148
msgid "enums"
msgstr "枚举"

#: ../../language/fundamentals.md:1149
msgid "arrays"
msgstr "数组"

#: ../../language/fundamentals.md:1150
msgid "maps"
msgstr "键值对"

#: ../../language/fundamentals.md:1151
msgid "JSONs"
msgstr "JSON"

#: ../../language/fundamentals.md:1153
msgid ""
"and so on. We can define identifiers to bind the matched values so that "
"they can be used later."
msgstr "等等。我们可以定义标识符来绑定匹配的值，以便稍后使用。"

#: ../../language/fundamentals.md:1155
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1162
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use "
"`..` to ignore remaining fields of struct or enum, or array (see [array "
"pattern](#array-pattern))."
msgstr ""
"我们可以使用 `_` 作为我们不关心的值的通配符，并使用 `..` 忽略结构体或枚举的剩余字段，或数组（参见 [数组模式](#array-"
"pattern)）。"

#: ../../language/fundamentals.md:1164
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~: String, payload~ : T)\n"
"}\n"
"\n"
"fn match_point[T](p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1171
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to "
"match several cases at once. A variable name can only be bound once in a "
"single pattern, and the same set of variables should be bound on both "
"sides of `|` patterns."
msgstr ""
"我们可以使用 `as` 为某些模式命名，可以使用 `|` 一次匹配多个情况。在单个模式中，变量名只能绑定一次，并且在 `|` "
"模式的两侧应绑定相同的变量集。"

#: ../../language/fundamentals.md:1173
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1180
msgid "Array Pattern"
msgstr "数组模式"

#: ../../language/fundamentals.md:1182
msgid ""
"For `Array`, `FixedArray` and `ArrayView`, MoonBit allows using array "
"pattern."
msgstr "对于 `Array`、`FixedArray` 和 `ArrayView`，MoonBit 允许使用数组模式。"

#: ../../language/fundamentals.md:1184
msgid "Array pattern have the following forms:"
msgstr "数组模式有以下形式："

#: ../../language/fundamentals.md:1186
msgid "`[]` : matching for an empty data structure"
msgstr "`[]`：匹配空数据结构"

#: ../../language/fundamentals.md:1187
msgid "`[pa, pb, pc]` : matching for known number of elements, 3 in this example"
msgstr "`[pa, pb, pc]`：匹配已知数量的元素，在此示例中为 3 个"

#: ../../language/fundamentals.md:1188
msgid ""
"`[pa, ..]` : matching for known number of elements, followed by unknown "
"number of elements"
msgstr "`[pa, ..]`：匹配已知数量的元素，后跟未知数量的元素"

#: ../../language/fundamentals.md:1189
msgid ""
"`[.., pa]` : matching for known number of elements, preceded by unknown "
"number of elements"
msgstr "`[.., pa]`：匹配已知数量的元素，前面是未知数量的元素"

#: ../../language/fundamentals.md:1191
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  if ary is [a, b, ..] && a == 1 && b == 2 {\n"
"    inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  } else {\n"
"    fail!(\"\")\n"
"  }\n"
"  guard let [.., a, b] = ary else {\n"
"    _ => fail!(\"\")\n"
"  }\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1197
msgid "Range Pattern"
msgstr "范围模式"

#: ../../language/fundamentals.md:1198
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the"
" value falls in a specific range."
msgstr "对于内置整数类型和 `Char`，MoonBit 允许匹配值是否落在特定范围内。"

#: ../../language/fundamentals.md:1200
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the "
"upper bound is exclusive, and `..=` means inclusive upper bound. `a` and "
"`b` can be one of:"
msgstr ""
"范围模式的形式为 `a..<b` 或 `a..=b`，其中 `..<` 表示上限是排他的，`..=` 表示包含上限。`a` 和 `b` "
"可以是以下之一："

#: ../../language/fundamentals.md:1203
msgid "literal"
msgstr "字面量"

#: ../../language/fundamentals.md:1204
msgid "named constant declared with `const`"
msgstr "使用 `const` 声明的常量"

#: ../../language/fundamentals.md:1205
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr "`_`，表示此模式在此侧没有限制"

#: ../../language/fundamentals.md:1207
msgid "Here are some examples:"
msgstr "以下是一些示例："

#: ../../language/fundamentals.md:1209
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1216
msgid "Map Pattern"
msgstr "Map 模式"

#: ../../language/fundamentals.md:1218
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a "
"map pattern, the `key : value` syntax will match if `key` exists in the "
"map, and match the value of `key` with pattern `value`. The `key? : "
"value` syntax will match no matter `key` exists or not, and `value` will "
"be matched against `map[key]` (an optional)."
msgstr ""
"MoonBit 允许在类似 map 的数据结构上方便地进行匹配。在 map 模式内，`key : value` 语法将在 map 中存在 "
"`key` 时匹配，并将 `key` 的值与模式 `value` 匹配。`key? : value` 语法将无论 `key` "
"是否存在都匹配，`value` 将与 `map[key]`（一个可选项）匹配。"

#: ../../language/fundamentals.md:1222
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _, .. } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" "
"exists in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""
"match map {\n"
"  // 仅在 `map` 中存在 \"b\" 时匹配\n"
"  { \"b\": _, .. } => ...\n"
"  // 仅在 `map` 中不存在 \"b\" 且 \"a\" 存在于 `map` 时匹配。\n"
"  // 匹配时，将 `map` 中的 \"a\" 的值绑定到 `x`\n"
"  { \"b\"? : None, \"a\": x, .. } => ...\n"
"  // 编译器报告缺失的情况：{ \"b\"? : None, \"a\"? : None }\n"
"}\n"

#: ../../language/fundamentals.md:1229
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and"
" trait](./methods.md))."
msgstr ""
"要使用 map 模式匹配数据类型 `T`，`T` 必须具有某种类型 `K` 和 `V` 的方法 `op_get(Self, K) -> "
"Option[V]`（请参见 [方法和特征](./methods.md)）。"

#: ../../language/fundamentals.md:1230
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr "目前，map 模式的键部分必须是字面量或常量"

#: ../../language/fundamentals.md:1231
msgid ""
"Map patterns are always open: the unmatched keys are silently ignored, "
"and `..` needs to be added to identify this nature"
msgstr "Map 模式始终是开放的：未匹配的键会被静默忽略，并且需要添加 `..` 以显示这一点"

#: ../../language/fundamentals.md:1232
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched"
" at most once"
msgstr "Map 模式将编译为高效的代码：每个键最多只会被获取一次"

#: ../../language/fundamentals.md:1234
msgid "Json Pattern"
msgstr "Json 模式"

#: ../../language/fundamentals.md:1236
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr "当匹配的值具有类型 `Json` 时，可以直接使用字面量模式，以及构造函数："

#: ../../language/fundamentals.md:1238
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports, .. } => ...\n"
"  { \"version\": Number(i), \"import\": Array(imports), ..} => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1245
msgid "Generics"
msgstr "泛型"

#: ../../language/fundamentals.md:1247
msgid ""
"Generics are supported in top-level function and data type definitions. "
"Type parameters can be introduced within square brackets. We can rewrite "
"the aforementioned data type `List` to add a type parameter `T` to obtain"
" a generic version of lists. We can then define generic functions over "
"lists like `map` and `reduce`."
msgstr ""
"泛型在顶层函数和数据类型定义中受支持。可以在方括号内引入类型参数。我们可以重写上述数据类型 `List`，添加类型参数 `T` "
"以获得列表的通用版本。然后，我们可以定义列表上的通用函数，如 `map` 和 `reduce`。"

#: ../../language/fundamentals.md:1249
msgid ""
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1253
msgid "Special Syntax"
msgstr "特殊语法"

#: ../../language/fundamentals.md:1255
msgid "Pipe operator"
msgstr "管道运算符"

#: ../../language/fundamentals.md:1257
msgid ""
"MoonBit provides a convenient pipe operator `|>`, which can be used to "
"chain regular function calls:"
msgstr "moonbit提供了一个方便的管道运算符`|>`，可以用于链接常规函数调用："

#: ../../language/fundamentals.md:1259
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> Array::push(5) // <=> Array::push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals.md:1266
msgid "Cascade Operator"
msgstr "级联运算符"

#: ../../language/fundamentals.md:1268
msgid ""
"The cascade operator `..` is used to perform a series of mutable "
"operations on the same value consecutively. The syntax is as follows:"
msgstr "级联运算符`..`用于连续对同一值执行一系列可变操作。 语法如下："

#: ../../language/fundamentals.md:1271
msgid "x..f()\n"
msgstr ""

#: ../../language/fundamentals.md:1278
msgid "`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`."
msgstr "`x..f()..g()` 等价于 `{x.f(); x.g(); x}`。"

#: ../../language/fundamentals.md:1280
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has "
"methods like `write_string`, `write_char`, `write_object`, etc., we often"
" need to perform a series of operations on the same `StringBuilder` "
"value:"
msgstr "考虑以下情况：对于具有诸如`write_string`，`write_char`，`write_object`等方法的`StringBuilder`类型，我们经常需要对同一`StringBuilder`值执行一系列操作："

#: ../../language/fundamentals.md:1284
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1291
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed "
"to return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used"
" for consecutive operations without the need to modify the return type of"
" the methods."
msgstr ""
"为了避免重复输入`builder`，其方法通常设计为返回`self`本身，允许使用`.`运算符链接操作。 "
"为了区分不可变和可变操作，在MoonBit中，对于所有返回`Unit`的方法，可以使用级联运算符进行连续操作，而无需修改方法的返回类型。"

#: ../../language/fundamentals.md:1297
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1304
msgid "Is Expression"
msgstr "Is 表达式"

#: ../../language/fundamentals.md:1306
msgid ""
"The `is` expression tests whether a value conforms to a specific pattern."
" It returns a `Bool` value and can be used anywhere a boolean value is "
"expected, for example:"
msgstr "`is` 表达式测试值是否符合特定模式。它返回一个 `Bool` 值，并可以在期望布尔值的任何地方使用，例如："

#: ../../language/fundamentals.md:1310
msgid ""
"fn is_none[T](x : T?) -> Bool {\n"
"  x is None\n"
"}\n"
"\n"
"fn start_with_lower_letter(s: String) -> Bool {\n"
"  s is ['a'..='z', ..]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1317
msgid ""
"Pattern binders introduced by `is` expressions can be used in the "
"following contexts:"
msgstr "通过 `is` 表达式绑定的标识符可以在以下的上下文中使用："

#: ../../language/fundamentals.md:1320
msgid ""
"In boolean AND expressions (`&&`): binders introduced in the left-hand "
"expression can be used in the right-hand expression"
msgstr "在与表达式（`&&`）中：左侧表达式中绑定的标识符可以在右侧表达式中使用"

#: ../../language/fundamentals.md:1324
msgid ""
"fn f(x : Int?) -> Bool {\n"
"  x is Some(v) && v >= 0\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1331
msgid ""
"In the first branch of `if` expression: if the condition is a sequence of"
" boolean expressions `e1 && e2 && ...`, the binders introduced by the "
"`is` expression can be used in the branch where the condition evaluates "
"to `true`."
msgstr ""
"在 `if` 的第一个分支中：如果条件是一系列布尔表达式 `e1 && e2 && ...`，则可以在条件为真的分支中使用 "
"`is` 表达式中绑定的标识符。"

#: ../../language/fundamentals.md:1335
msgid ""
"fn g(x : Array[Int?]) -> Unit {\n"
"  if x is [v, .. rest] && v is Some(i) && i is 0..=10 {\n"
"    println(v)\n"
"    println(i)\n"
"    println(rest)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1342
msgid "In the following statements of a `guard` condition:"
msgstr "下面举一个在 `guard` 中使用的情况："

#: ../../language/fundamentals.md:1344
msgid ""
"fn h(x : Int?) -> Unit {\n"
"  guard x is Some(v) \n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1351
msgid "In the body of a `while` loop:"
msgstr "在 `while` 循环中的使用："

#: ../../language/fundamentals.md:1353
msgid ""
"fn i(x : Int?) -> Unit {\n"
"  let mut m = x\n"
"  while m is Some(v) {\n"
"    println(v)\n"
"    m = None\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1360
msgid "TODO syntax"
msgstr "TODO 语法"

#: ../../language/fundamentals.md:1362
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of"
" code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr "`todo`语法(`...`)是一种特殊构造，用于标记尚未实现或用于未来功能的占位符代码段。 例如："

#: ../../language/fundamentals.md:1364
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/index.md:1
msgid "MoonBit Language"
msgstr "MoonBit（月兔）编程语言"

#: ../../language/index.md:3
msgid ""
"MoonBit is an end-to-end programming language toolchain for cloud and "
"edge computing using WebAssembly. The IDE environment is available at "
"[https://try.moonbitlang.com](https://try.moonbitlang.com) without any "
"installation; it does not rely on any server either."
msgstr ""
"MoonBit是一个用于云和边缘计算的 WebAssembly 端到端编程语言工具链。无需安装即可在 "
"[https://try.moonbitlang.cn](https://try.moonbitlang.cn) 上使用 IDE "
"环境；它也不依赖任何服务器。"

#: ../../language/index.md:5
msgid "**Status and aimed timeline**"
msgstr "**状态**"

#: ../../language/index.md:7
msgid "MoonBit is currently in beta-preview. We expect to reach 1.0 in 2025."
msgstr "MoonBit 目前处于 beta-preview 阶段。我们预计在 2025 年达到 1.0 版本。"

#: ../../language/index.md:9
msgid ""
"When MoonBit reaches beta, it means any backwards-incompatible changes "
"will be seriously evaluated and MoonBit _can_ be used in production(very "
"rare compiler bugs). MoonBit is developed by a talented full time team "
"who had extensive experience in building language toolchains, so we will "
"grow much faster than the typical language ecosystem, you won't wait long"
" to use MoonBit in your production."
msgstr ""
"当 MoonBit 达到 beta 阶段后，任何不兼容的更改将受到严格评估，MoonBit "
"将可以用于生产（只有非常罕见的编译器错误）。MoonBit "
"由一支才华横溢的全职团队开发，他们在构建语言工具链方面拥有丰富的经验，因此我们将比典型的语言生态系统发展得更快，您不必等太久就可以在生产中使用 "
"MoonBit。"

#: ../../language/index.md:11
msgid "**Main advantages**"
msgstr "**主要优势**"

#: ../../language/index.md:13
msgid "Generate significantly smaller WASM output than any existing solutions."
msgstr "生成比现有解决方案明显更小的 Wasm 文件。"

#: ../../language/index.md:14
msgid "Much faster runtime performance."
msgstr "更高的运行时性能。"

#: ../../language/index.md:15
msgid "State of the art compile-time performance."
msgstr "先进的编译时性能。"

#: ../../language/index.md:16
msgid "Simple but practical, data-oriented language design."
msgstr "简单且实用的数据导向语言设计。"

#: ../../language/index.md:19
msgid "[Download this section in Markdown](path:/download/language/summary.md)"
msgstr "[下载本章节的 Markdown 版本](path:/download/language/summary.md)"

#: ../../language/introduction.md:1
msgid "Introduction"
msgstr "概述"

#: ../../language/introduction.md:3
msgid "A MoonBit program consists of top-level definitions including:"
msgstr "一个 MoonBit 程序由顶层定义组成，包括："

#: ../../language/introduction.md:5
msgid "type definitions"
msgstr "类型定义"

#: ../../language/introduction.md:6
msgid "function definitions"
msgstr "函数定义"

#: ../../language/introduction.md:7
msgid "constant definitions and variable bindings"
msgstr "常数定义和变量绑定"

#: ../../language/introduction.md:8
msgid "`init` functions, `main` function and/or `test` blocks."
msgstr "`init` 函数，`main` 函数和/或 `test` 块。"

#: ../../language/introduction.md:10
msgid "Expressions and Statements"
msgstr "表达式和语句"

#: ../../language/introduction.md:12
msgid ""
"MoonBit distinguishes between statements and expressions. In a function "
"body, only the last clause should be an expression, which serves as a "
"return value. For example:"
msgstr "MoonBit 区分语句和表达式。在函数体中，只有最后一个子句应该是一个表达式，它作为返回值。例如："

#: ../../language/introduction.md:14
msgid ""
"fn foo() -> Int {\n"
"  let x = 1\n"
"  x + 1\n"
"}\n"
"\n"
"fn bar() -> Int {\n"
"  let x = 1\n"
"  //! x + 1\n"
"  x + 2\n"
"}"
msgstr ""

#: ../../language/introduction.md:28
msgid "Expressions include:"
msgstr "表达式包括："

#: ../../language/introduction.md:30
msgid ""
"Value literals (e.g. Boolean values, numbers, characters, strings, "
"arrays, tuples, structs)"
msgstr "值字面量（例如布尔值、数字、字符、字符串、数组、元组、结构体）"

#: ../../language/introduction.md:31
msgid "Arithmetical, logical, or comparison operations"
msgstr "算术、逻辑或比较操作"

#: ../../language/introduction.md:32
msgid ""
"Accesses to array elements (e.g. `a[0]`), struct fields (e.g `r.x`), "
"tuple components (e.g. `t.0`), etc."
msgstr "访问数组元素（例如 `a[0]`），结构体字段（例如 `r.x`），元组组件（例如 `t.0`）等。"

#: ../../language/introduction.md:33
msgid "Variables and (capitalized) enum constructors"
msgstr "变量和枚举构造器"

#: ../../language/introduction.md:34
msgid "Anonymous local function definitions"
msgstr "匿名本地函数定义"

#: ../../language/introduction.md:35
msgid "`match`, `if`, `loop` expressions, etc."
msgstr "`match`，`if`，`loop` 表达式等。"

#: ../../language/introduction.md:37
msgid "Statements include:"
msgstr "语句包括："

#: ../../language/introduction.md:39
msgid "Named local function definitions"
msgstr "命名本地函数定义"

#: ../../language/introduction.md:40
msgid "Local variable bindings"
msgstr "本地变量绑定"

#: ../../language/introduction.md:41
msgid "Assignments"
msgstr "赋值"

#: ../../language/introduction.md:42
msgid "`return` statements"
msgstr "`return` 语句"

#: ../../language/introduction.md:43
msgid "Any expression whose return type is `Unit`, (e.g. `ignore`)"
msgstr "任何返回类型为 `Unit` 的表达式（例如 `ignore`）"

#: ../../language/introduction.md:45
msgid ""
"A code block can contain multiple statements and one expression, and the "
"value of the expression is the value of the code block."
msgstr "代码块可以包含多个语句和一个表达式，表达式的值是代码块的值。"

#: ../../language/introduction.md:47
msgid "Variable Binding"
msgstr "变量绑定"

#: ../../language/introduction.md:49
msgid ""
"A variable can be declared as mutable or immutable using `let mut` or "
"`let`, respectively. A mutable variable can be reassigned to a new value,"
" while an immutable one cannot."
msgstr "变量可以使用 `let mut` 或 `let` 声明为可变或不可变。可变变量可以重新赋值为新值，而不可变变量则不能。"

#: ../../language/introduction.md:51
msgid "A constant can only be declared at top level and cannot be changed."
msgstr "常量只能在顶层声明，不能更改。"

#: ../../language/introduction.md:53
msgid ""
"let zero = 0\n"
"\n"
"const ZERO = 0\n"
"\n"
"fn main {\n"
"  //! const ZERO = 0 \n"
"  let mut i = 10\n"
"  i = 20\n"
"  println(i + zero + ZERO)\n"
"}"
msgstr ""

#: ../../language/introduction.md:68
msgid "A top level variable binding"
msgstr "顶层变量绑定"

#: ../../language/introduction.md:69
msgid ""
"requires **explicit** type annotation (unless defined using literals such"
" as string, byte or numbers)"
msgstr "需要 **显式** 类型注释（除非使用字符串、字节或数字等字面量定义）"

#: ../../language/introduction.md:70
msgid "can't be mutable (use `Ref` instead)"
msgstr "不能是可变的（使用 `Ref` 代替）"

#: ../../language/introduction.md:74
msgid "Naming conventions"
msgstr "命名约定"

#: ../../language/introduction.md:76
msgid ""
"Variables, functions should start with lowercase letters `a-z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with snake_case."
msgstr ""
"变量、函数应以小写字母 `a-z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 snake_case"
" 命名。"

#: ../../language/introduction.md:79
msgid ""
"Constants, types should start with uppercase letters `A-Z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with PascalCase or SCREAMING_SNAKE_CASE."
msgstr ""
"常量、类型应以大写字母 `A-Z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 PascalCase"
" 或 SCREAMING_SNAKE_CASE 命名。"

#: ../../language/introduction.md:82
msgid "Program entrance"
msgstr "程序入口"

#: ../../language/introduction.md:84
msgid "`init` and `main`"
msgstr "`init` 和 `main`"

#: ../../language/introduction.md:85
msgid ""
"There is a specialized function called `init` function. The `init` "
"function is special:"
msgstr "有一个专门的函数称为 `init` 函数。`init` 函数是特殊的："

#: ../../language/introduction.md:87
msgid "It has no parameter list nor return type."
msgstr "它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:88
msgid "There can be multiple `init` functions in the same package."
msgstr "同一个包中可以有多个 `init` 函数。"

#: ../../language/introduction.md:89
msgid ""
"An `init` function can't be explicitly called or referred to by other "
"functions.  Instead, all `init` functions will be implicitly called when "
"initializing a package. Therefore, `init` functions should only consist "
"of statements."
msgstr "`init` 函数不能被显式调用或被其他函数引用。相反，所有 `init` 函数将在初始化包时隐式调用。因此，`init` 函数应该只包含语句。"

#: ../../language/introduction.md:92
msgid ""
"fn init {\n"
"  let x = 1\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:100
msgid ""
"There is another specialized function called `main` function. The `main` "
"function is the main entrance of the program, and it will be executed "
"after the initialization stage."
msgstr "还有另一个专门的函数称为 `main` 函数。`main` 函数是程序的主入口，它将在初始化阶段之后执行。"

#: ../../language/introduction.md:102
msgid "Same as the `init` function, it has no parameter list nor return type."
msgstr "与 `init` 函数相同，它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:104
msgid ""
"fn main {\n"
"  let x = 2\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:112
msgid "The previous two code snippets will print the following at runtime:"
msgstr "前两个代码片段将在运行时打印以下内容："

#: ../../language/introduction.md:114
msgid ""
"1\n"
"2\n"
msgstr ""

#: ../../language/introduction.md:119
msgid ""
"Only packages that are `main` packages can define such `main` function. "
"Check out [build system tutorial](/toolchain/moon/tutorial) for detail."
msgstr "只有 `main` 包的包才能定义这样的 `main` 函数。查看[构建系统教程](/toolchain/moon/tutorial)了解详情。"

#: ../../language/introduction.md:121
msgid "moon.pkg.json"
msgstr ""

#: ../../language/introduction.md:121
msgid ""
"{\n"
"  \"is-main\": true\n"
"}"
msgstr ""

#: ../../language/introduction.md:126
msgid "`test`"
msgstr ""

#: ../../language/introduction.md:128
msgid ""
"There's also a top-level structure called `test` block. A `test` block "
"defines inline tests, such as:"
msgstr "还有一个称为 `test` 块的顶级结构。`test` 块定义内联测试，例如："

#: ../../language/introduction.md:130 ../../language/tests.md:11
msgid ""
"test \"test_name\" {\n"
"  assert_eq!(1 + 1, 2)\n"
"  assert_eq!(2 + 2, 4)\n"
"  inspect!([1, 2, 3], content=\"[1, 2, 3]\")\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:136
msgid ""
"The following contents will use `test` block and `main` function to "
"demonstrate the execution result, and we assume that all the `test` "
"blocks pass unless stated otherwise."
msgstr "以下内容将使用 `test` 块和 `main` 函数来演示执行结果。我们假设所有 `test` 块都通过测试，除非另有说明。"

#: ../../language/methods.md:1
msgid "Method and Trait"
msgstr "方法和特征"

#: ../../language/methods.md:3
msgid "Method system"
msgstr "方法系统"

#: ../../language/methods.md:5
msgid ""
"MoonBit supports methods in a different way from traditional object-"
"oriented languages. A method in MoonBit is just a toplevel function "
"associated with a type constructor. There are two ways to define a "
"method:"
msgstr "MoonBit 支持方法的方式与传统的面向对象语言不同。MoonBit 中的方法只是与类型构造器关联的顶层函数。方法可以用两种方式来定义："

#: ../../language/methods.md:8
msgid ""
"`fn method_name(self : SelfType, ..)`, where the method belongs to "
"`SelfType`. The name of the first parameter must be `self` here"
msgstr ""
"`fn method_name(self : SelfType, ..)`，如此定义的方法属于类型 `SelfType`。方法的第一个参数必须叫作"
" `self`"

#: ../../language/methods.md:9
msgid ""
"`fn SelfTypeName::method_name(...)`, where the method belongs to "
"`SelfTypeName`"
msgstr "`fn SelfTypeName::method_name(...)`，如此定义的方法属于类型 `SelfTypeName`"

#: ../../language/methods.md:11
msgid ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn length[X](self : List[X]) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"fn List::length_qualified[X](xs : List[X]) -> Int {\n"
"  ...\n"
"}\n"
msgstr ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn length[X](self : List[X]) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"fn List::length_qualified[X](xs : List[X]) -> Int {\n"
"  ...\n"
"}\n"

#: ../../language/methods.md:17
msgid ""
"The difference between these two syntax is: the syntax `fn "
"method_name(self : T, ..)` defines a regular function. So the defined "
"method can be involked directly, just like regular functions. In the `fn "
"T::method_name(..)` syntax, however, the method is defined in the small "
"namespace `T`, and must be involked using qualified syntax "
"`T::method_name(..)`:"
msgstr ""
"这两种定义方式的区别是：`fn method_name(self : T, ..)` "
"定义出的方法是一个普通的函数，因此它可以像普通函数一样直接调用。`fn T::method_name(..)` 定义出的方法处在命名空间 `T` "
"内，因此调用它时，必须使用 `T::method_name(..)` 的形式。"

#: ../../language/methods.md:23
msgid ""
"  let l : List[Int] = Nil\n"
"  println(length(l))\n"
"  println(List::length_qualified(l))\n"
msgstr ""

#: ../../language/methods.md:29
msgid ""
"Unlike regular functions, methods defined using the "
"`TypeName::method_name` syntax support overloading: different types can "
"define methods of the same name, because each method lives in a different"
" name space:"
msgstr "用 `TypeName::method_name` 形式定义出的方法支持重载：由于不同类型的方法处于不同的命名空间中，不同的类型可以定义同名的方法。"

#: ../../language/methods.md:32
msgid ""
"struct T1 {\n"
"  x1 : Int\n"
"}\n"
"\n"
"fn T1::default() -> T1 {\n"
"  { x1: 0 }\n"
"}\n"
"\n"
"struct T2 {\n"
"  x2 : Int\n"
"}\n"
"\n"
"fn T2::default() -> T2 {\n"
"  { x2: 0 }\n"
"}\n"
"\n"
"test {\n"
"  let t1 = T1::default()\n"
"  let t2 = T2::default()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:39
msgid ""
"When the first parameter of a method is also the type it belongs to, "
"methods can be called using dot syntax `x.method(...)`. MoonBit "
"automatically finds the correct method based on the type of `x`, there is"
" no need to write the type name and even the package name of the method:"
msgstr ""
"当方法的第一个参数也是它所属的类型时，可以使用点语法 `x.method(...)` 调用方法。MoonBit 根据 `x` "
"的类型自动找到正确的方法，无需编写方法的类型名称甚至包名称："

#: ../../language/methods.md:41
msgid ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn concat[X](self : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn concat[X](self : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"

#: ../../language/methods.md:47
msgid "using package with alias list"
msgstr "以别名 list 使用包"

#: ../../language/methods.md:47
msgid ""
"  // assume `xs` is a list of lists, all the following three lines are "
"equivalent\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"
msgstr ""
"  // 假设 `xs` 是一个列表的列表，那么下面三种写法是等价的：\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"

#: ../../language/methods.md:54
msgid "API design guideline"
msgstr "接口设计指南"

#: ../../language/methods.md:56
msgid ""
"Since there are two ways to define methods, and both allow dot syntax, a "
"natural question is which syntax to choose when designing the API of a "
"package. The rule here is:"
msgstr "既然有两种不同的方式来定义方法，并且两种方式都能使用 `.` 语法调用，那么在设计一个包的接口时，应该如何选择呢？MoonBit 推荐的选择是："

#: ../../language/methods.md:60
msgid ""
"if the package exports only one primary type, or if a method is "
"intuitively unambiguous in the package, use the `fn f(self : T, ..)` "
"syntax"
msgstr "如果一个包只有一个主要的公开类型，或者某个方法在这个包的语境下没有歧义，使用 `fn f(self : T, ..)` 的形式来定义方法"

#: ../../language/methods.md:63
msgid "otherwise, use the qualified `fn T::f(..)` syntax"
msgstr "否则，使用 `fn T::f(..)` 来定义方法，以显式消除歧义"

#: ../../language/methods.md:65
msgid "Operator Overloading"
msgstr "运算符重载"

#: ../../language/methods.md:67
msgid ""
"MoonBit supports operator overloading of builtin operators via methods. "
"The method name corresponding to a operator `<op>` is `op_<op>`. For "
"example:"
msgstr "MoonBit 支持通过方法对内置运算符进行运算符重载。与运算符 `<op>` 对应的方法名是 `op_<op>`。例如："

#: ../../language/methods.md:69
msgid ""
"struct T {\n"
"  x : Int\n"
"}\n"
"\n"
"fn op_add(self : T, other : T) -> T {\n"
"  { x: self.x + other.x }\n"
"}\n"
"\n"
"test {\n"
"  let a = { x: 0 }\n"
"  let b = { x: 2 }\n"
"  assert_eq!((a + b).x, 2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:75
msgid "Another example about `op_get` and `op_set`:"
msgstr "关于 `op_get` 和 `op_set` 的另一个例子："

#: ../../language/methods.md:77
msgid ""
"struct Coord {\n"
"  mut x : Int\n"
"  mut y : Int\n"
"} derive(Show)\n"
"\n"
"fn op_get(self : Coord, key : String) -> Int {\n"
"  match key {\n"
"    \"x\" => self.x\n"
"    \"y\" => self.y\n"
"  }\n"
"}\n"
"\n"
"fn op_set(self : Coord, key : String, val : Int) -> Unit {\n"
"  match key {\n"
"    \"x\" => self.x = val\n"
"    \"y\" => self.y = val\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/methods.md:83
msgid ""
"fn main {\n"
"  let c = { x: 1, y: 2 }\n"
"  println(c)\n"
"  println(c[\"y\"])\n"
"  c[\"x\"] = 23\n"
"  println(c)\n"
"  println(c[\"x\"])\n"
"}\n"
msgstr ""

#: ../../language/methods.md:91
msgid ""
"{x: 1, y: 2}\n"
"2\n"
"{x: 23, y: 2}\n"
"23\n"
msgstr ""

#: ../../language/methods.md:95
msgid "Currently, the following operators can be overloaded:"
msgstr "目前，可以重载以下运算符："

#: ../../language/methods.md:91
msgid "Operator Name"
msgstr "运算符名称"

#: ../../language/methods.md:91
msgid "Recommended Signature"
msgstr ""

#: ../../language/methods.md:91
msgid "`(A, A) -> X`"
msgstr ""

#: ../../language/methods.md:91
msgid "`(A, A) -> Bool` (Required by trait `Eq`)"
msgstr ""

#: ../../language/methods.md:91
msgid "`(A, B) -> X`"
msgstr ""

#: ../../language/methods.md:91
msgid "`(A) -> X`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_]` (get item)"
msgstr "`_[_]`（获取项）"

#: ../../language/methods.md:91
msgid "`_[_] = _` (set item)"
msgstr "`_[_] = _`（设置项）"

#: ../../language/methods.md:91
msgid "`(A, B, C) -> Unit`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_:_]` (view)"
msgstr "`_[_:_]`（视图）"

#: ../../language/methods.md:91
msgid "`(A, start? : B, end? : C) -> X`"
msgstr ""

#: ../../language/methods.md:115
msgid ""
"By implementing `op_as_view` method, you can create a view for a user-"
"defined type. Here is an example:"
msgstr "通过实现 `op_as_view` 方法，可以为用户定义的类型创建视图。以下是一个例子："

#: ../../language/methods.md:117
msgid ""
"type DataView String\n"
"\n"
"struct Data {}\n"
"\n"
"fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> "
"DataView {\n"
"  \"[\\{start}, \\{end.or(100)})\"\n"
"}\n"
"\n"
"test {\n"
"  let data = Data::{  }\n"
"  inspect!(data[:]._, content=\"[0, 100)\")\n"
"  inspect!(data[2:]._, content=\"[2, 100)\")\n"
"  inspect!(data[:5]._, content=\"[0, 5)\")\n"
"  inspect!(data[2:5]._, content=\"[2, 5)\")\n"
"}\n"
msgstr ""

#: ../../language/methods.md:123
msgid "Trait system"
msgstr "Trait（特征）系统"

#: ../../language/methods.md:125
msgid ""
"MoonBit features a structural trait system for overloading/ad-hoc "
"polymorphism. Traits declare a list of operations, which must be supplied"
" when a type wants to implement the trait. Traits can be declared as "
"follows:"
msgstr "MoonBit 具有用于重载/特殊多态的结构特征系统。特征声明一系列操作，当类型想要实现特征时，必须提供这些操作。特征可以如下声明："

#: ../../language/methods.md:127
msgid ""
"pub(open) trait I {\n"
"  method_(Int) -> Int\n"
"  method_with_label(Int, label~: Int) -> Int\n"
"  //! method_with_label(Int, label?: Int) -> Int\n"
"}\n"
msgstr ""

#: ../../language/methods.md:133
msgid ""
"In the body of a trait definition, a special type `Self` is used to refer"
" to the type that implements the trait."
msgstr "在特征定义的主体中，使用特殊类型 `Self` 来引用实现特征的类型。"

#: ../../language/methods.md:135
msgid "Extending traits"
msgstr "扩展特征"

#: ../../language/methods.md:137
msgid "A trait can depend on other traits, for example:"
msgstr "特征（子特征）可以依赖于其他特征（超特征），例如："

#: ../../language/methods.md:139
msgid ""
"pub(open) trait Position {\n"
"  pos(Self) -> (Int, Int)\n"
"}\n"
"pub(open) trait Draw {\n"
"  draw(Self) -> Unit\n"
"}\n"
"\n"
"pub(open) trait Object : Position + Draw {}\n"
msgstr ""

#: ../../language/methods.md:145
msgid ""
"To implement the sub trait, one will have to implement the super traits, "
"and the methods defined in the sub trait."
msgstr "要实现子特征，必须实现子特征和所有超特征中定义的方法。"

#: ../../language/methods.md:148
msgid "Implementing traits"
msgstr "实现特征"

#: ../../language/methods.md:150
msgid ""
"To implement a trait, a type must provide all the methods required by the"
" trait."
msgstr "要实现特征，类型必须提供特征所需的所有方法。"

#: ../../language/methods.md:152
msgid ""
"This allows types to implement a trait implicitly, hence allowing "
"different packages to work together without seeing or depending on each "
"other. For example, the following trait is automatically implemented for "
"builtin number types such as `Int` and `Double`:"
msgstr ""
"这使得类型可以隐式满足特征，从而允许不同的包在不看到或依赖于彼此的情况下运行。例如，内置数字类型（如 `Int` 和 "
"`Double`）自动满足了以下的特征："

#: ../../language/methods.md:155
msgid ""
"pub(open) trait Number {\n"
"  op_add(Self, Self) -> Self\n"
"  op_mul(Self, Self) -> Self\n"
"}\n"
msgstr ""

#: ../../language/methods.md:161
msgid ""
"**Explicit implementation** for trait methods can be provided via the "
"syntax `impl Trait for Type with method_name(...) { ... }`, for example:"
msgstr ""
"**显式实现**特征方法可以通过语法 `impl Trait for Type with method_name(...) { ... }` "
"提供，例如："

#: ../../language/methods.md:163
msgid ""
"pub(open) trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"pub impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// trait implementation with type parameters.\n"
"// `[X : Show]` means the type parameter `X` must implement `Show`,\n"
"// this will be covered later.\n"
"pub impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ..."
" }\n"
msgstr ""
"pub(open) trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"pub impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// 使用类型参数实现特征。\n"
"// `[X : Show]` 意味着类型参数 `X` 必须实现 `Show`，\n"
"// 我们将稍后介绍。\n"
"pub impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"

#: ../../language/methods.md:169
msgid ""
"Type annotation can be omitted for trait `impl`: MoonBit will "
"automatically infer the type based on the signature of `Trait::method` "
"and the self type."
msgstr "`impl` 实现的类型注释可以省略：MoonBit 将根据 `Trait::method` 的签名和 self 类型自动推断类型。"

#: ../../language/methods.md:171
msgid ""
"The author of the trait can also define **default implementations** for "
"some methods in the trait, for example:"
msgstr "特征的作者还可以为特征中的某些方法定义**默认实现**，例如："

#: ../../language/methods.md:173
msgid ""
"pub(open) trait J {\n"
"  f(Self) -> Unit\n"
"  f_twice(Self) -> Unit\n"
"}\n"
"\n"
"impl J with f_twice(self) {\n"
"  self.f()\n"
"  self.f()\n"
"}\n"
msgstr ""

#: ../../language/methods.md:179
msgid ""
"Implementers of trait `I` don't have to provide an implementation for "
"`f_twice`: to implement `I`, only `f` is necessary. They can always "
"override the default implementation with an explicit `impl I for Type "
"with f_twice`, if desired, though."
msgstr ""
" `I` 的类型实现特征时不必为 `f_twice` 提供实现：要实现 `I`，只有 `f` 是必要的。如果需要，他们总是可以显式地用 `impl"
" I for Type with f_twice` 覆盖默认实现。"

#: ../../language/methods.md:182
msgid ""
"If an explicit `impl` or default implementation is not found, trait "
"method resolution falls back to regular methods."
msgstr "如果找不到显式的 `impl` 或默认实现，特征方法解析将回退到常规方法。"

#: ../../language/methods.md:184
msgid "Using traits"
msgstr "使用特征"

#: ../../language/methods.md:186
msgid ""
"When declaring a generic function, the type parameters can be annotated "
"with the traits they should implement, allowing the definition of "
"constrained generic functions. For example:"
msgstr "在声明泛型函数时，可以使用特征注释类型参数，来定义受约束的泛型函数。例如："

#: ../../language/methods.md:188
msgid ""
"fn square[N : Number](x : N) -> N {\n"
"  x * x // <=> x.op_mul(x)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:194
msgid ""
"Without the `Number` requirement, the expression `x * x` in `square` will"
" result in a method/operator not found error. Now, the function `square` "
"can be called with any type that implements `Number`, for example:"
msgstr ""
"如果没有 `Number` 要求，`square` 中的表达式 `x * x` 将产生方法/运算符未找到的错误。现在，函数 `square` "
"可以使用任何实现 `Number` 的类型调用，例如："

#: ../../language/methods.md:196
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Show)\n"
"\n"
"pub impl Number for Point with op_add(self, other) {\n"
"  { x: self.x + other.x, y: self.y + other.y }\n"
"}\n"
"\n"
"pub impl Number for Point with op_mul(self, other) {\n"
"  { x: self.x * other.x, y: self.y * other.y }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(square(2), 4)\n"
"  assert_eq!(square(1.5), 2.25)\n"
"  assert_eq!(square(Point::{ x: 2, y: 3 }), { x: 4, y: 9 })\n"
"}\n"
msgstr ""

#: ../../language/methods.md:202
msgid "Invoke trait methods directly"
msgstr "直接调用特征方法"

#: ../../language/methods.md:204
msgid ""
"Methods of a trait can be called directly via `Trait::method`. MoonBit "
"will infer the type of `Self` and check if `Self` indeed implements "
"`Trait`, for example:"
msgstr ""
"可以通过 `Trait::method` 直接调用特征的方法。MoonBit 将推断 `Self` 的类型，并检查 `Self` 是否确实实现了 "
"`Trait`，例如："

#: ../../language/methods.md:206
msgid ""
"test {\n"
"  assert_eq!(Show::to_string(42), \"42\")\n"
"  assert_eq!(Compare::compare(1.0, 2.5), -1)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:212
msgid ""
"Trait implementations can also be invoked via dot syntax, with the "
"following restrictions:"
msgstr "特征实现也可以通过点语法调用，但有以下限制："

#: ../../language/methods.md:214
msgid ""
"if a regular method is present, the regular method is always favored when"
" using dot syntax"
msgstr "如果存在常规方法，使用点语法时总是优先选择常规方法"

#: ../../language/methods.md:215
msgid ""
"only trait implementations that are located in the package of the self "
"type can be invoked via dot syntax"
msgstr "只有位于 self 类型的包中的特征实现才能通过点语法调用"

#: ../../language/methods.md:216
msgid ""
"if there are multiple trait methods (from different traits) with the same"
" name available, an ambiguity error is reported"
msgstr "如果有多个具有相同名称的特征方法（来自不同的特征）可用，将报告歧义错误"

#: ../../language/methods.md:217
msgid ""
"if neither of the above two rules apply, trait `impl`s in current package"
" will also be searched for dot syntax. This allows extending a foreign "
"type locally."
msgstr "如果上述两条规则都不适用，还将在当前包中搜索特征 `impl` 以进行点语法。这允许在本地扩展外部类型。"

#: ../../language/methods.md:219
msgid ""
"these `impl`s can only be called via dot syntax locally, even if they are"
" public."
msgstr "这些 `impl` 只能在本地通过点语法调用，即使它们是公开的。"

#: ../../language/methods.md:221
msgid ""
"The above rules ensures that MoonBit's dot syntax enjoys good property "
"while being flexible. For example, adding a new dependency never break "
"existing code with dot syntax due to ambiguity. These rules also make "
"name resolution of MoonBit extremely simple: the method called via dot "
"syntax must always come from current package or the package of the type!"
msgstr ""
"上述规则确保了 MoonBit 的点语法具有良好的特性，同时也具有灵活性。例如，由于歧义，添加新依赖关系永远不会破坏现有的点语法代码。这些规则还使"
" MoonBit 的名称解析非常简单：通过点语法调用的方法必须始终来自当前包或类型的包！"

#: ../../language/methods.md:226
msgid "Here's an example of calling trait `impl` with dot syntax:"
msgstr "以下是使用点语法调用特征 `impl` 的示例："

#: ../../language/methods.md:228
msgid ""
"struct MyCustomType {}\n"
"\n"
"pub impl Show for MyCustomType with output(self, logger) { ... }\n"
"\n"
"fn f() -> Unit {\n"
"  let x = MyCustomType::{  }\n"
"  let _ = x.to_string()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:234
msgid "Trait objects"
msgstr "特征对象"

#: ../../language/methods.md:236
msgid ""
"MoonBit supports runtime polymorphism via trait objects. If `t` is of "
"type `T`, which implements trait `I`, one can pack the methods of `T` "
"that implements `I`, together with `t`, into a runtime object via `t as "
"&I`. Trait object erases the concrete type of a value, so objects created"
" from different concrete types can be put in the same data structure and "
"handled uniformly:"
msgstr ""
"MoonBit 支持通过特征对象实现运行时多态。如果 `t` 是类型 `T`，它实现了特征 `I`，可以通过 `t as &I` 将实现 `I` "
"的 `T` 的方法与 `t` 一起打包到运行时对象中。特征对象擦除了值的具体类型，因此可以将从不同具体类型创建的对象放入相同的数据结构并统一处理："

#: ../../language/methods.md:243
msgid ""
"pub(open) trait Animal {\n"
"  speak(Self) -> String\n"
"}\n"
"\n"
"type Duck String\n"
"\n"
"fn Duck::make(name : String) -> Duck {\n"
"  Duck(name)\n"
"}\n"
"\n"
"fn speak(self : Duck) -> String {\n"
"  \"\\{self._}: quack!\"\n"
"}\n"
"\n"
"type Fox String\n"
"\n"
"fn Fox::make(name : String) -> Fox {\n"
"  Fox(name)\n"
"}\n"
"\n"
"fn Fox::speak(_self : Fox) -> String {\n"
"  \"What does the fox say?\"\n"
"}\n"
"\n"
"test {\n"
"  let duck1 = Duck::make(\"duck1\")\n"
"  let duck2 = Duck::make(\"duck2\")\n"
"  let fox1 = Fox::make(\"fox1\")\n"
"  let animals : Array[&Animal] = [\n"
"    duck1 as &Animal,\n"
"    duck2 as &Animal,\n"
"    fox1 as &Animal,\n"
"  ]\n"
"  inspect!(\n"
"    animals.map(fn(animal) { animal.speak() }),\n"
"    content=\n"
"      #|[\"duck1: quack!\", \"duck2: quack!\", \"What does the fox "
"say?\"]\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/methods.md:249
msgid ""
"Not all traits can be used to create objects. \"object-safe\" traits' "
"methods must satisfy the following conditions:"
msgstr "并非所有特征都可以用于创建对象。“对象安全” 特征的方法必须满足以下条件："

#: ../../language/methods.md:252
msgid "`Self` must be the first parameter of a method"
msgstr "`Self` 必须是方法的第一个参数"

#: ../../language/methods.md:253
msgid ""
"There must be only one occurrence of `Self` in the type of the method "
"(i.e. the first parameter)"
msgstr "方法的类型中只能出现一个 `Self` （即第一个参数）"

#: ../../language/methods.md:255
msgid ""
"Users can define new methods for trait objects, just like defining new "
"methods for structs and enums:"
msgstr "用户可以为特征对象定义新方法，就像为结构体和枚举定义新方法一样："

#: ../../language/methods.md:257
msgid ""
"pub(open) trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"pub(open) trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// use the new method to simplify code\n"
"pub impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger)"
" {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"
msgstr ""
"pub(open) trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"pub(open) trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// 使用新的方法来简化代码\n"
"pub impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"

#: ../../language/methods.md:263
msgid "Builtin traits"
msgstr "内建特征"

#: ../../language/methods.md:265
msgid "MoonBit provides the following useful builtin traits:"
msgstr "MoonBit 提供了以下有用的内建特征："

#: ../../language/methods.md:269
msgid ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` for equal, `-1` for smaller, `1` for greater\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // to be implemented\n"
"  hash(Self) -> Int // has default implementation\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // to be implemented\n"
"  to_string(Self) -> String // has default implementation\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"
msgstr ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` 代表相等，`-1` 代表小于，`1` 代表大于\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // 待实现\n"
"  hash(Self) -> Int // 有默认实现\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // 待实现\n"
"  to_string(Self) -> String // 有默认实现\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"

#: ../../language/methods.md:294
msgid "Deriving builtin traits"
msgstr "派生内建特征"

#: ../../language/methods.md:296
msgid "MoonBit can automatically derive implementations for some builtin traits:"
msgstr "MoonBit 可以自动为一些内建特征派生实现："

#: ../../language/methods.md:298
msgid ""
"struct T {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare, Show, Default)\n"
"\n"
"test {\n"
"  let t1 = T::default()\n"
"  let t2 = T::{ x: 1, y: 1 }\n"
"  inspect!(t1, content=\"{x: 0, y: 0}\")\n"
"  inspect!(t2, content=\"{x: 1, y: 1}\")\n"
"  assert_not_eq!(t1, t2)\n"
"  assert_true!(t1 < t2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:304
msgid "See [Deriving](./derive.md) for more information about deriving traits."
msgstr "参见 [派生](./derive.md) 了解有关派生特征的更多信息。"

#: ../../language/packages.md:1
msgid "Managing Projects with Packages"
msgstr "使用包管理项目"

#: ../../language/packages.md:3
msgid ""
"When developing projects at large scale, the project usually needs to be "
"divided into smaller modular unit that depends on each other.  More "
"often, it involves using other people's work: most noticeably is the "
"[core](https://github.com/moonbitlang/core), the standard library of "
"MoonBit."
msgstr ""
"在大规模开发项目时，项目通常需要分解为相互依赖的较小模块单元。更常见的是使用其他人的工作：最典型的是 "
"[core](https://github.com/moonbitlang/core)，MoonBit 的标准库。"

#: ../../language/packages.md:6
msgid "Packages and modules"
msgstr "包和模块"

#: ../../language/packages.md:8
msgid ""
"In MoonBit, the most important unit for code organization is a package, "
"which consists of a number of source code files and a single "
"`moon.pkg.json` configuration file. A package can either be a `main` "
"package, consisting a `main` function, or a package that serves as a "
"library."
msgstr ""
"在 MoonBit 中，代码组织的最重要单元是包，它由多个源代码文件和一个单独的 `moon.pkg.json` 配置文件组成。包可以是一个 "
"`main` 包，包含一个 `main` 函数，或者是一个用作库的包。"

#: ../../language/packages.md:11
msgid ""
"A project, corresponding to a module, consists of multiple packages and a"
" single `moon.mod.json` configuration file."
msgstr "一个项目对应一个模块，由多个包和一个单独的 `moon.mod.json` 配置文件组成。"

#: ../../language/packages.md:13
msgid ""
"When using things from another package, the dependency between modules "
"should first be declared inside the `moon.mod.json`. The dependency "
"between packages should then be declared inside the `moon.pkg.json`. Then"
" it is possible to use `@pkg` to access the imported entities, where "
"`pkg` is the last part of the imported package's path or the declared "
"alias in `moon.pkg.json`:"
msgstr ""
"在从另一个包中使用内容时，模块之间的依赖关系应首先在 `moon.mod.json` 中声明。然后在 `moon.pkg.json` "
"中声明包之间的依赖关系。然后可以使用 `@pkg` 访问导入的实体，其中 `pkg` 是导入包路径的最后一部分或 `moon.pkg.json` "
"中声明的别名："

#: ../../language/packages.md:17
msgid "pkgB/moon.pkg.json"
msgstr ""

#: ../../language/packages.md:17
msgid ""
"{\n"
"    \"import\": [\n"
"        \"moonbit-community/language/packages/pkgA\",\n"
"        {\n"
"            \"path\": \"moonbit-community/language/packages/pkgC\",\n"
"            \"alias\": \"c\"\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../language/packages.md:22
msgid "pkgB/top.mbt"
msgstr ""

#: ../../language/packages.md:22
msgid ""
"pub fn add1(x : Int) -> Int {\n"
"  @c.incr(@pkgA.incr(x))\n"
"}"
msgstr ""

#: ../../language/packages.md:27
msgid "Access Control"
msgstr "访问控制"

#: ../../language/packages.md:29
msgid ""
"By default, all function definitions and variable bindings are "
"_invisible_ to other packages. You can use the `pub` modifier before "
"toplevel `let`/`fn` to make them public."
msgstr "默认情况下，所有函数定义和变量绑定对其他包是 _不可见_ 的。可以在顶层 `let`/`fn` 前使用 `pub` 修饰符使其公开。"

#: ../../language/packages.md:32
msgid "There are four different kinds of visibility for types in MoonBit:"
msgstr "MoonBit 中有四种不同的类型可见性："

#: ../../language/packages.md:34
msgid ""
"private type, declared with `priv`, completely invisible to the outside "
"world"
msgstr "私有类型，使用 `priv` 声明，对外部世界完全不可见"

#: ../../language/packages.md:35
msgid ""
"abstract type, which is the default visibility for types. Only the name "
"of an abstract type is visible outside, the internal representation of "
"the type is hidden"
msgstr "抽象类型，这是类型的默认可见性。只有抽象类型的名称对外部可见，类型的内部表示被隐藏"

#: ../../language/packages.md:36
msgid ""
"readonly types, declared with `pub`. The internal representation of "
"readonly types are visible outside, but users can only read the values of"
" these types from outside, construction and mutation are not allowed"
msgstr "只读类型，使用 `pub` 声明。只读类型的内部表示对外部可见，但用户只能从外部读取这些类型的值，不允许构造和修改"

#: ../../language/packages.md:38
msgid ""
"fully public types, declared with `pub(all)`. The outside world can "
"freely construct, modify and read values of these types"
msgstr "完全公开类型，使用 `pub(all)` 声明。外部世界可以自由构造、修改和读取这些类型的值"

#: ../../language/packages.md:40
msgid ""
"In addition to the visibility of the type itself, the fields of a public "
"`struct` can be annotated with `priv`, which will hide the field from the"
" outside world completely. Note that `struct`s with private fields cannot"
" be constructed directly outside, but you can update the public fields "
"using the functional struct update syntax."
msgstr ""
"除了类型本身的可见性外，公开的结构体的字段可以用 `priv` 注释，这将完全隐藏字段对外部世界。请注意，具有私有字段的 `struct` "
"不能直接在外部构造，但可以使用函数式 `struct` 更新语法更新公开字段。"

#: ../../language/packages.md:45
msgid ""
"Readonly types is a very useful feature, inspired by [private "
"types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short,"
" values of `pub` types can be destructed by pattern matching and the dot "
"syntax, but cannot be constructed or mutated in other packages. Note that"
" there is no restriction within the same package where `pub` types are "
"defined."
msgstr ""
"只读类型是一个非常有用的功能，受到 OCaml 中 "
"[私有类型](https://v2.ocaml.org/manual/privatetypes.html) 的启发。简而言之，`pub` "
"类型的值可以通过模式匹配和点语法解构，但不能在其他包中构造或修改。请注意，在定义 `pub` 类型的同一包中没有限制。"

#: ../../language/packages.md:49
msgid ""
"// Package A\n"
"pub struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // OK\n"
"  let r = { ..r, field: 8 }  // OK\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // OK\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public"
" read-only type RO!\n"
"  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only "
"field!\n"
"}\n"
msgstr ""
"// Package A\n"
"pub struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // 可以\n"
"  let r = { ..r, field: 8 }  // 可以\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // 可以\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // 错误：不能创建公开只读类型 RO 的值！\n"
"  let r = { ..r, field: 8 }  // 错误：不能修改公开只读字段！\n"
"}\n"

#: ../../language/packages.md:71
msgid ""
"Access control in MoonBit adheres to the principle that a `pub` type, "
"function, or variable cannot be defined in terms of a private type. This "
"is because the private type may not be accessible everywhere that the "
"`pub` entity is used. MoonBit incorporates sanity checks to prevent the "
"occurrence of use cases that violate this principle."
msgstr ""
"MoonBit "
"中的访问控制遵循一个原则，即公开的类型、函数或变量不能以私有类型定义。这是因为私有类型可能无法在使用公开的实体的所有地方访问。MoonBit "
"包含了健全性检查，以防止违反这一原则的用例发生。"

#: ../../language/packages.md:74
msgid ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // OK\n"
"  y: T2  // OK\n"
"  z: T3  // ERROR: public field has private type `T3`!\n"
"}\n"
"\n"
"// ERROR: public function has private parameter type `T3`!\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// ERROR: public function has private return type `T3`!\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// OK\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // ERROR: public variable has private type `T3`!\n"
msgstr ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // 可以\n"
"  y: T2  // 可以\n"
"  z: T3  // 错误：公开字段使用了私有类型 `T3`！\n"
"}\n"
"\n"
"// 错误：公开函数使用了私有类型 `T3`！\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// 错误：公开函数的返回值使用了私有类型 `T3`！\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// 可以\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // 错误：公开变量的类型是私有类型 `T3`！\n"

#: ../../language/packages.md:95
msgid "Access control of methods and trait implementations"
msgstr "方法和特征实现的访问控制"

#: ../../language/packages.md:97
msgid ""
"To make the trait system coherent (i.e. there is a globally unique "
"implementation for every `Type: Trait` pair), and prevent third-party "
"packages from modifying behavior of existing programs by accident, "
"MoonBit employs the following restrictions on who can define "
"methods/implement traits for types:"
msgstr ""
"为了使特征系统一致（即每个 `Type: Trait` 对都有全局唯一的实现），并防止第三方包意外地修改现有程序的行为，MoonBit "
"对谁可以定义方法/实现类型的特征采用了以下限制："

#: ../../language/packages.md:101
msgid ""
"_only the package that defines a type can define methods for it_. So one "
"cannot define new methods or override old methods for builtin and foreign"
" types."
msgstr "**只有定义类型的包才能为其定义方法**。因此，不能为内建和外部类型定义新方法或覆盖旧方法。"

#: ../../language/packages.md:102
msgid ""
"_only the package of the type or the package of the trait can define an "
"implementation_. For example, only `@pkg1` and `@pkg2` are allowed to "
"write `impl @pkg1.Trait for @pkg2.Type`."
msgstr ""
"**只有类型的包或特征的包才能定义实现**。例如，只有 `@pkg1` 和 `@pkg2` 允许编写 `impl @pkg1.Trait for "
"@pkg2.Type`。"

#: ../../language/packages.md:105
msgid ""
"The second rule above allows one to add new functionality to a foreign "
"type by defining a new trait and implementing it. This makes MoonBit's "
"trait & method system flexible while enjoying good coherence property."
msgstr "上述第二条规则允许通过定义新特征并实现它来为外部类型添加新功能。这使 MoonBit 的特征和方法系统灵活，同时享有良好的一致性属性。"

#: ../../language/packages.md:108
msgid "Visibility of traits and sealed traits"
msgstr "特征的可见性和封闭特征"

#: ../../language/packages.md:109
msgid ""
"There are four visibility for traits, just like `struct` and `enum`: "
"private, abstract, readonly and fully public. Private traits are declared"
" with `priv trait`, and they are completely invisible from outside. "
"Abstract trait is the default visibility. Only the name of the trait is "
"visible from outside, and the methods in the trait are not exposed. "
"Readonly traits are declared with `pub trait`, their methods can be "
"involked from outside, but only the current package can add new "
"implementation for readonly traits. Finally, fully public traits are "
"declared with `pub(open) trait`, they are open to new implementations "
"outside current package, and their methods can be freely used."
msgstr ""
"特征有四种可见性，就像 `struct` 和 `enum`：私有、抽象、只读和完全公开。私有特征使用 `priv trait` "
"声明，对外部完全不可见。抽象特征是默认可见性：只有特征的名称对外部可见，特征中的方法不会暴露。只读特征使用 `pub trait` "
"声明，它们的方法可以从外部调用，但只有当前包可以为只读特征添加新实现。最后，完全公开特征使用 `pub(open) trait` "
"声明，它们对外部新实现是开放的，它们的方法可以自由使用。"

#: ../../language/packages.md:115
msgid ""
"Abstract and readonly traits are sealed, because only the package "
"defining the trait can implement them. Implementing a sealed (abstract or"
" readonly) trait outside its package result in compiler error. If you are"
" the owner of a sealed trait, and you want to make some implementation "
"available to users of your package, make sure there is at least one "
"declaration of the form `impl Trait for Type with ...` in your package. "
"Implementations with only regular method and default implementations will"
" not be available outside."
msgstr "抽象和只读特征是封闭的，因为只有定义特征的包才能实现它们。在其包外实现封闭（抽象或只读）特征会导致编译器错误。"

#: ../../language/packages.md:121
msgid "Here's an example of abstract trait:"
msgstr "以下是抽象特征的示例："

#: ../../language/packages.md:124
msgid ""
"trait Number {\n"
" op_add(Self, Self) -> Self\n"
" op_sub(Self, Self) -> Self\n"
"}\n"
"\n"
"fn add[N : Number](x : N, y: N) -> N {\n"
"  Number::op_add(x, y)\n"
"}\n"
"\n"
"fn sub[N : Number](x : N, y: N) -> N {\n"
"  Number::op_sub(x, y)\n"
"}\n"
"\n"
"impl Number for Int with op_add(x, y) { x + y }\n"
"impl Number for Int with op_sub(x, y) { x - y }\n"
"\n"
"impl Number for Double with op_add(x, y) { x + y }\n"
"impl Number for Double with op_sub(x, y) { x - y }\n"
msgstr ""

#: ../../language/packages.md:145
msgid "From outside this package, users can only see the following:"
msgstr "从包外，用户只能看到以下内容："

#: ../../language/packages.md:147
msgid ""
"trait Number\n"
"\n"
"fn op_add[N : Number](x : N, y : N) -> N\n"
"fn op_sub[N : Number](x : N, y : N) -> N\n"
"\n"
"impl Number for Int\n"
"impl Number for Double\n"
msgstr ""

#: ../../language/packages.md:157
msgid ""
"The author of `Number` can make use of the fact that only `Int` and "
"`Double` can ever implement `Number`, because new implementations are not"
" allowed outside."
msgstr "`Number` 的作者可以利用只有 `Int` 和 `Double` 可以实现 `Number` 这一事实，因为在外部不允许新的实现。"

#: ../../language/tests.md:1
msgid "Writing Tests"
msgstr "编写测试"

#: ../../language/tests.md:3
msgid ""
"Tests are important for improving quality and maintainability of a "
"program. They verify the behavior of a program and also serves as a "
"specification to avoid regressions over time."
msgstr "测试对于提高程序的质量和可维护性很重要。它们验证程序的行为，也作为规范，以避免随时间的推移出现退步。"

#: ../../language/tests.md:5
msgid "MoonBit comes with test support to make the writing easier and simpler."
msgstr "MoonBit 提供测试支持，使编写测试更加简单和容易。"

#: ../../language/tests.md:7
msgid "Test Blocks"
msgstr "测试块"

#: ../../language/tests.md:9
msgid ""
"MoonBit provides the test code block for writing inline test cases. For "
"example:"
msgstr "MoonBit 提供测试代码块，用于编写内联测试用例。例如："

#: ../../language/tests.md:17
msgid ""
"A test code block is essentially a function that returns a `Unit` but may"
" throws a `String` on error, or `Unit!String` as one would see in its "
"signature at the position of return type. It is called during the "
"execution of `moon test` and outputs a test report through the build "
"system. The `assert_eq` function is from the standard library; if the "
"assertion fails, it prints an error message and terminates the test. The "
"string `\"test_name\"` is used to identify the test case and is optional."
msgstr ""
"测试代码块本质上是一个返回 `Unit` 抛出 `String` 的函数。它在执行 `moon test` "
"期间被调用，并通过构建系统输出测试报告。`assert_eq` 函数来自标准库；如果断言失败，它会打印错误消息并终止测试。字符串 "
"`\"test_name\"` 用于标识测试用例，是可选的。"

#: ../../language/tests.md:19
msgid ""
"If a test name starts with `\"panic\"`, it indicates that the expected "
"behavior of the test is to trigger a panic, and the test will only pass "
"if the panic is triggered. For example:"
msgstr "如果测试名称以 `\"panic\"` 开头，表示测试的预期行为是触发 panic，只有在触发 panic 时测试才会通过。例如："

#: ../../language/tests.md:21
msgid ""
"test \"panic_test\" {\n"
"  let _ : Int = Option::None.unwrap()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/tests.md:27
msgid "Snapshot Tests"
msgstr "快照测试"

#: ../../language/tests.md:29
msgid ""
"Writing tests can be tedious when specifying the expected values. Thus, "
"MoonBit provides three kinds of snapshot tests. All of which can be "
"inserted or updated automatically using `moon test --update`."
msgstr ""
"在指定预期值时，编写测试可能会很繁琐。因此，MoonBit 提供了三种快照测试。所有这些都可以使用 `moon test --update` "
"自动插入或更新。"

#: ../../language/tests.md:32
msgid "Snapshotting `Show`"
msgstr "快照 `Show`"

#: ../../language/tests.md:34
msgid ""
"We can use `inspect!(x, content=\"x\")` to inspect anything that "
"implements `Show` trait.  As we mentioned before, `Show` is a builtin "
"trait that can be derived, providing `to_string` that will print the "
"content of the data structures.  The labelled argument `content` can be "
"omitted as `moon test --update` will insert it for you:"
msgstr ""
"我们可以使用 `inspect!(x, content=\"x\")` 来检查实现了 `Show` "
"特征的任何内容。正如我们之前提到的，`Show` 是一个可以派生的内建特征，提供了 `to_string`来打印数据结构的内容。标记参数 "
"`content` 可以省略，因为 `moon test --update` 会自动插入："

#: ../../language/tests.md:38
msgid ""
"struct X { x : Int } derive(Show)\n"
"\n"
"test \"show snapshot test\" {\n"
"  inspect!({x: 10}, content=\"{x: 10}\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:44
msgid "Snapshotting `JSON`"
msgstr "快照 `JSON`"

#: ../../language/tests.md:46
msgid ""
"The problem with the derived `Show` trait is that it does not perform "
"pretty printing, resulting in extremely long output."
msgstr "派生的 `Show` 特征的问题是它不能对输出进行格式化，导致输出非常长。"

#: ../../language/tests.md:48
msgid ""
"The solution is to use `@json.inspect!(x, content=x)`. The benefit is "
"that the resulting content is a JSON structure, which can be more "
"readable after being formatted."
msgstr "解决方案是使用 `@json.inspect!(x, content=x)`。其好处是生成的内容是一个 JSON 结构，在格式化后更易读。"

#: ../../language/tests.md:50
msgid ""
"enum Rec {\n"
"  End\n"
"  Really_long_name_that_is_difficult_to_read(Rec)\n"
"} derive(Show, ToJson)\n"
"\n"
"test \"json snapshot test\" {\n"
"  let r = Really_long_name_that_is_difficult_to_read(\n"
"    Really_long_name_that_is_difficult_to_read(\n"
"      Really_long_name_that_is_difficult_to_read(End),\n"
"    ),\n"
"  )\n"
"  inspect!(\n"
"    r,\n"
"    "
"content=\"Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(End)))\","
"\n"
"  )\n"
"  @json.inspect!(\n"
"    r,\n"
"    content={\n"
"      \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"      \"0\": {\n"
"        \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"        \"0\": {\n"
"          \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"          \"0\": { \"$tag\": \"End\" },\n"
"        },\n"
"      },\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/tests.md:56
msgid ""
"One can also implement a custom `ToJson` to keep only the essential "
"information."
msgstr "也可以实现自定义 `ToJson` 来保留必要的信息。"

#: ../../language/tests.md:58
msgid "Snapshotting Anything"
msgstr "快照任何内容"

#: ../../language/tests.md:60
msgid ""
"Still, sometimes we want to not only record one data structure but the "
"output of a whole process."
msgstr "有时我们不仅要记录一个数据结构，还要记录整个过程的输出。"

#: ../../language/tests.md:62
msgid ""
"A full snapshot test can be used to record anything using "
"`@test.T::write` and `@test.T::writeln`:"
msgstr "可以使用完整的快照测试使用 `@test.T::write` 和 `@test.T::writeln` 记录任何内容："

#: ../../language/tests.md:64
msgid ""
"test \"record anything\" (t : @test.T) {\n"
"  t.write(\"Hello, world!\")\n"
"  t.writeln(\" And hello, MoonBit!\")\n"
"  t.snapshot!(filename=\"record_anything.txt\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:70
msgid ""
"This will create a file under `__snapshot__` of that package with the "
"given filename:"
msgstr "这将在该包的 `__snapshot__` 下创建一个具有给定文件名的文件："

#: ../../language/tests.md:72
msgid "Hello, world! And hello, MoonBit!\n"
msgstr ""

#: ../../language/tests.md:75
msgid ""
"This can also be used for applications to test the generated output, "
"whether it were creating an image, a video or some custom data."
msgstr "这也可以用于测试应用程序的输出，无论是创建图像、视频还是一些自定义数据。"

#: ../../language/tests.md:77
msgid "BlackBox Tests and WhiteBox Tests"
msgstr "黑盒测试和白盒测试"

#: ../../language/tests.md:79
msgid ""
"When developing libraries, it is important to verify if the user can use "
"it correctly. For example, one may forget to make a type or a function "
"public. That's why MoonBit provides BlackBox tests, allowing developers "
"to have a grasp of how others are feeling."
msgstr ""
"在开发库时，验证用户是否可以正确使用它是很重要的。例如，可能会忘记使类型或函数公开。这就是为什么 MoonBit "
"提供了黑盒测试，允许开发人员了解其他人的感受。"

#: ../../language/tests.md:81
msgid ""
"A test that has access to all the members in a package is called a "
"WhiteBox tests as we can see everything. Such tests can be defined inline"
" or defined in a file whose name ends with `_wbtest.mbt`."
msgstr ""
"只能访问包中所有成员的测试称为白盒测试，因为我们可以看到一切。这样的测试可以内联定义，也可以在文件中定义，文件名以 `_wbtest.mbt` "
"结尾。"

#: ../../language/tests.md:83
msgid ""
"A test that has access only to the public members in a package is called "
"a BlackBox tests. Such tests need to be defined in a file whose name ends"
" with `_test.mbt`."
msgstr "只能访问包中公开成员的测试称为黑盒测试。这样的测试需要在文件中定义，文件名以 `_test.mbt` 结尾。"

#: ../../language/tests.md:85
msgid ""
"The WhiteBox test files (`_wbtest.mbt`) imports the packages defined in "
"the `import` and `wbtest-import` sections of the package configuration "
"(`moon.pkg.json`)."
msgstr ""
"白盒测试文件（`_wbtest.mbt`）导入包配置（`moon.pkg.json`）中的 `import` 和 `wbtest-import` "
"部分定义的包。"

#: ../../language/tests.md:87
msgid ""
"The BlackBox test files (`_test.mbt`) imports the current package and the"
" packages defined in the `import` and `test-import` sections of the "
"package configuration (`moon.pkg.json`)."
msgstr ""
"黑盒测试文件（`_test.mbt`）导入当前包和包配置（`moon.pkg.json`）中的 `import` 和 `test-import` "
"部分定义的包。"
