# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../sources/sudoku/src/index.mbt.md:2
msgid "Sudoku Solver"
msgstr "数独求解器"

#: ../../sources/sudoku/src/index.mbt.md:4
msgid ""
"Sudoku is a logic-based puzzle game that originated in 1979. It was well-"
"suited for print media like newspapers, and even in the digital age, many "
"Sudoku game programs are available for computers and smartphones. Despite "
"the variety of entertainment options today, Sudoku enthusiasts continue to "
"form active communities (online forum such as: "
"[enjoysudoku](http://forum.enjoysudoku.com/)). This article will demonstrate"
" how to write a suitable program to solve Sudoku using MoonBit. ![sudoku "
"example](/imgs/sudoku.jpg)"
msgstr ""
"数独是一种基于逻辑的益智游戏，起源于 1979 "
"年。它非常适合报纸等印刷媒体，即使在数字时代，许多数独游戏程序也可用于计算机和智能手机。尽管如今娱乐选择多种多样，但数独爱好者仍在继续组建活跃的社区（在线论坛，例如：[enjoysudoku](http://forum.enjoysudoku.com/)）。本文将演示如何使用"
" MoonBit 编写合适的程序来解决数独问题。"

#: ../../sources/sudoku/src/index.mbt.md:4
msgid "sudoku example"
msgstr "数独示例"

#: ../../sources/sudoku/src/index.mbt.md:13
msgid "Squares, Units, and Peers"
msgstr "方格、单元和同级"

#: ../../sources/sudoku/src/index.mbt.md:15
msgid ""
"The most common form of Sudoku is played on a 9x9 grid. We label the rows "
"from top to bottom as A-I, and the columns from left to right as 1-9. This "
"gives each square in the grid a coordinate, for example, the square "
"containing the number 0 in the grid below has the coordinate C3."
msgstr ""
"最常见的数独形式是在 9x9 网格上进行的。我们将从上到下的行标记为 A-I，从左到右的列标记为 "
"1-9。这为网格中的每个方格提供了一个坐标，例如，下面网格中包含数字 0 的方格的坐标为 C3。"

#: ../../sources/sudoku/src/index.mbt.md:20
msgid ""
"  1 2 3 4 5 6 7 8 9\n"
"A . . . . . . . . .\n"
"B . . . . . . . . .\n"
"C . . 0 . . . . . .\n"
"D . . . . . . . . .\n"
"E . . . . . . . . .\n"
"F . . . . . . . . .\n"
"G . . . . . . . . .\n"
"H . . . . . . . . .\n"
"I . . . . . . . . .\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:33
msgid ""
"This 9x9 grid has a total of 9 units, and each unit contains squares that "
"must have unique digits from 1 to 9. However, in the initial state of the "
"game, most squares do not contain any digits."
msgstr "这个 9x9 的网格共有 9 个单元，每个单元包含的方格必须具有从 1 到 9 的唯一数字。但是在游戏的初始状态下，大多数方格不包含任何数字。"

#: ../../sources/sudoku/src/index.mbt.md:37
msgid ""
" 4  1  7 | 3  6  9 | 8  2  5\n"
" 6  3  2 | 1  5  8 | 9  4  7\n"
" 9  5  8 | 7  2  4 | 3  1  6\n"
"---------+---------+---------\n"
" 8  2  5 | 4  3  7 | 1  6  9\n"
" 7  9  1 | 5  8  6 | 4  3  2\n"
" 3  4  6 | 9  1  2 | 7  5  8\n"
"---------+---------+---------\n"
" 2  8  9 | 6  4  3 | 5  7  1\n"
" 5  7  3 | 2  9  1 | 6  8  4\n"
" 1  6  4 | 8  7  5 | 2  9  3\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:51
msgid ""
"Beyond the units, another important concept is peers. A square's peers "
"include other squares in the same row, column, and unit. For example, the "
"peers of C2 include these squares:"
msgstr "除了单元之外，另一个重要概念是同级。一个方格的同级包括同一行、同一列和同一单位的其他方格。例如，C2 的同级包括以下方格："

#: ../../sources/sudoku/src/index.mbt.md:55
msgid ""
"    A2   |         |\n"
"    B2   |         |\n"
"    C2   |         |\n"
"---------+---------+---------\n"
"    D2   |         |\n"
"    E2   |         |\n"
"    F2   |         |\n"
"---------+---------+---------\n"
"    G2   |         |\n"
"    H2   |         |\n"
"    I2   |         |\n"
"\n"
"         |         |\n"
"         |         |\n"
" C1 C2 C3| C4 C5 C6| C7 C8 C9\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"\n"
" A1 A2 A3|         |\n"
" B1 B2 B3|         |\n"
" C1 C2 C3|         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:93
msgid "No two squares that are peers can contain the same digit."
msgstr "没有两个同级的格子可以包含相同的数字。"

#: ../../sources/sudoku/src/index.mbt.md:95
msgid ""
"We need a data type, `Grid[T]`, to store the 81 squares and the information "
"associated with each square. This can be implemented using a hashtable, but "
"using an array would be more compact and simple. First, we write a function "
"to convert coordinates A1-I9 to indices 0-80:"
msgstr ""
"我们需要一个数据类型 Grid[T] 来存储这 81 "
"个方格以及与每个方格相关的信息。这可以使用哈希表来实现，但使用数组会更紧凑、更简单。首先，我们编写一个函数将坐标 A1-I9 转换为索引 0-80："

#: ../../sources/sudoku/src/index.mbt.md:100
msgid ""
"// A1 => 0, A2 => 1\n"
"fn square_to_int(s : String) -> Int {\n"
"  if s is [('A'..='I') as a, ('1'..='9') as b, ..] {\n"
"    let row = a.to_int() - 'A'.to_int() // 'A' <=> 0\n"
"    let col = b.to_int() - '1'.to_int() // '1' <=> 0\n"
"    return row * 9 + col\n"
"  } else {\n"
"    abort(\"Grid_to_int(): \\{s} is not a Grid\")\n"
"  }\n"
"}\n"
"\n"
"///\n"
"test {\n"
"  inspect(square_to_int(\"A1\"), content=\"0\")\n"
"  inspect(square_to_int(\"A7\"), content=\"6\")\n"
"  inspect(square_to_int(\"I9\"), content=\"80\")\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:120
msgid ""
"Then we wrap the array and provide operations for creating, accessing, "
"assigning values to specific coordinates, and copying `Grid[T]`. By "
"overloading the op_get and op_set methods, we can write convenient code like"
" `table[\"A2\"]` and `table[\"C3\"] = ...`."
msgstr ""
"然后我们包装这个数组，并提供创建、访问、为特定坐标赋值以及复制 Grid[T] 的操作。通过重载 op_get 和 op_set 方法，我们可以编写类似"
" `table[\"A2\"]` 和 `table[\"C3\"] = ...` 的便捷代码。"

#: ../../sources/sudoku/src/index.mbt.md:125
msgid ""
"///|\n"
"struct Grid[T](FixedArray[T])\n"
"\n"
"///|\n"
"fn[T] Grid::new(val : T) -> Grid[T] {\n"
"  FixedArray::make(81, val)\n"
"}\n"
"\n"
"///|\n"
"fn[T] Grid::copy(self : Grid[T]) -> Grid[T] {\n"
"  if self.0.length() == 0 {\n"
"    return []\n"
"  }\n"
"  let arr = FixedArray::make(81, self.0[0])\n"
"  let mut i = 0\n"
"  while i < 81 {\n"
"    arr[i] = self.0[i]\n"
"    i = i + 1\n"
"  }\n"
"  return arr\n"
"}\n"
"\n"
"///|\n"
"#alias(\"_[_]\")\n"
"fn[T] Grid::at(self : Grid[T], square : String) -> T {\n"
"  let i = square_to_int(square)\n"
"  self.0[i]\n"
"}\n"
"\n"
"///|\n"
"#alias(\"_[_]=_\")\n"
"fn[T] Grid::set(self : Grid[T], square : String, x : T) -> Unit {\n"
"  let i = square_to_int(square)\n"
"  self.0[i] = x\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:163
msgid "Next, we prepare some constants:"
msgstr "接下来我们准备一些常量："

#: ../../sources/sudoku/src/index.mbt.md:165
msgid ""
"let rows = \"ABCDEFGHI\"\n"
"\n"
"let cols = \"123456789\"\n"
"\n"
"type Squares =  @immut/sorted_set.SortedSet[String] \n"
"\n"
"// squares contains the coordinates of each square\n"
"let squares : Squares = ......\n"
"\n"
"// units[coord] contains the other squares in the unit of the square at "
"coord\n"
"// for example：units[\"A3\"] => [C3, C2, C1, B3, B2, B1, A2, A1]\n"
"let units : Grid[Squares] = ......\n"
"\n"
"// peers[coord] contains all the peers of the square at coord\n"
"// for example：peers[\"A3\"] => [A1, A2, A4, A5, A6, A7, A8, A9, B1, B2, B3,"
" C1, C2, C3, D3, E3, F3, G3, H3, I3]\n"
"let peers : Grid[Squares] = ......\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:184
msgid ""
"The process of constructing the units and peers tables is tedious, so it "
"will not be detailed here."
msgstr "构建单元和同级表的过程非常繁琐，因此这里不再详述。"

#: ../../sources/sudoku/src/index.mbt.md:187
msgid "Preprocessing the Grid"
msgstr "预处理网格"

#: ../../sources/sudoku/src/index.mbt.md:189
msgid ""
"We use a string to represent the initial Sudoku grid. Various formats are "
"acceptable; both `.` and `0` represent empty squares, and other characters "
"like spaces and newlines are ignored."
msgstr "我们使用字符串来表示初始数独网格。各种格式均可接受；. 和 0 均表示空方块，其他字符（如空格和换行符）将被忽略。"

#: ../../sources/sudoku/src/index.mbt.md:193
msgid ""
"#|400000805\n"
"#|030000000\n"
"#|000700000\n"
"#|020000060\n"
"#|000080400\n"
"#|000010000\n"
"#|000603070\n"
"#|500200000\n"
"#|104000000\n"
"\n"
"#|4 . .   . . .   8 . 5\n"
"#|. 3 .   . . .   . . .\n"
"#|. . .   7 . .   . . .\n"
"#|\n"
"#|. 2 .   . . .   . 6 .\n"
"#|. . .   . 8 .   4 . .\n"
"#|. . .   . 1 .   . . .\n"
"#|\n"
"#|. . .   6 . 3   . 7 .\n"
"#|5 . .   2 . .   . . .\n"
"#|1 . 4   . . .   . . .\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:217
msgid ""
"For now, let's not consider game rules too much. If we only consider the "
"digits that can be filled in each square, then 1-9 are all possible. "
"Therefore, we initially set the content of all squares to `['1', '2', '3', "
"'4', '5', '6', '7', '8', '9']` (a List)."
msgstr ""
"暂时先不考虑太多游戏规则，如果只考虑每个方格能填入的数字，那么 1-9 都是有可能的，因此我们初始将所有方格的内容设置为`['1', '2', '3',"
" '4', '5', '6', '7', '8', '9']` (a List)。"

#: ../../sources/sudoku/src/index.mbt.md:222
msgid ""
"fn Grid::parse(s : String) -> Grid[@immut/sorted_set.T[Char]] {\n"
"  let digits = @immut/sorted_set.from_array(cols.to_array())\n"
"  let values = Grid::new(digits)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:230
msgid ""
"Next, we need to assign values to the squares with known digits from the "
"input. This process can be implemented with the function `assign(values, "
"key, val)`, where `key` is a string like `A6` and `val` is a character. It "
"is easy to write such code."
msgstr ""
"接下来，我们需要将输入中已知数字的方块赋值。这个过程可以用函数 `assign(values, key, val)` 来实现，其中 `key` "
"是一个字符串，比如 `A6`，`val` 是一个字符。这样的代码写起来很容易。"

#: ../../sources/sudoku/src/index.mbt.md:235
msgid ""
"fn assign(values : Grid[@immut/sorted_set.T[Char]], key : String, val : "
"Char) -> Unit {\n"
"  values[key] = @immut/sorted_set.singleton(val)\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:241
msgid "This implementation is simple and precise, but we can do more."
msgstr "这个实现简单而精确，但我们可以做得更多。"

#: ../../sources/sudoku/src/index.mbt.md:243
msgid ""
"Now, we can reintroduce the rules that we set aside earlier. However, the "
"rules themselves do not tell us what to do. We need heuristic strategies to "
"gain insights from the rules, similar to solving Sudoku with pen and paper. "
"Let's start with the elimination method:"
msgstr "现在，我们可以重新引入之前搁置的规则。但是，规则本身并没有告诉我们该做什么。我们需要启发式策略来从规则中获得见解，类似于用笔和纸解决数独。让我们从消除法开始："

#: ../../sources/sudoku/src/index.mbt.md:248
msgid ""
"**Strategy 1**: If a square `key` is assigned a value `val`, then its peers "
"(peers[key]) should not contain `val` in their lists of possible values, as "
"this would violate the rule that no two squares in the same unit, row, or "
"column can have the same digit."
msgstr ""
"**策略 1**：如果为一个方块 `key` 分配了一个值 `val`，则其对同级（'peers[key]'）的可能值列表中不应该包含 "
"`val'，因为这会违反同一单元、行或列中没有两个方块可以具有相同数字的规则。"

#: ../../sources/sudoku/src/index.mbt.md:253
msgid ""
"**Strategy 2**: If there is only one square in a unit that can hold a "
"specific digit (possibly happen after applying the above rule several "
"times), then that digit should be assigned to that square."
msgstr "**策略 2**：如果一个单元中只有一个方格可以容纳特定的数字（在多次应用上述规则后可能发生），则应将该数字分配给该方格。"

#: ../../sources/sudoku/src/index.mbt.md:257
msgid ""
"We adjust the code by defining an `eliminate` function, which removes a "
"digit from the possible values of a square. After performing the elimination"
" task, it applies the above strategies to `key` and `val` to attempt further"
" eliminations. Note that it includes a boolean return value to handle "
"possible contradictions. If the list of possible values for a square becomes"
" empty, something went wrong, and we return `false`."
msgstr ""
"我们通过定义一个消除函数 `eliminate` 来调整代码，该函数从正方形的可能值中删除一个数字。执行消除任务后，它将上述策略应用于 `key` 和 "
"`val` 以尝试进一步消除。请注意，它包含一个布尔返回值来处理可能的矛盾。如果方格的可能值列表为空，则出现问题，我们返回 `false`。"

#: ../../sources/sudoku/src/index.mbt.md:264
msgid ""
"fn eliminate(\n"
"  values : Grid[@immut/sorted_set.SortedSet[Char]],\n"
"  key : String,\n"
"  val : Char\n"
") -> Bool {\n"
"  if not(values[key].contains(val)) {\n"
"    return true\n"
"  }\n"
"  values[key] = values[key].remove(val)\n"
"  // If `key` has only one possible value left, remove this value from its "
"peers\n"
"  match values[key].length() {\n"
"    1 => {\n"
"      let val = values[key].min()\n"
"      let mut res = true\n"
"      for key in peers[key] {\n"
"        res = res && eliminate(values, key, val)\n"
"      }\n"
"      if not(res) {\n"
"        return res\n"
"      }\n"
"    }\n"
"    0 => return false\n"
"    _ => ()\n"
"  }\n"
"  //  If there is only one square in the unit of `key` that can hold `val`, "
"assign `val` to that square\n"
"  let unit = units[key]\n"
"  let places = unit.filter(fn(sq) { values[sq].contains(val) })\n"
"  match places.length() {\n"
"    1 => {\n"
"      let key = places.min()\n"
"      return assign(values, key, val)\n"
"    }\n"
"    0 => return false\n"
"    _ => return true\n"
"  }\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:303
msgid ""
"Next, we define `assign(values, key, val)` to remove all values except `val`"
" from the possible values of `key`."
msgstr "接下来，我们定义 `assign(values, key, val)` 来从 `key` 的可能值中删除除 `val` 之外的所有值。"

#: ../../sources/sudoku/src/index.mbt.md:306
msgid ""
"///|\n"
"fn assign(\n"
"  values : Grid[@immut/sorted_set.SortedSet[Char]],\n"
"  key : String,\n"
"  val : Char\n"
") -> Bool {\n"
"  let other_values = values[key].remove(val)\n"
"  let mut result = true\n"
"  for val in other_values {\n"
"    result = result && eliminate(values, key, val)\n"
"  }\n"
"  return result\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:322
msgid ""
"These two functions apply heuristic strategies to each square they access. A"
" successful heuristic application introduces new squares to consider, "
"allowing these strategies to propagate widely across the grid. This is key "
"to quickly eliminating invalid options. In fact, this preprocessing can "
"already solve some simple Sudoku puzzles."
msgstr "这两个函数将启发式策略应用于它们访问的每个方格。成功的启发式应用会引入新的方格供考虑，从而使这些策略在整个网格中广泛传播。这是快速消除无效选项的关键。事实上，这种预处理已经可以解决一些简单的数独难题。"

#: ../../sources/sudoku/src/index.mbt.md:328
msgid ""
"let grid2 =\n"
"  #|0 0 3   0 2 0   6 0 0\n"
"  #|9 0 0   3 0 5   0 0 1\n"
"  #|0 0 1   8 0 6   4 0 0\n"
"  #|\n"
"  #|0 0 8   1 0 2   9 0 0\n"
"  #|7 0 0   0 0 0   0 0 8\n"
"  #|0 0 6   7 0 8   2 0 0\n"
"  #|\n"
"  #|0 0 2   6 0 9   5 0 0\n"
"  #|8 0 0   2 0 3   0 0 9\n"
"  #|0 0 5   0 1 0   3 0 0\n"
"\n"
"test {\n"
"  inspect(\n"
"    Grid::parse(grid2).format(),\n"
"    content=(\n"
"      #| 4  8  3 | 9  2  1 | 6  5  7\n"
"      #| 9  6  7 | 3  4  5 | 8  2  1\n"
"      #| 2  5  1 | 8  7  6 | 4  9  3\n"
"      #|---------+---------+---------\n"
"      #| 5  4  8 | 1  3  2 | 9  7  6\n"
"      #| 7  2  9 | 5  6  4 | 1  3  8\n"
"      #| 1  3  6 | 7  9  8 | 2  4  5\n"
"      #|---------+---------+---------\n"
"      #| 3  7  2 | 6  8  9 | 5  1  4\n"
"      #| 8  1  4 | 2  5  3 | 7  6  9\n"
"      #| 6  9  5 | 4  1  7 | 3  8  2\n"
"      #|\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:363
msgid ""
"If you are interested in artificial intelligence, you might recognize this "
"as a Constraint Satisfaction Problem (CSP), and `assign` and `eliminate` are"
" specialized arc consistency algorithms. For more on this topic, refer to "
"Chapter 6 of _Artificial Intelligence: A Modern Approach_."
msgstr ""
"如果您对人工智能感兴趣，您可能会将其视为约束满足问题 (CSP)，而'分配'和'消除'是专门的弧一致性算法。有关此主题的更多信息，请参阅 "
"Artificial Intelligence: A Modern Approach 第 6 章"

#: ../../sources/sudoku/src/index.mbt.md:368
msgid "Search"
msgstr "搜索"

#: ../../sources/sudoku/src/index.mbt.md:370
msgid ""
"After preprocessing, we can boldly use brute-force enumeration to search for"
" all feasible combinations. However, we can still use the heuristic "
"strategies during the search process. When trying to assign a value to a "
"square, we still use `assign`, which allows us to apply previous "
"optimizations to eliminate many invalid branches during the search."
msgstr ""
"经过预处理后，我们可以大胆地使用蛮力枚举来搜索所有可行的组合。但是，在搜索过程中，我们仍然可以使用启发式策略。当尝试为某个方块赋值时，我们仍然使用 "
"`assign`，这使我们能够应用先前的优化来消除搜索过程中的许多无效分支。"

#: ../../sources/sudoku/src/index.mbt.md:376
msgid ""
"Another point to note is that conflicts may arise during the search (when a "
"square's possible values are exhausted). Since mutable structures make "
"backtracking troublesome, we directly copy values each time we assign a "
"value."
msgstr "另外需要注意的是，搜索过程中可能会发生冲突（当一个方格的可能值耗尽时）。由于可变结构使回溯变得麻烦，因此我们每次分配值时都直接复制值。"

#: ../../sources/sudoku/src/index.mbt.md:380
msgid ""
"fn search(\n"
"  values : Grid[@immut/sorted_set.SortedSet[Char]],\n"
") -> Grid[@immut/sorted_set.SortedSet[Char]]? {\n"
"  if values.contains(fn(digits) { not(digits.length() == 1) }) {\n"
"    let mut minsq = \"\"\n"
"    let mut n = 10\n"
"    for sq in squares {\n"
"      let len = values[sq].length()\n"
"      if len > 1 {\n"
"        if len < n {\n"
"          n = len\n"
"          minsq = sq\n"
"        }\n"
"      }\n"
"    }\n"
"    for digit in values[minsq] {\n"
"      let another = values.copy()\n"
"      if assign(another, minsq, digit) {\n"
"        let temp = search(another)\n"
"        match temp {\n"
"          None => continue\n"
"          Some(v) => return Some(v)\n"
"        }\n"
"      }\n"
"    } nobreak {\n"
"      return None\n"
"    }\n"
"  } else {\n"
"    return Some(values)\n"
"  }\n"
"}\n"
"\n"
"fn solve(g : String) -> String {\n"
"  match search(Grid::parse(g)) {\n"
"    None => \"can't solve \\{g}\"\n"
"    Some(v) => v.format()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:421
msgid ""
"Let's run the example taken from "
"[magictour](http://magictour.free.fr/top95), a list of difficult Sudoku "
"puzzles, which is not easy for humans."
msgstr ""
"我们运行一个来自 [magictour](http://magictour.free.fr/top95) "
"（一个困难数独谜题列表，对人类来说并不容易）的例子"

#: ../../sources/sudoku/src/index.mbt.md:424
msgid ""
"let grid1 =\n"
"  #|4 . .   . . .   8 . 5\n"
"  #|. 3 .   . . .   . . .\n"
"  #|. . .   7 . .   . . .\n"
"  #|\n"
"  #|. 2 .   . . .   . 6 .\n"
"  #|. . .   . 8 .   4 . .\n"
"  #|. . .   . 1 .   . . .\n"
"  #|\n"
"  #|. . .   6 . 3   . 7 .\n"
"  #|5 . .   2 . .   . . .\n"
"  #|1 . 4   . . .   . . .\n"
"\n"
"test {\n"
"  inspect(\n"
"    solve(grid1),\n"
"    content=(\n"
"      #| 4  1  7 | 3  6  9 | 8  2  5\n"
"      #| 6  3  2 | 1  5  8 | 9  4  7\n"
"      #| 9  5  8 | 7  2  4 | 3  1  6\n"
"      #|---------+---------+---------\n"
"      #| 8  2  5 | 4  3  7 | 1  6  9\n"
"      #| 7  9  1 | 5  8  6 | 4  3  2\n"
"      #| 3  4  6 | 9  1  2 | 7  5  8\n"
"      #|---------+---------+---------\n"
"      #| 2  8  9 | 6  4  3 | 5  7  1\n"
"      #| 5  7  3 | 2  9  1 | 6  8  4\n"
"      #| 1  6  4 | 8  7  5 | 2  9  3\n"
"      #|\n"
"    ),\n"
"  )\n"
"}\n"
msgstr ""

#: ../../sources/sudoku/src/index.mbt.md:459
msgid ""
"Running on [MoonBit online IDE](https://try.moonbitlang.com/), It takes only"
" about 0.11 seconds to solve this Sudoku!"
msgstr "在 [MoonBit online IDE](https://try.moonbitlang.com/) 上运行，仅需大约 0.11 秒即可解决这个数独！"

#: ../../sources/sudoku/src/index.mbt.md:462
msgid "Conclusion"
msgstr "总结"

#: ../../sources/sudoku/src/index.mbt.md:464
msgid ""
"The purpose of games is to relieve boredom and bring joy. If playing a game "
"becomes more anxiety-inducing than exciting, it might go against the game "
"designer's original intent. The article demonstrated that simple elimination"
" methods and brute-force search can quickly solve some Sudoku puzzles. This "
"does not mean that Sudoku is not worth playing; rather, it reveals that one "
"should not be overly concerned with an unsolvable Sudoku puzzle."
msgstr "游戏的目的是为了缓解无聊并带来快乐。如果玩游戏让人感到焦虑而不是兴奋，那么它可能违背了游戏设计师的初衷。本文表明，简单的消除法和强力搜索可以快速解决一些数独难题。这并不意味着数独不值得玩；相反，它表明人们不应该过分担心无法解决的数独难题。"

#: ../../sources/sudoku/src/index.mbt.md:471
msgid "Let's play with MoonBit with ease!"
msgstr "让我们轻松玩转 MoonBit 吧！"

#: ../../sources/sudoku/src/index.mbt.md:473
msgid ""
"This tutorial references Norvig's blog: "
"[http://norvig.com/sudoku.html](http://norvig.com/sudoku.html)"
msgstr ""
"本教程参考了 Norvig "
"的博客：[http://norvig.com/sudoku.html](http://norvig.com/sudoku.html)"

