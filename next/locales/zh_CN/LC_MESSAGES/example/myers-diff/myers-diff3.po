# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../example/myers-diff/myers-diff3.md:1
msgid "Myers diff 3"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:3
msgid ""
"This article is the third in the [diff series](/example/myers-"
"diff/index.md). In the [previous part](/example/myers-diff/myers-diff2.md), "
"we explored the full Myers algorithm and its limitations. In this post, "
"we'll learn how to implement a variant of the Myers algorithm that operates "
"with linear space complexity."
msgstr ""
"本文是 [diff 系列](/example/myers-diff/index.md) 的第三篇。在 [上一部分](/example/myers-"
"diff/myers-diff2.md) 中，我们探讨了完整的 Myers 算法及其局限性。在这篇文章中，我们将学习如何实现 Myers "
"算法的一种变体，该算法具有线性空间复杂度。"

#: ../../example/myers-diff/myers-diff3.md:5
msgid "Divide and Conquer"
msgstr "分而治之"

#: ../../example/myers-diff/myers-diff3.md:7
msgid ""
"The linear variant of Myers' diff algorithm used by Git employs a concept "
"called the _Snake_ (sometimes referred to as the _Middle Snake_) to break "
"down the entire search process. A Snake in the edit graph represents a "
"diagonal movement of 0 to N steps after a single left or down move. The "
"linear Myers algorithm finds the middle Snake on the optimal edit path and "
"uses it to divide the entire edit graph into two parts. The subsequent steps"
" apply the same technique to the resulting subgraphs, eventually producing a"
" complete edit path."
msgstr ""
"Git 使用的 Myers 的 diff 算法的线性变体采用了一个称为 _Snake_（有时称为 _Middle "
"Snake_）的概念来分解整个搜索过程。编辑图中的 Snake 表示在一次向左或向下移动后的 0 到 N 步的对角线移动。线性 Myers "
"算法在最优编辑路径上找到中间的 Snake，并用它将整个编辑图分成两部分。随后的步骤将相同的技术应用于结果子图，最终生成完整的编辑路径。"

#: ../../example/myers-diff/myers-diff3.md:9
msgid ""
"    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14\n"
" 0  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 1  o---o---o---o---o---o---o\n"
"    |   | \\ |   |   |   |   |\n"
" 2  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 3  o---o---o---o---o---o---o\n"
"    |   |   |   |   | \\ |   |\n"
" 4  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 5  o---o---o---o---o---o---o\n"
"                              \\\n"
" 6                              @\n"
"                                  \\\n"
" 7                                  @---o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
" 8                                      o---o---o---o---o---o\n"
"                                        | \\ |   |   |   |   |\n"
" 9                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"10                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"11                                      o---o---o---o---o---o\n"
"                                        |   |   | \\ |   |   |\n"
"12                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"13                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   | \\ |\n"
"14                                      o---o---o---o---o---o\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:42
msgid ""
"A quick recap: The optimal edit path is the one that has the shortest "
"distance to the endpoint (a diagonal distance of zero), and there can be "
"more than one such path."
msgstr "简要回顾一下：最佳编辑路径是到端点的距离最短的路径（对角线距离为零），并且可以有多个这样的路径。"

#: ../../example/myers-diff/myers-diff3.md:44
msgid ""
"Attentive readers may have noticed a chicken-and-egg problem: to find a "
"Snake, you need an optimal edit path, but to get an optimal edit path, it "
"seems like you need to run the original Myers algorithm first."
msgstr ""
"细心的读者可能已经注意到一个鸡生蛋还是蛋生鸡的问题：为了找到 Snake，你需要一个最优的编辑路径，但是为了获得最优的编辑路径，你似乎需要先运行原始的 "
"Myers 算法。"

#: ../../example/myers-diff/myers-diff3.md:46
msgid ""
"In fact, the idea behind the linear Myers algorithm is somewhat "
"unconventional: it alternates the original Myers algorithm from both the "
"top-left and bottom-right corners, but without storing the history. Instead,"
" it simply checks if the searches from both sides overlap. When they do, the"
" overlapping portion is returned as the Middle Snake."
msgstr ""
"事实上，线性 Myers 算法背后的思想有些不寻常：它从左上角和右下角替换原始 Myers "
"算法，但不存储历史。相反，它只是检查两边的搜索是否重叠。当它们这样做时，重叠的部分作为 `Middle Snake` 返回。"

#: ../../example/myers-diff/myers-diff3.md:48
msgid ""
"This approach seems straightforward, but there are still some details to "
"sort out."
msgstr "这种方法似乎很简单，但仍有一些细节需要解决。"

#: ../../example/myers-diff/myers-diff3.md:50
msgid ""
"When searching from the bottom-right, the diagonal coordinate can no longer "
"be referred to as _k_. We need to define a new diagonal coordinate **c = k -"
" delta**. This coordinate is the mirror image of _k_, perfectly suited for "
"reverse direction search."
msgstr ""
"当从右下搜索时，对角线坐标不能再被称为 _k_。我们需要定义一个新的对角线坐标 **c = k - delta** 。这个坐标是 _k_ "
"的镜像，非常适合反向搜索。"

#: ../../example/myers-diff/myers-diff3.md:52
msgid ""
"        x                       k\n"
"                                  0     1     2     3\n"
"        0     1     2     3         \\     \\     \\     \\\n"
"  y  0  o-----o-----o-----o           o-----o-----o-----o\n"
"        |     |     |     |      -1   |     |     |     | \\\n"
"        |     |     |     |         \\ |     |     |     |   2\n"
"     1  o-----o-----o-----o           o-----o-----o-----o\n"
"        |     | \\   |     |      -2   |     | \\   |     | \\\n"
"        |     |   \\ |     |         \\ |     |   \\ |     |   1\n"
"     2  o-----o-----o-----o           o-----o-----o-----o\n"
"                                        \\     \\     \\     \\\n"
"                                        -3    -2    -1      0\n"
"                                                              c\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:68
msgid ""
"How do we determine if the searches overlap? Simply check if the position on"
" a diagonal line in the forward search has an _x_ value greater than that in"
" the reverse search. However, since the _k_ and _c_ coordinates differ for "
"the same diagonal, the conversion can be a bit tricky."
msgstr ""
"我们如何确定搜索是否重叠？只需检查正向搜索中对角线上的位置的 _x_ 值是否大于反向搜索中的 _x_ 值。但是，由于同一对角线的 _k_ 和 _c_ "
"坐标不同，因此转换可能有点棘手。"

#: ../../example/myers-diff/myers-diff3.md:70
msgid "Code Implementation"
msgstr "代码实现"

#: ../../example/myers-diff/myers-diff3.md:72
msgid ""
"We'll start by defining `Snake` and `Box` types, representing the middle "
"snake and the sub-edit graphs (since they're square, we call them `Box`)."
msgstr "我们将首先定义 `Snake` 和 `Box` 类型，代表 `middle snake` 和子编辑图（因为它们是方形的，所以我们称之为 `Box`）。"

#: ../../example/myers-diff/myers-diff3.md:74
msgid ""
"///\n"
"struct Box {\n"
"  left : Int\n"
"  right : Int\n"
"  top : Int\n"
"  bottom : Int\n"
"} derive(Show)\n"
"\n"
"///|\n"
"struct Snake {\n"
"  start : (Int, Int)\n"
"  end : (Int, Int)\n"
"} derive(Show)\n"
"\n"
"///|\n"
"fn Box::width(self : Self) -> Int {\n"
"  self.right - self.left\n"
"}\n"
"\n"
"///|\n"
"fn Box::height(self : Self) -> Int {\n"
"  self.bottom - self.top\n"
"}\n"
"\n"
"///|\n"
"fn Box::size(self : Self) -> Int {\n"
"  self.width() + self.height()\n"
"}\n"
"\n"
"///|\n"
"fn Box::delta(self : Self) -> Int {\n"
"  self.width() - self.height()\n"
"}\n"
"\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:80
msgid ""
"To avoid getting bogged down in details too early, let's assume we already "
"have a function `midpoint : (Box, Array[Line], Array[Line]) -> Snake?` to "
"find the middle snake. Then, we can build the function `find_path` to search"
" for the complete path."
msgstr ""
"为了避免太早陷入细节，让我们假设我们已经有一个函数：`midpoint : (Box, Array[Line], Array[Line]) -> "
"Snake?` 去找 `middle snake`。然后，我们可以构建函数 `find_path` 来搜索完整的路径。"

#: ../../example/myers-diff/myers-diff3.md:82
msgid ""
"///\n"
"fn Box::find_path(\n"
"  box : Self,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line],\n"
") -> Iter[(Int, Int)]? {\n"
"  guard box.midpoint(old~, new~) is Some(snake) else { None }\n"
"  let start = snake.start\n"
"  let end = snake.end\n"
"  let headbox = Box::{\n"
"    left: box.left,\n"
"    top: box.top,\n"
"    right: start.0,\n"
"    bottom: start.1,\n"
"  }\n"
"  let tailbox = Box::{\n"
"    left: end.0,\n"
"    top: end.1,\n"
"    right: box.right,\n"
"    bottom: box.bottom,\n"
"  }\n"
"  let head = headbox.find_path(old~, new~).unwrap_or(Iter::singleton(start))"
"\n"
"  let tail = tailbox.find_path(old~, new~).unwrap_or(Iter::singleton(end))\n"
"  Some(head.concat(tail))\n"
"}\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:88
msgid ""
"The implementation of `find_path` is straightforward, but `midpoint` is a "
"bit more complex:"
msgstr " `find_path` 的实现很简单，但 `midpoint` 有点复杂："

#: ../../example/myers-diff/myers-diff3.md:90
msgid "For a `Box` of size 0, return `None`."
msgstr "对于大小为 0 的 `Box`，返回 `None`。"

#: ../../example/myers-diff/myers-diff3.md:91
msgid ""
"Calculate the search boundaries. Since forward and backward searches each "
"cover half the distance, divide by two. However, if the size of the `Box` is"
" odd, add one more to the forward search boundary."
msgstr "计算搜索边界。因为向前和向后搜索各占一半的距离，所以除以 2。但是，如果 `Box` 的大小是奇数，则在正向搜索边界上再添加一个。"

#: ../../example/myers-diff/myers-diff3.md:92
msgid "Store the results of the forward and backward searches in two arrays."
msgstr "将向前和向后搜索的结果存储在两个数组中。"

#: ../../example/myers-diff/myers-diff3.md:93
msgid ""
"Alternate between forward and backward searches, returning `None` if no "
"result is found."
msgstr "在向前和向后搜索之间交替，如果没有找到结果则返回 `None`。"

#: ../../example/myers-diff/myers-diff3.md:95
msgid ""
"\n"
"///|\n"
"fn Box::midpoint(self : Self, old~ : Array[Line], new~ : Array[Line]) -> "
"Snake? {\n"
"  if self.size() == 0 {\n"
"    return None\n"
"  }\n"
"  let max = {\n"
"    let half = self.size() / 2\n"
"    if is_odd(self.size()) {\n"
"      half + 1\n"
"    } else {\n"
"      half\n"
"    }\n"
"  }\n"
"  let vf = BPArray::make(2 * max + 1, 0)\n"
"  vf[1] = self.left\n"
"  let vb = BPArray::make(2 * max + 1, 0)\n"
"  vb[1] = self.bottom\n"
"  for d = 0; d < max + 1; d = d + 1 {\n"
"    match self.forward(forward=vf, backward=vb, d, old~, new~) {\n"
"      None =>\n"
"        match self.backward(forward=vf, backward=vb, d, old~, new~) {\n"
"          None => continue\n"
"          res => return res\n"
"        }\n"
"      res => return res\n"
"    }\n"
"  } else {\n"
"    None\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:101
msgid ""
"The forward and backward searches have some modifications compared to the "
"original Myers algorithm, which need a bit of explanation:"
msgstr "与最初的 Myers 算法相比，向前和向后搜索有一些修改，需要做出解释："

#: ../../example/myers-diff/myers-diff3.md:103
msgid ""
"Since we need to return the snake, the search process must calculate the "
"previous coordinate (`px` stands for previous x)."
msgstr "因为我们需要返回 `snake`，所以搜索过程必须计算前一个坐标（`px` 代表前一个 x）。"

#: ../../example/myers-diff/myers-diff3.md:104
msgid ""
"The search now works within a `Box` (not the global edit graph), so "
"calculating `y` from `x` (or vice versa) requires conversion."
msgstr "搜索现在在 `Box`（不是全局编辑图）中工作，因此从 `x` 计算 `y` 需要转换（反之亦然）。"

#: ../../example/myers-diff/myers-diff3.md:105
msgid ""
"The backward search minimizes `y` as a heuristic strategy, but minimizing "
"`x` would also work."
msgstr "反向搜索最小化 `y` 是一种启发式策略，但最小化 `x` 也是可行的。"

#: ../../example/myers-diff/myers-diff3.md:107
msgid ""
"\n"
"///|\n"
"fn Box::forward(\n"
"  self : Self,\n"
"  forward~ : BPArray[Int],\n"
"  backward~ : BPArray[Int],\n"
"  depth : Int,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line],\n"
") -> Snake? {\n"
"  for k = depth; k >= -depth; k = k - 2 {\n"
"    let c = k - self.delta()\n"
"    let mut x = 0\n"
"    let mut px = 0\n"
"    if k == -depth || (k != depth && forward[k - 1] < forward[k + 1]) {\n"
"      x = forward[k + 1]\n"
"      px = x\n"
"    } else {\n"
"      px = forward[k - 1]\n"
"      x = px + 1\n"
"    }\n"
"    let mut y = self.top + (x - self.left) - k\n"
"    let py = if depth == 0 || x != px { y } else { y - 1 }\n"
"    while x < self.right && y < self.bottom && old[x].text == new[y].text {\n"
"      x = x + 1\n"
"      y = y + 1\n"
"    }\n"
"    forward[k] = x\n"
"    if is_odd(self.delta()) &&\n"
"      (c >= -(depth - 1) && c <= depth - 1) &&\n"
"      y >= backward[c] {\n"
"      return Some(Snake::{ start: (px, py), end: (x, y) })\n"
"    }\n"
"  }\n"
"  return None\n"
"}\n"
"\n"
"///|\n"
"fn Box::backward(\n"
"  self : Self,\n"
"  forward~ : BPArray[Int],\n"
"  backward~ : BPArray[Int],\n"
"  depth : Int,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line],\n"
") -> Snake? {\n"
"  for c = depth; c >= -depth; c = c - 2 {\n"
"    let k = c + self.delta()\n"
"    let mut y = 0\n"
"    let mut py = 0\n"
"    if c == -depth || (c != depth && backward[c - 1] > backward[c + 1]) {\n"
"      y = backward[c + 1]\n"
"      py = y\n"
"    } else {\n"
"      py = backward[c - 1]\n"
"      y = py - 1\n"
"    }\n"
"    let mut x = self.left + (y - self.top) + k\n"
"    let px = if depth == 0 || y != py { x } else { x + 1 }\n"
"    while x > self.left && y > self.top && old[x - 1].text == new[y - "
"1].text {\n"
"      x = x - 1\n"
"      y = y - 1\n"
"    }\n"
"    backward[c] = y\n"
"    if is_even(self.delta()) && (k >= -depth && k <= depth) && x <= "
"forward[k] {\n"
"      return Some(Snake::{ start: (x, y), end: (px, py) })\n"
"    }\n"
"  }\n"
"  return None\n"
"}\n"
msgstr ""

#: ../../example/myers-diff/myers-diff3.md:113
msgid "Conclusion"
msgstr "总结"

#: ../../example/myers-diff/myers-diff3.md:115
msgid ""
"In addition to the default diff algorithm, Git also offers another diff "
"algorithm called patience diff. It differs significantly from Myers diff in "
"approach and sometimes produces more readable diff results."
msgstr ""
"除了默认的 diff 算法之外，Git 还提供了另一种 diff 算法，称为 `patience diff`。它在方法上与 Myers diff "
"有很大不同，有时会产生更可读的 diff 结果。"

