# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../example/segment-tree/segment-tree2.md:1
msgid "Segment Trees (Part 2)"
msgstr "线段树（第二部分）"

#: ../../example/segment-tree/segment-tree2.md:3
msgid "Introduction"
msgstr "介绍"

#: ../../example/segment-tree/segment-tree2.md:5
msgid ""
"In the previous article, we discussed the basic implementation of a segment "
"tree. That tree only allowed range queries (single-point modifications and "
"queries were also possible), but it couldn't handle range modifications, "
"such as adding a value to all elements in a given range."
msgstr "在上一篇文章当中我们讨论了最基础线段树的实现，但那棵线段树只能做到区间的查询（当然单点的修改与查询也是可以的），但做不到区间的修改（一个经典的应用是区间加法，即整个区间都加上某个值）。"

#: ../../example/segment-tree/segment-tree2.md:7
msgid ""
"In this session, we will deepen the abstraction by introducing the concept "
"of **LazyTag** to handle range modifications, creating a more functional "
"segment tree."
msgstr "在本节当中我们将基于上次的线段树继续加深抽象，引入 LazyTag 的概念来解决区间修改的问题，完成一棵功能基本完备的线段树。"

#: ../../example/segment-tree/segment-tree2.md:9
msgid "How to Implement Range Modifications?"
msgstr "怎么做到区间修改？"

#: ../../example/segment-tree/segment-tree2.md:11
msgid ""
"First, let's imagine what happens if we add a number to all elements in a "
"range on the segment tree. How would we do this using a straightforward "
"approach?"
msgstr "先设想如果我们在线段树上给一个区间都加上某个数会发生什么？或者换种说法，以最简单的办法来说，我们是如何完成它的？"

#: ../../example/segment-tree/segment-tree2.md:13
msgid "![add to segment tree](/imgs/segment-tree-add.png)"
msgstr "![插入线段树](/imgs/segment-tree-add.png)"

#: ../../example/segment-tree/segment-tree2.md:13
msgid "add to segment tree"
msgstr "插入线段树"

#: ../../example/segment-tree/segment-tree2.md:15
msgid ""
"Take the segment tree from the last lesson as an example. In the figure "
"below, we add 1 to the range [4, 7]. You'll notice that we need to rebuild "
"and maintain all parts of the tree that cover this range, which is too "
"costly."
msgstr ""
"以上节课的线段树为例，上面这张图中，我们对 [4, 7] 的区间都加上 "
"1。这时候我们会发现这需要把涉及到这段区间的所有树上部分都重新构建维护一次，这个时间代价我们肯定是不能接受的。"

#: ../../example/segment-tree/segment-tree2.md:17
msgid "Is there a better way? Of course! We can use **LazyTag**."
msgstr "那有没有更好的方法？当然有！可以使用 LazyTag！"

#: ../../example/segment-tree/segment-tree2.md:19
msgid "![lazytag](/imgs/segment-tree-lazytag.png)"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:19
msgid "lazytag"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:21
msgid ""
"Consider that instead of modifying every affected part, we mark the smallest"
" covering range with a \"+1\" tag. Based on the length of the range, we "
"calculate its value and merge it upward. Following the complexity of "
"querying from the last lesson, this operation would be O(log N)."
msgstr ""
"设想我们在操作时，仅把 [4, 7] 区间的最少覆盖区间（就像查询需要的区间一样）打上一个“+1” "
"的标记，并且根据这个区间的长度计算他应该有的值，然后合并上去，根据上节课 query 的复杂度类推，这个操作的复杂度应为 O(Log N) 的。"

#: ../../example/segment-tree/segment-tree2.md:23
msgid ""
"However, there's a problem. While querying ranges like [1, 7] or [4, 7] "
"works fine, what if we query [4, 6]? The minimal covering ranges are [4, 5] "
"and [6, 6], not [4, 7], so our tag doesn't propagate to lower nodes."
msgstr ""
"但有个问题，现在这种处理方法查询 [1, 7] 或者 [4, 7] 这些区间都没有问题，但如果我们要查询 [4, 6] 呢？容易发现对于区间 [4, "
"6]，它的最小覆盖区间是 [4, 5] 与 [6, 6] 而不是 [4, 7]，我们的 Tag 并没有对下面的节点生效。"

#: ../../example/segment-tree/segment-tree2.md:25
msgid "Here’s where the **Lazy** aspect of LazyTag comes into play."
msgstr "下面我们就要用到 LazyTag 除了 Tag 外的另一个性质：Lazy。"

#: ../../example/segment-tree/segment-tree2.md:27
msgid "![add using lazytag](/imgs/segment-tree-add-lazytag.png)"
msgstr "![使用 lazytag 插入](/imgs/segment-tree-add-lazytag.png)"

#: ../../example/segment-tree/segment-tree2.md:27
msgid "add using lazytag"
msgstr "使用 lazytag 插入"

#: ../../example/segment-tree/segment-tree2.md:29
msgid ""
"We define that when querying a node with a tag, the tag is distributed to "
"its child nodes. These child nodes inherit the tag and compute their values "
"based on their length. The following diagram shows the propagation of the "
"tag downward when querying [4, 6]."
msgstr ""
"我们规定在查询到某个节点时，如果当前节点上有一个加法的 Tag，就把它分发给下面的节点，下面的节点同样接收这个 Tag "
"并且根据自己的长度计算出自己应有的值。上图展示了在查询区间 [4, 6] 的结果时发生的 Tag 向下分发的操作。非常符合直觉的，叶子节点接收 Tag "
"之后可以直接转换为自身的改变而不需要再保留 Tag。"

#: ../../example/segment-tree/segment-tree2.md:31
msgid ""
"This \"lazy propagation\" ensures that each modification is completed in "
"O(log N), while ensuring correct query results."
msgstr "容易发现像这样的“懒惰下推 Tag”的方法可以保证每次修改的操作在 O(Log N) 的时间内完成，还可以保证查询时可以查询到正确的结果！"

#: ../../example/segment-tree/segment-tree2.md:34
msgid ""
"Some may wonder about overlapping tags. However, additive tags like these "
"merge seamlessly without affecting the total sum of a node."
msgstr "可能有些同学会疑问如果 Tag 重叠会怎么样，如果我们尝试一下就可以发现上文的这种加法 Tag 之间其实具有良好的合并性，不影响该节点总和的计算。"

#: ../../example/segment-tree/segment-tree2.md:37
msgid "Let’s dive into the code!"
msgstr "让我们来试试代码实现吧！"

#: ../../example/segment-tree/segment-tree2.md:39
msgid "Implementation"
msgstr "实现"

#: ../../example/segment-tree/segment-tree2.md:41
msgid "Basic Definition"
msgstr "基础定义"

#: ../../example/segment-tree/segment-tree2.md:43
msgid ""
"In the previous code, we defined the segment tree using `enum`. However, "
"none of the elements were clearly named, which was manageable when the data "
"size was small. Now, we need to add **Tag** and **Length** attributes, so it"
" makes sense to use labeled arguments in the `enum` definition:"
msgstr ""
"上节课的代码当中使用 enum 定义了线段树，但是每个 enum "
"当中的每个元素是用来干什么的其实没有名称标识，因为数据量比较小，对我们的心智负担影响不大，但目前我们需要添加 Tag 和 Length "
"属性存储，会显得匹配和定义的时候无法区分参数。所以我们可以使用 enum 的 labeled-argument 写法来完成更好的定义："

#: ../../example/segment-tree/segment-tree2.md:45
msgid ""
"\n"
"///|\n"
"enum Data {\n"
"  Data(sum~ : Int, len~ : Int)\n"
"}\n"
"\n"
"///|\n"
"enum LazyTag {\n"
"  Nil\n"
"  Tag(Int)\n"
"}\n"
"\n"
"///|\n"
"enum Node {\n"
"  Nil\n"
"  Node(data~ : Data, tag~ : LazyTag, left~ : Node, right~ : Node)\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:51
msgid ""
"This allows for clearer initialization and pattern matching, making the code"
" easier to follow. We've also abstracted the `Data` type, adding a `len` "
"attribute to represent the length of the current range, which is useful for "
"calculating the node's value."
msgstr ""
"这样我们就清晰地完成了对数据、LazyTag 和节点结构的定义，在下面初始化与模式匹配时将会更加清晰。另外，我们把 Data "
"类型单独抽象出来，比上节课多了一个 len 属性，用来标记当前区间的长度，以配合 Tag 计算当前节点的值。"

#: ../../example/segment-tree/segment-tree2.md:53
msgid "Building the Tree"
msgstr "建树"

#: ../../example/segment-tree/segment-tree2.md:55
msgid ""
"Similar to the last lesson, before building the tree, we need to define the "
"addition operations between `Node` types. However, since we’ve abstracted "
"`Data`, we must account for its addition too:"
msgstr "我们依然像上一节一样在编写建树逻辑之前需要先考虑 Node 类型之间的加法，但本节中因为我们单独抽象了 Data，所以也要考虑他们之间的加法："

#: ../../example/segment-tree/segment-tree2.md:57
msgid ""
"\n"
"///|\n"
"impl Add for Data with add(self : Data, v : Data) -> Data {\n"
"  match (self, v) {\n"
"    (Data(sum=a, len=len_a), Data(sum=b, len=len_b)) =>\n"
"      Data(sum=a + b, len=len_a + len_b)\n"
"  }\n"
"}\n"
"\n"
"///|\n"
"impl Add for Node with add(self : Node, v : Node) -> Node {\n"
"  match (self, v) {\n"
"    (Node(data=l, ..), Node(data=r, ..)) =>\n"
"      Node(data=l + r, tag=Nil, left=self, right=v)\n"
"    (Node(_), Nil) => self\n"
"    (Nil, Node(_)) => v\n"
"    (Nil, Nil) => Nil\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:63
msgid ""
"Here, we’ve ignored merging LazyTags for now and set the resulting tag to "
"`Nil` because once a node is reached, its parent’s LazyTag no longer "
"applies."
msgstr ""
"可以发现这里暂时还没有考虑 LazyTag 的合并，而是认为他们加法的结果得到的节点的 LazyTag 均为 "
"Nil，这是很好理解的，如果已经走到一个节点，那么它的父节点当然会是没有 LazyTag 的。"

#: ../../example/segment-tree/segment-tree2.md:65
msgid "Now, we can implement the tree-building function:"
msgstr "接下来就可以写出建树的代码，这与上节非常相似："

#: ../../example/segment-tree/segment-tree2.md:67
msgid ""
"\n"
"///|\n"
"fn build(data : ArrayView[Int]) -> Node {\n"
"  if data.length() == 1 {\n"
"    Node(data=Data(sum=data[0], len=1), tag=Nil, left=Nil, right=Nil)\n"
"  } else {\n"
"    let mid = (data.length() + 1) >> 1\n"
"    build(data[0:mid]) + build(data[mid:])\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:73
msgid "LazyTag and Range Modifications"
msgstr "LazyTag 与区间修改的实现"

#: ../../example/segment-tree/segment-tree2.md:75
msgid ""
"We define a node receiving a LazyTag as `apply`. The key logic lies in here:"
" the node receiving the LazyTag may not own a LazyTag, and if it did own "
"one, how do we merge them? And how do we compute the new value of the node "
"based on the LazyTag?"
msgstr ""
"我们把一个节点接受一个 LazyTag 的行为定义为 apply，容易发现其实真正的核心逻辑就在这里，当前接受上方 LazyTag "
"的节点身上不一定是否有 LazyTag，而如果有，又应该怎么合并？怎么根据 LazyTag 计算当前节点新的值？答案都在这个操作当中。"

#: ../../example/segment-tree/segment-tree2.md:77
msgid ""
"A decent implementation is to define a new addition operation to merge "
"LazyTags, and define an `apply` function for Node to receive it."
msgstr ""
"一个很好的实现方法是我们对 LazyTag 再单独定义一套加法运算来实现他们的合并，然后为 Node 类型编写一个 apply 函数来接收一个 "
"LazyTag。"

#: ../../example/segment-tree/segment-tree2.md:80
msgid ""
"\n"
"///|\n"
"impl Add for LazyTag with add(self : LazyTag, v : LazyTag) -> LazyTag {\n"
"  match (self, v) {\n"
"    (Tag(a), Tag(b)) => Tag(a + b)\n"
"    (Nil, t) | (t, Nil) => t\n"
"  }\n"
"}\n"
"\n"
"///|\n"
"fn Node::apply(self : Node, v : LazyTag) -> Node {\n"
"  match (self, v) {\n"
"    (Node(data=Data(sum=a, len=length), tag~, left~, right~), Tag(v) as "
"new_tag) =>\n"
"      Node(\n"
"        data=Data(sum=a + v * length, len=length),\n"
"        tag=tag + new_tag,\n"
"        left~,\n"
"        right~,\n"
"      )\n"
"    (_, Nil) => self\n"
"    (Nil, _) => Nil\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:86
msgid ""
"Here is the core part of this section: compute the correct node's value with"
" the segment's length and the value of LazyTag."
msgstr "这是我们这节课最核心的地方，根据当前区间长度和 LazyTag 的值计算出了当前节点的正确数值，这样我们就有了 LazyTag 的实现。"

#: ../../example/segment-tree/segment-tree2.md:88
msgid "Then how do we implement range modifications?"
msgstr "怎么做到区间修改？"

#: ../../example/segment-tree/segment-tree2.md:90
msgid ""
"\n"
"///|\n"
"fn Node::modify(\n"
"  self : Node,\n"
"  l : Int,\n"
"  r : Int,\n"
"  modify_l : Int,\n"
"  modify_r : Int,\n"
"  tag : LazyTag,\n"
") -> Node {\n"
"  if modify_l > r || l > modify_r {\n"
"    self\n"
"  } else if modify_l <= l && modify_r >= r {\n"
"    self.apply(tag)\n"
"  } else {\n"
"    guard self is Node(left~, right~, ..)\n"
"    let mid = (l + r) >> 1\n"
"    left.modify(l, mid, modify_l, modify_r, tag) +\n"
"    right.modify(mid + 1, r, modify_l, modify_r, tag)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:96
msgid ""
"The logic is similar to the query function from the previous lesson, but now"
" each relevant node applies the necessary LazyTag for the modification."
msgstr "逻辑实际上与上节课编写的 query 大差不差，只是每个地方都让对应的节点 apply 了我们需要修改的值（作为 LazyTag）。"

#: ../../example/segment-tree/segment-tree2.md:98
msgid ""
"When we arrive here, we find that, even with the range modification, it's "
"still a persistent, or **Immutable** segment tree. The `modify` function "
"will return the recently created segment tree, without changing the original"
" one, and the semantics of recurring and merging represent this vividly."
msgstr ""
"不过写到这里我们可以发现，这棵线段树就算加入了区间修改之后居然还是一个可持久化的，或者说 Immutable 的线段树！我们的 modify "
"函数将会返回最新的那棵线段树，并没有对原来的线段树作任何改变，而我们的递归与合并语义非常明显的体现了这一点。"

#: ../../example/segment-tree/segment-tree2.md:100
msgid ""
"This means that using these kind of implementations (ADT(enum), recursion) "
"for meeting immutable requirements is natural and elegant. With the garbage "
"collection mechanism of MoonBit, we don't need to use pointers "
"**explicitly** for some relationships in recurring ADT(enum), and we don't "
"need to take care of the memory."
msgstr ""
"这说明在一些 Immutable 的需求上上采用这类写法（ADT(enum)、递归）是非常优雅而且自然的。而且 MoonBit 语言存在垃圾回收机制 "
"(GC)，所以在无限递归的 ADT(enum) 当中不需要**显式地**用指针来指代一些关系，我们并不需要关心内存里面发生了什么。"

#: ../../example/segment-tree/segment-tree2.md:102
msgid ""
"Readers unfamiliar with the functional programming languages may not notice "
"this, but we actually always profit from it. For example, writing a "
"`ConsList` in Rust using ADT(enum), we usually need:"
msgstr ""
"很多对函数式编程语言不熟悉的读者可能使用 MoonBit 时没有太关注到这个问题，但其实我们一直从中受益，比如如果我们需要在 Rust 当中使用 "
"ADT(enum) 来写一个 ConsList，我们往往需要："

#: ../../example/segment-tree/segment-tree2.md:104
msgid ""
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:111
msgid "But in MoonBit, we only need:"
msgstr "但在 MoonBit，我们只需要："

#: ../../example/segment-tree/segment-tree2.md:113
msgid ""
"enum List[T] {\n"
"  Cons(T, List[T])\n"
"  Nil\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:120
msgid "GC is really interesting!"
msgstr "GC 真的很有趣！"

#: ../../example/segment-tree/segment-tree2.md:122
msgid "Queries"
msgstr "查询"

#: ../../example/segment-tree/segment-tree2.md:124
msgid "For queries, we need to remember to push the LazyTag downwards:"
msgstr "查询部分只要记得需要下推 LazyTag 即可。"

#: ../../example/segment-tree/segment-tree2.md:126
msgid ""
"\n"
"///|\n"
"let empty_node : Node = Node(\n"
"  data=Data(sum=0, len=0),\n"
"  tag=Nil,\n"
"  left=Nil,\n"
"  right=Nil,\n"
")\n"
"\n"
"///|\n"
"fn Node::query(\n"
"  self : Node,\n"
"  l : Int,\n"
"  r : Int,\n"
"  query_l : Int,\n"
"  query_r : Int,\n"
") -> Node {\n"
"  if query_l > r || l > query_r {\n"
"    empty_node\n"
"  } else if query_l <= l && query_r >= r {\n"
"    self\n"
"  } else {\n"
"    guard self is Node(tag~, left~, right~, ..)\n"
"    let mid = (l + r) >> 1\n"
"    left.apply(tag).query(l, mid, query_l, query_r) +\n"
"    right.apply(tag).query(mid + 1, r, query_l, query_r)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/segment-tree/segment-tree2.md:132
msgid "Conclusion"
msgstr "总结"

#: ../../example/segment-tree/segment-tree2.md:134
msgid ""
"With this, we have a segment tree that supports range modifications and is "
"much more functional!"
msgstr "到这里我们就完成了一棵支持区间修改的，更加完美的线段树！"

#: ../../example/segment-tree/segment-tree2.md:136
msgid ""
"In the next lesson, we’ll add multiplication support to the segment tree and"
" explore some use cases for immutable segment trees. Stay tuned!"
msgstr ""
"接下来，在最后一节课当中我们将会学习如何给当前这棵线段树再加入一个“乘法操作”，以及探索一些 Immutable "
"线段树的应用场景。感兴趣的读者可以提前自行了解。"

#: ../../example/segment-tree/segment-tree2.md:138
msgid "Full code is available [here](path:/sources/segment-tree/src/part2/top.mbt)."
msgstr "完整代码在 [这里](path:/sources/segment-tree/src/part2/top.mbt)。"

