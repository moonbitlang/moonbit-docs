# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2026, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2026.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-04 10:54+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../example/gmachine/gmachine-2.md:1
msgid "G-Machine 2"
msgstr "G-Machine 第二部分"

#: ../../example/gmachine/gmachine-2.md:3
msgid ""
"This article is the second in the series on implementing lazy evaluation in "
"MoonBit. In the first part, we explored the purposes of lazy evaluation and "
"a typical abstract machine for lazy evaluation, the G-Machine, and "
"implemented some basic G-Machine instructions. In this article, we will "
"further extend the G-Machine implementation from the previous article to "
"support `let` expressions and basic arithmetic, comparison, and other "
"operations."
msgstr ""
"本文是 MoonBit 实现惰性求值系列的第二篇。在第一篇中，我们探讨了惰性求值的目的，介绍了典型的惰性求值抽象机器 G-Machine "
"并实现了它的一些基本指令。在本文中，我们将延续前文基础，进一步扩展 G-Machine 的实现以支持 `let` 表达式及基础算术，比较等运算。"

#: ../../example/gmachine/gmachine-2.md:5
msgid "let Expressions"
msgstr "let 表达式"

#: ../../example/gmachine/gmachine-2.md:7
msgid ""
"The `let` expression in coreF differs slightly from that in MoonBit. A `let`"
" expression can create multiple variables but can only be used within a "
"limited scope. Here is an example:"
msgstr ""
"coreF 中的 `let` 表达式与 MoonBit 略有差异。MoonBit 的 `let` "
"表达式可以创建多个变量，但只能在有限的范围内使用。示例如下："

#: ../../example/gmachine/gmachine-2.md:9
msgid ""
"{\n"
"  let x = n + m\n"
"  let y = x + 42\n"
"  x * y\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:17
msgid "Equivalent coreF expression:"
msgstr "对应的 coreF 表达式："

#: ../../example/gmachine/gmachine-2.md:19
msgid ""
"(let ([x (add n m)]\n"
"      [y (add x 42)])\n"
"  (mul x y)) ;; xy can only be used within let\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:25
msgid ""
"It is important to note that coreF's `let` expressions must follow a "
"sequential order. For example, the following is not valid:"
msgstr "需要注意 coreF 中的 `let` 表达式必须按顺序执行，如下代码是无效的："

#: ../../example/gmachine/gmachine-2.md:27
msgid ""
"(let ([y (add x 42)]\n"
"      [x (add n m)])\n"
"  (mul x y))\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:33
msgid ""
"In contrast, `letrec` is more complex as it allows the local variables "
"defined to reference each other without considering the order of their "
"definitions."
msgstr "相比之下，`letrec` 允许本地变量不考虑定义顺序下相互引用，从而更加复杂。 "

#: ../../example/gmachine/gmachine-2.md:35
msgid ""
"Before implementing `let` (and the more complex `letrec`), we first need to "
"modify the current parameter passing method. The local variables created by "
"`let` should intuitively be accessed in the same way as parameters, but the "
"local variables defined by `let` do not correspond to `NApp` nodes. "
"Therefore, we need to adjust the stack parameters before calling the "
"supercombinator."
msgstr ""
"在实现 `let`（和更复杂的 `letrec`）表达式之前，我们首先需要修改当前的参数传递方法。`let` 创建的本地变量应该像参数一样访问，但 "
"`let` 中的本地变量不对应 NApp 节点，因此我们需要在调用超组合子之前调整栈参数。"

#: ../../example/gmachine/gmachine-2.md:37
msgid ""
"The adjustment is done in the implementation of the `Unwind` instruction. If"
" the supercombinator has no parameters, it is the same as the original "
"unwind. When there are parameters, the top address of the supercombinator "
"node is discarded, and the `rearrange` function is called."
msgstr ""
"该调整在执行 `Unwind` 指令的过程中完成。如果超组合子没有参数，则与原始 `unwind` "
"相同。当存在参数时，超组合子节点的顶部地址会被丢弃，并开始调用 `rearrange` 函数。"

#: ../../example/gmachine/gmachine-2.md:39
msgid ""
"fn GState::rearrange(self : GState, n : Int) -> Unit {\n"
"  let appnodes = self.stack.take(n)\n"
"  let args = appnodes.map(fn(addr) {\n"
"    guard self.heap[addr] is NApp(_, arg)\n"
"    arg\n"
"  })\n"
"  self.stack = args + appnodes.drop(n - 1)\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:45
msgid ""
"The `rearrange` function assumes that the first N addresses on the stack "
"point to a series of `NApp` nodes. It keeps the bottommost one (used as "
"Redex update), cleans up the top N-1 addresses, and then places N addresses "
"that directly point to the parameters."
msgstr ""
"`rearrange` 函数假设堆栈上的前 N 个地址指向一系列 `NApp` 节点。它保留最底部的地址（用于 Redex 更新），清理栈顶的 N-1 "
"个地址，然后将 N 个地址放置在栈中，这些地址直接指向参数。"

#: ../../example/gmachine/gmachine-2.md:47
msgid ""
"After this, both parameters and local variables can be accessed using the "
"same command by changing the `PushArg` instruction to a more general `Push` "
"instruction."
msgstr "在这之后，通过将 `PushArg` 指令更改为更通用的 `Push` 指令，参数和局部变量都可以使用相同的命令进行访问。"

#: ../../example/gmachine/gmachine-2.md:49
msgid ""
"fn GState::push(self : GState, offset : Int) -> Unit {\n"
"  // Push(n) a0 : . . . : an : s\n"
"  //     =>  an : a0 : . . . : an : s\n"
"  let addr = self.stack.unsafe_nth(offset)\n"
"  self.put_stack(addr)\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:55
msgid ""
"The next issue is that we need something to clean up. Consider the following"
" expression:"
msgstr "接下来我们需要清理一些不再使用的数据或状态，考虑以下表达式："

#: ../../example/gmachine/gmachine-2.md:57
msgid ""
"(let ([x1 e1]\n"
"      [x2 e2])\n"
"  expr)\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:63
msgid ""
"After constructing the graph corresponding to the expression `expr`, the "
"stack still contains addresses pointing to e1 and e2 (corresponding to "
"variables x1 and x2), as shown below (the stack grows from bottom to top):"
msgstr "在构建与表达式 expr 对应的图之后，栈中仍然包含指向 e1 和 e2 的地址（分别对应变量 x1 和 x2）,如下所示（栈从下到上增长）"

#: ../../example/gmachine/gmachine-2.md:65
msgid ""
"<Address pointing to expr>\n"
"       |\n"
"<Address pointing to x2>\n"
"       |\n"
"<Address pointing to x1>\n"
"       |\n"
"...remaining stack...\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:75
msgid ""
"Therefore, we need a new instruction to clean up these no longer needed "
"addresses. It is called `Slide`. As the name suggests, the function of "
"`Slide(n)` is to skip the first address and delete the following N "
"addresses."
msgstr "因此，我们需要一个新的指令来清理这些不再需要的地址。它被称为 `Slide`。顾名思义，`Slide(n)` 的功能是跳过第一个地址并删除以下 N 个地址"

#: ../../example/gmachine/gmachine-2.md:77
msgid ""
"fn GState::slide(self : GState, n : Int) -> Unit {\n"
"  let addr = self.pop1()\n"
"  self.stack = self.stack.drop(n).prepend(addr)\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:83
msgid ""
"Now we can compile `let`. We will compile the expressions corresponding to "
"local variables using the `compileC` function. Then, traverse the list of "
"variable definitions (`defs`), compile and update the corresponding offsets "
"in order. Finally, use the passed `comp` function to compile the main "
"expression and add the `Slide` instruction to clean up the unused addresses."
msgstr ""
"现在我们来使用 let 表达式，我们将用 compileC "
"函数编译与本地变量对应的表达式。然后，遍历变量定义（`defs`）列表，依次编译并更新相应的偏移量。最后，使用传入的 `comp` "
"函数编译主表达式，并添加 `Slide` 指令来清理不使用的地址。"

#: ../../example/gmachine/gmachine-2.md:85
msgid ""
"Compiling the main expression using the passed function makes it easy to "
"reuse when adding subsequent features."
msgstr "使用传入的函数编译主表达式，有助于在后续添加新功能时实现代码的高效复用。"

#: ../../example/gmachine/gmachine-2.md:87
msgid ""
"fn compileLet(\n"
"  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],\n"
"  defs : List[(String, RawExpr[String])],\n"
"  expr : RawExpr[String],\n"
"  env : List[(String, Int)]\n"
") -> List[Instruction] {\n"
"  let (env, codes) = loop (env, @list.empty(), defs) {\n"
"    (env, acc, Empty) => (env, acc)\n"
"    (env, acc, More((name, expr), tail=rest)) => {\n"
"      let code = expr.compileC(env)\n"
"      let env = argOffset(1, env).prepend((name, 0))\n"
"      continue (env, acc + code, rest)\n"
"    }\n"
"  }\n"
"  codes + comp(expr, env) + @list.from_array([Slide(defs.length())])\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:93
msgid ""
"The semantics of `letrec` are more complex - it allows the N variables "
"within the expression to reference each other, so we need to pre-allocate N "
"addresses and place them on the stack. We need a new instruction: "
"`Alloc(N)`, which pre-allocates N `NInd` nodes and pushes the addresses onto"
" the stack sequentially. The addresses in these indirect nodes are negative "
"and only serve as placeholders."
msgstr ""
"`letrec`的语义更加复杂——它允许表达式中的 N 个变量相互引用，因此我们需要预先分配 N "
"个地址并将其放置在堆栈上。我们需要一个新的指令：`Alloc（N）`，它预先分配 N "
"个`NInd`节点，并将地址顺序推送到堆栈上。这些间接节点中的地址是负数，仅用作占位符。"

#: ../../example/gmachine/gmachine-2.md:95
msgid ""
"fn GState::alloc_nodes(self : GState, n : Int) -> Unit {\n"
"  let dummynode : Node = NInd(Addr(-1))\n"
"  for i = 0; i < n; i = i + 1 {\n"
"    let addr = self.heap.alloc(dummynode)\n"
"    self.put_stack(addr)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:101
msgid "The steps to compile letrec are similar to `let`:"
msgstr "`letrec`的用法与`let`语句类似"

#: ../../example/gmachine/gmachine-2.md:103
msgid "Use `Alloc(n)` to allocate N addresses."
msgstr "使用`Alloc(n)`来分配 N 个节点"

#: ../../example/gmachine/gmachine-2.md:104
msgid "Use the `loop` expression to build a complete environment."
msgstr "使用`loop`表达式构建一个完整的环境"

#: ../../example/gmachine/gmachine-2.md:105
msgid ""
"Compile the local variables in `defs`, using the `Update` instruction to "
"update the results to the pre-allocated addresses after compiling each one."
msgstr "在`defs`中编译本地变量，然后使用`Update`指令将结果更新到预先分配好的地址。"

#: ../../example/gmachine/gmachine-2.md:106
msgid "Compile the main expression and use the `Slide` instruction to clean up."
msgstr "编译主表达式，并使用`Slide`指令进行清理。"

#: ../../example/gmachine/gmachine-2.md:108
msgid ""
"fn compileLetrec(\n"
"  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],\n"
"  defs : List[(String, RawExpr[String])],\n"
"  expr : RawExpr[String],\n"
"  env : List[(String, Int)]\n"
") -> List[Instruction] {\n"
"  let mut env = env\n"
"  loop defs {\n"
"    Empty => ()\n"
"    More((name, _), tail=rest) => {\n"
"      env = argOffset(1, env).prepend((name, 0))\n"
"      continue rest\n"
"    }\n"
"  }\n"
"  let n = defs.length()\n"
"  fn compileDefs(\n"
"    defs : List[(String, RawExpr[String])],\n"
"    offset : Int\n"
"  ) -> List[Instruction] {\n"
"    match defs {\n"
"      Empty => comp(expr, env) + @list.from_array([Slide(n)])\n"
"      More((_, expr), tail=rest) =>\n"
"        expr.compileC(env) + compileDefs(rest, offset - "
"1).prepend(Update(offset))\n"
"    }\n"
"  }\n"
"\n"
"  compileDefs(defs, n - 1).prepend(Alloc(n))\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:114
msgid "Adding Primitives"
msgstr "添加原语"

#: ../../example/gmachine/gmachine-2.md:116
msgid ""
"From this step, we can finally perform basic integer operations such as "
"arithmetic, comparison, and checking if two numbers are equal. First, modify"
" the `Instruction` type to add related instructions."
msgstr "从这步开始，我们终于可以开始执行基本的整数运算，如算术、比较与检查两个数字是否相等。首先，修改 `Instruction`类型以添加相关指令。"

#: ../../example/gmachine/gmachine-2.md:118
msgid ""
"  Add\n"
"  Sub\n"
"  Mul\n"
"  Div\n"
"  Neg\n"
"  Eq // ==\n"
"  Ne // !=\n"
"  Lt // <\n"
"  Le // <=\n"
"  Gt // >\n"
"  Ge // >=\n"
"  Cond(List[Instruction], List[Instruction])\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:133
msgid ""
"At first glance, implementing these instructions seems simple. Take `Add` as"
" an example: just pop two top addresses from the stack, retrieve the "
"corresponding numbers from memory, perform the operation, and push the "
"result address back onto the stack."
msgstr "实现这些指令乍看上去似乎很简单。以`Add`为例：只需从栈中弹出两个地址，获取对应的数字，执行加法操作，然后把结果的地址推回栈中。"

#: ../../example/gmachine/gmachine-2.md:135
msgid ""
"fn add(self : GState) -> Unit {\n"
"  let (a1, a2) = self.pop2() // Pop two top addresses\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let newnode = Node::NNum(n1 + n2)\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.putStack(addr)\n"
"    }\n"
"    ......\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:149
msgid ""
"However, the next problem we face is that this is a lazy evaluation "
"language. The parameters of `add` are likely not yet computed (i.e., not "
"`NNum` nodes). We also need an instruction that can force a computation to "
"give a result or never stop computing. We call it `Eval` (short for "
"Evaluation)."
msgstr ""
"然而，接下来我们面临的问题是：这是一个惰性求值的语言。在惰性求值中，传递给 `add` 的参数很可能还没有被计算（即它们可能不是 `NNum "
"`节点，而是尚未计算的表达式）。因此，我们需要一种指令来强制执行计算，确保获取结果，或者在某些情况下，保证计算不会停下来。我们称之为 `Eval`（即 "
"Evaluation 缩写）。"

#: ../../example/gmachine/gmachine-2.md:151
msgid ""
"In jargon, the result of such a computation is called Weak Head Normal Form "
"(WHNF)."
msgstr "在术语中，这种计算的结果称为弱头范式（WHNF）。"

#: ../../example/gmachine/gmachine-2.md:153
msgid ""
"At the same time, we need to modify the structure of `GState` and add a "
"state called `dump`. Its type is `List[(List[Instruction], List[Addr])]`, "
"used by `Eval` and `Unwind` instructions."
msgstr ""
"同时我们需要修改 `GState` 的架构并加入 `dump` 的状态，类型是 `List[(List[Instruction], "
"List[Addr])]`，使用 `Eval` 和 `Unwind` 指令的功能 "

#: ../../example/gmachine/gmachine-2.md:155
msgid "The implementation of the `Eval` instruction is not complicated:"
msgstr "执行`Eval`指令并不复杂"

#: ../../example/gmachine/gmachine-2.md:157
msgid "Pop the top address of the stack."
msgstr "弹出堆栈的顶部地址"

#: ../../example/gmachine/gmachine-2.md:159
msgid ""
"Save the current unexecuted instruction sequence and stack (by putting them "
"into the dump)."
msgstr "保存当前未执行的指令序列和栈（通过将它们放入 `dump` 中）"

#: ../../example/gmachine/gmachine-2.md:161
msgid "Clear the current stack and place the previously saved address."
msgstr "清空当前栈并放入先前保存的地址。"

#: ../../example/gmachine/gmachine-2.md:163
msgid "Clear the current instruction sequence and place the `Unwind` instruction."
msgstr "清空当前的指令序列，并放入 `Unwind `指令"

#: ../../example/gmachine/gmachine-2.md:165
msgid ""
"This is similar to how strict evaluation languages handle saving caller "
"contexts, but practical implementations would use more efficient methods."
msgstr "这与严格求值语言中保存调用者上下文的方式类似，但在实际实现中会采用更高效的方法。"

#: ../../example/gmachine/gmachine-2.md:167
msgid ""
"fn GState::eval(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  self.put_dump(self.code, self.stack)\n"
"  self.stack = @list.from_array([addr])\n"
"  self.code = @list.from_array([Unwind])\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:173
msgid ""
"This simple definition requires modifying the `Unwind` instruction to "
"restore the context when `Unwind` in the `NNum` branch finds that there is a"
" recoverable context (`dump` is not empty)."
msgstr ""
"这个简单的定义要求我们修改 `Unwind` 指令，使其在遇到 `NNum` 分支时，如果发现存在可恢复的上下文（即 `dump` "
"不为空），则恢复该上下文。"

#: ../../example/gmachine/gmachine-2.md:175
msgid ""
"fn GState::unwind(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(_) =>\n"
"      match self.dump {\n"
"        Empty => self.put_stack(addr)\n"
"        More((instrs, stack), tail=rest_dump) => {\n"
"          self.stack = stack\n"
"          self.put_stack(addr)\n"
"          self.dump = rest_dump\n"
"          self.code = instrs\n"
"        }\n"
"      }\n"
"    NApp(a1, _) => {\n"
"      self.put_stack(addr)\n"
"      self.put_stack(a1)\n"
"      self.put_code(@list.from_array([Unwind]))\n"
"    }\n"
"    NGlobal(_, n, c) =>\n"
"      if self.stack.length() < n {\n"
"        abort(\"Unwinding with too few arguments\")\n"
"      } else {\n"
"        if n != 0 {\n"
"          self.rearrange(n)\n"
"        } else {\n"
"          self.put_stack(addr)\n"
"        }\n"
"        self.put_code(c)\n"
"      }\n"
"    NInd(a) => {\n"
"      self.put_stack(a)\n"
"      self.put_code(@list.from_array([Unwind]))\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:181
msgid ""
"Next, we need to implement arithmetic and comparison instructions. We use "
"two functions to simplify the form of binary operations. The result of the "
"comparison instruction is a boolean value, and for simplicity, we use "
"numbers to represent it: 0 for `false`, 1 for `true`."
msgstr ""
"接下来，我们需要实现算术和比较算法。我们使用两个函数来简化二进制运算的形式。比较指令的结果是一个布尔值，简单起见我们使用数字来表示它：0 表示 "
"`false`，1 表示 `true`。"

#: ../../example/gmachine/gmachine-2.md:183
msgid ""
"fn GState::negate(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(n) => {\n"
"      let addr = self.heap.alloc(NNum(-n))\n"
"      self.put_stack(addr)\n"
"    }\n"
"    otherwise =>\n"
"      abort(\"negate: wrong kind of node \\{otherwise}, address \\{addr}\")\n"
"  }\n"
"}\n"
"\n"
"fn GState::lift_arith2(self : GState, op : (Int, Int) -> Int) -> Unit {\n"
"  let (a1, a2) = self.pop2()\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let newnode = Node::NNum(op(n1, n2))\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.put_stack(addr)\n"
"    }\n"
"    (node1, node2) => abort(\"liftArith2: \\{a1} = \\{node1} \\{a2} = "
"\\{node2}\")\n"
"  }\n"
"}\n"
"\n"
"fn GState::lift_cmp2(self : GState, op : (Int, Int) -> Bool) -> Unit {\n"
"  let (a1, a2) = self.pop2()\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let flag = op(n1, n2)\n"
"      let newnode = if flag { Node::NNum(1) } else { Node::NNum(0) }\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.put_stack(addr)\n"
"    }\n"
"    (node1, node2) => abort(\"liftCmp2: \\{a1} = \\{node1} \\{a2} = "
"\\{node2}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:189
msgid "Finally, implement branching:"
msgstr "最后，实现分支："

#: ../../example/gmachine/gmachine-2.md:191
msgid ""
"fn GState::condition(\n"
"  self : GState,\n"
"  i1 : List[Instruction],\n"
"  i2 : List[Instruction]\n"
") -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(0) =>\n"
"      // false\n"
"      self.code = i2 + self.code\n"
"    NNum(1) =>\n"
"      // true\n"
"      self.code = i1 + self.code\n"
"    otherwise => abort(\"cond : \\{addr} = \\{otherwise}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:197
msgid ""
"No major adjustments are needed in the compilation part, just add some "
"predefined programs:"
msgstr "编译部分不需要进行重大调整，只需添加一些预定义程序："

#: ../../example/gmachine/gmachine-2.md:199
msgid ""
"let compiled_primitives : List[(String, Int, List[Instruction])] = "
"@list.from_array([\n"
"    // Arith\n"
"    (\n"
"      \"add\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Add,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"sub\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Sub,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"mul\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Mul,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"div\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Div,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    // Compare\n"
"    (\n"
"      \"eq\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Eq,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"neq\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Ne,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"ge\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Ge,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"gt\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Gt,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"le\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Le,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    (\n"
"      \"lt\",\n"
"      2,\n"
"      @list.from_array([\n"
"        Push(1),\n"
"        Eval,\n"
"        Push(1),\n"
"        Eval,\n"
"        Lt,\n"
"        Update(2),\n"
"        Pop(2),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"    // MISC\n"
"    (\n"
"      \"negate\",\n"
"      1,\n"
"      @list.from_array([Push(0), Eval, Neg, Update(1), Pop(1), Unwind]),\n"
"    ),\n"
"    (\n"
"      \"if\",\n"
"      3,\n"
"      @list.from_array([\n"
"        Push(0),\n"
"        Eval,\n"
"        Cond(@list.from_array([Push(1)]), @list.from_array([Push(2)])),\n"
"        Update(3),\n"
"        Pop(3),\n"
"        Unwind,\n"
"      ]),\n"
"    ),\n"
"  ],\n"
")\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:205
msgid "and modify the initial instruction sequence"
msgstr "并修改初始指令序列"

#: ../../example/gmachine/gmachine-2.md:207
msgid ""
"let initialState : GState = {\n"
"  heap,\n"
"  stack: @list.empty(),\n"
"  code: @list.from_array([PushGlobal(\"main\"), Eval]),\n"
"  globals,\n"
"  stats: 0,\n"
"  dump: @list.empty(),\n"
"}\n"
msgstr ""

#: ../../example/gmachine/gmachine-2.md:214
msgid "Conclusion"
msgstr "总结"

#: ../../example/gmachine/gmachine-2.md:216
msgid ""
"In the next part, we will improve the code generation for primitives and add"
" support for data structures."
msgstr "在下一章，我们将改进原语的代码生成，并添加对数据结构的支持。"

