# MoonBit

MoonBit æ˜¯ä¸€ä¸ªç”¨äºäº‘è®¡ç®—å’Œè¾¹ç¼˜è®¡ç®—çš„ WebAssembly ç«¯åˆ°ç«¯çš„ç¼–ç¨‹è¯­è¨€å·¥å…·é“¾ã€‚
æ‚¨å¯ä»¥è®¿é—® [https://try.moonbitlang.cn](https://try.moonbitlang.cn) è·å¾— IDE ç¯å¢ƒï¼Œæ— éœ€å®‰è£…ä»»ä½•è½¯ä»¶ï¼Œä¹Ÿä¸ä¾èµ–ä»»ä½•æœåŠ¡å™¨ã€‚

## çŠ¶æ€

MoonBit ç›®å‰å¤„äº Pre-alpha é˜¶æ®µï¼Œæ˜¯å®éªŒæ€§è´¨çš„ã€‚æˆ‘ä»¬æœŸæœ›ä»Šå¹´èƒ½è¾¾åˆ° beta é˜¶æ®µã€‚

## ä¸»è¦ä¼˜åŠ¿

- ç”Ÿæˆæ¯”ç°æœ‰è§£å†³æ–¹æ¡ˆæ˜æ˜¾æ›´å°çš„ WASM æ–‡ä»¶ã€‚
- æ›´é«˜çš„è¿è¡Œæ—¶æ€§èƒ½ã€‚
- å…ˆè¿›çš„ç¼–è¯‘æ—¶æ€§èƒ½ã€‚
- ç®€å•ä¸”å®ç”¨çš„æ•°æ®å¯¼å‘è¯­è¨€è®¾è®¡ã€‚

## æ¦‚è¿°

ä¸€ä¸ªæœˆå…”ç¨‹åºç”±ç±»å‹å®šä¹‰ï¼Œå‡½æ•°å®šä¹‰å’Œå˜é‡ç»‘å®šç»„æˆã€‚

### ç¨‹åºå…¥å£

æœ‰ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼š `init` å‡½æ•°ï¼Œå®ƒæœ‰ä»¥ä¸‹ä¸¤ä¸ªç‰¹ç‚¹ï¼š

1. åŒä¸€ä¸ªåŒ…ä¸­å¯ä»¥æœ‰å¤šä¸ª `init` å‡½æ•°ã€‚
2. `init` å‡½æ•°ä¸èƒ½è¢«æ˜¾å¼è°ƒç”¨æˆ–è¢«å…¶ä»–å‡½æ•°å¼•ç”¨ã€‚ç›¸åï¼Œåœ¨ä¸€ä¸ªåŒ…åˆå§‹åŒ–æ—¶ï¼Œæ‰€æœ‰çš„ `init` å‡½æ•°éƒ½å°†è¢«éšå¼åœ°è°ƒç”¨ã€‚å› æ­¤ï¼Œ`init` å‡½æ•°ä¸­åªèƒ½åŒ…å«è¯­å¥ã€‚

```moonbit live
fn init {
  println("Hello world!") // OK
}

fn init {
  let x = 1
  // x     // å¤±è´¥
  println(x) // æˆåŠŸ
}
```

å¯¹äº WebAssembly åç«¯è€Œè¨€ï¼Œè¿™æ„å‘³ç€å®ƒå°†ä¼šåœ¨å®ä¾‹å‡†å¤‡å¥½**ä¹‹å‰**è¢«æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæœ‰ FFI ä¾èµ–å®ä¾‹çš„å¯¼å‡ºï¼Œé‚£ä¹ˆå°†ä¸èƒ½æ­£å¸¸è¿è¡Œï¼›å¯¹äº JavaScript åç«¯è€Œè¨€ï¼Œè¿™æ„å‘³ç€å®ƒå°†ä¼šåœ¨è¢«å¯¼å…¥çš„æ—¶å€™æ‰§è¡Œã€‚

å¦ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°æ˜¯`main`å‡½æ•°ã€‚`main`å‡½æ•°æ˜¯ç¨‹åºçš„å…¥å£ï¼Œå®ƒå°†ä¼šåœ¨åˆå§‹åŒ–é˜¶æ®µä¹‹åè¢«æ‰§è¡Œã€‚åªæœ‰æ˜¯`main`çš„åŒ…ä¸­æ‰èƒ½å®šä¹‰`main`å‡½æ•°ã€‚æŸ¥çœ‹[æ„å»ºç³»ç»Ÿæ•™ç¨‹](./build-system-tutorial.md)äº†è§£æ›´å¤šã€‚

ä¸Šè¿°ä¸¤ä¸ªå‡½æ•°å‡éœ€çœç•¥å‚æ•°åˆ—è¡¨ä¸è¿”å›å€¼å®šä¹‰ã€‚

### è¡¨è¾¾å¼å’Œè¯­å¥

MoonBit åŒºåˆ†è¯­å¥å’Œè¡¨è¾¾å¼ã€‚åœ¨ä¸€ä¸ªå‡½æ•°ä½“ä¸­ï¼Œåªæœ‰æœ€åä¸€å¥æ‰èƒ½å†™æˆä½œä¸ºè¿”å›å€¼çš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn foo() -> Int {
  let x = 1
  x + 1 // OK
}

fn bar() -> Int {
  let x = 1
  x + 1 // å¤±è´¥
  x + 2
}

fn init {
  println(foo())
  println(bar())
}
```

è¡¨è¾¾å¼åŒ…æ‹¬ï¼š

- å€¼å­—é¢é‡ï¼ˆä¾‹å¦‚å¸ƒå°”å€¼ã€æ•°å­—ã€å­—ç¬¦ã€å­—ç¬¦ä¸²ã€æ•°ç»„ã€å…ƒç»„ã€ç»“æ„ä½“ï¼‰
- ç®—æœ¯ã€é€»è¾‘å’Œæ¯”è¾ƒè¿ç®—
- è®¿é—®æ•°ç»„å…ƒç´ ï¼ˆä¾‹å¦‚ `a[0]`ï¼‰ã€ç»“æ„ä½“å­—æ®µï¼ˆä¾‹å¦‚ `r.x`ï¼‰æˆ–å…ƒç»„çš„å…ƒç´ ï¼ˆä¾‹å¦‚ `t.0`ï¼‰
- å˜é‡å’Œï¼ˆå¤§å†™å­—æ¯å¼€å¤´çš„ï¼‰æšä¸¾æ„é€ å™¨
- åŒ¿åå±€éƒ¨å‡½æ•°å®šä¹‰
- `match` å’Œ `if` è¡¨è¾¾å¼

è¯­å¥åŒ…æ‹¬ï¼š

- å‘½åå±€éƒ¨å‡½æ•°å®šä¹‰
- å±€éƒ¨å˜é‡ç»‘å®š
- èµ‹å€¼
- `return` è¯­å¥
- è¿”å›ç±»å‹ä¸º `unit` çš„ä»»ä½•è¡¨è¾¾å¼

## å‡½æ•°

å‡½æ•°æ¥å—å‚æ•°å¹¶äº§ç”Ÿç»“æœã€‚
åœ¨ MoonBit ä¸­ï¼Œå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€å‡½æ•°å¯ä»¥ä½œä¸ºå…¶ä»–å‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚ä¸ä¸‹è¿°çš„ `enum` çš„ç±»å‹æ„é€ å­ç›¸å¯¹ï¼ŒMoonBit çš„å‘½åè§„åˆ™è¦æ±‚å‡½æ•°åä¸èƒ½ä»¥å¤§å†™å­—æ¯ (A-Z) å¼€å¤´ã€‚

### é¡¶å±‚å‡½æ•°

å‡½æ•°å¯ä»¥è¢«å®šä¹‰ä¸ºé¡¶å±‚æˆ–å±€éƒ¨ã€‚
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `fn` å…³é”®å­—å®šä¹‰ä¸€ä¸ªé¡¶å±‚å‡½æ•°ï¼Œ
ä¾‹å¦‚ä»¥ä¸‹å‡½æ•°æ±‚ä¸‰ä¸ªæ•´æ•°ä¹‹å’Œå¹¶è¿”å›ç»“æœï¼š

```moonbit
fn add3(x: Int, y: Int, z: Int)-> Int {
  x + y + z
}
```

æ³¨æ„ï¼Œé¡¶å±‚å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹éœ€è¦æ˜¾å¼æ ‡æ³¨ã€‚

### å±€éƒ¨å‡½æ•°

å±€éƒ¨å‡½æ•°ä½¿ç”¨ `fn` å…³é”®å­—å®šä¹‰ã€‚å±€éƒ¨å‡½æ•°å¯ä»¥æ˜¯å‘½åçš„æˆ–åŒ¿åçš„ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå±€éƒ¨å‡½æ•°çš„ç±»å‹æ³¨è§£å¯ä»¥çœç•¥ï¼Œå› ä¸ºç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn foo() -> Int {
  fn inc(x) { x + 1 }       // å‘½åä¸º `inc`
  fn (x) { x + inc(2) } (6) // åŒ¿åï¼Œç«‹å³åº”ç”¨åˆ°æ•´æ•°å­—é¢é‡ 6
}

fn init {
  println(foo())
}
```

æ— è®ºæ˜¯å‘½åçš„è¿˜æ˜¯åŒ¿åçš„ï¼Œå‡½æ•°éƒ½æ˜¯ _è¯æ³•é—­åŒ…_ï¼šä»»ä½•æ²¡æœ‰å±€éƒ¨ç»‘å®šçš„æ ‡è¯†ç¬¦ï¼Œ
å¿…é¡»å¼•ç”¨æ¥è‡ªå‘¨å›´è¯æ³•ä½œç”¨åŸŸçš„ç»‘å®šï¼š

```moonbit live
let y = 3
fn foo(x: Int) -> Unit {
  fn inc()  { x + 1 } // OKï¼Œè¿”å› x + 1
  fn four() { y + 1 } // Okï¼Œè¿”å› 4
  println(inc())
  println(four())
}

fn init {
  foo(2)
}
```

### å‡½æ•°è°ƒç”¨

å‡½æ•°å¯é€šè¿‡å‘åœ†æ‹¬å·å†…ä¼ å…¥å‚æ•°åˆ—è¡¨è¿›è¡Œè°ƒç”¨ï¼š

```moonbit
add3(1, 2, 7)
```

è¿™é€‚ç”¨äºå‘½åå‡½æ•°ï¼ˆå¦‚å‰é¢çš„ä¾‹å­ï¼‰å’Œç»‘å®šåˆ°å‡½æ•°å€¼çš„å˜é‡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```moonbit live
fn init {
  let add3 = fn(x, y, z) { x + y + z }
  println(add3(1, 2, 7))
}
```

è¡¨è¾¾å¼ `add3(1, 2, 7)` è¿”å› `10`ã€‚ä»»ä½•æ±‚å€¼ä¸ºå‡½æ•°å€¼çš„è¡¨è¾¾å¼éƒ½å¯ä»¥è¢«è°ƒç”¨ï¼š

```moonbit live
fn init {
  let f = fn (x) { x + 1 }
  let g = fn (x) { x + 2 }
  println((if true { f } else { g })(3)) // OK
}
```

### å¸¦æ ‡ç­¾çš„å‚æ•°

å¯ä»¥ç”¨ `~label : Type` çš„è¯­æ³•ä¸ºå‡½æ•°å£°æ˜å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚å‡½æ•°ä½“å†…å‚æ•°çš„åå­—ä¹Ÿæ˜¯ `label`ï¼š

```moonbit
fn labelled(~arg1 : Int, ~arg2 : Int) -> Int {
  arg1 + arg2
}
```

è°ƒç”¨å‡½æ•°æ—¶ï¼Œå¯ä»¥ç”¨ `label=arg` çš„è¯­æ³•æä¾›å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚`label=label` å¯ä»¥ç®€å†™æˆ `~label`ï¼š

```moonbit
fn init {
  let arg1 = 1
  println(labelled(arg2=2, ~arg1)) // 3
}
```

å¯ä»¥ç”¨ä»»æ„çš„é¡ºåºæä¾›å¸¦æ ‡ç­¾çš„å‚æ•°ã€‚å‚æ•°çš„æ±‚å€¼é¡ºåºä¸å‡½æ•°å£°æ˜ä¸­å‚æ•°çš„é¡ºåºç›¸åŒã€‚

### å¯é€‰çš„å‚æ•°

å¯é€‰çš„å‚æ•°æ˜¯å¸¦æœ‰é»˜è®¤å€¼çš„å¸¦æ ‡ç­¾å‚æ•°ã€‚å£°æ˜å¯é€‰çš„å‚æ•°çš„è¯­æ³•æ˜¯ `~label : Type = default_expr`ã€‚è°ƒç”¨å‡½æ•°æ—¶ï¼Œå¦‚æœæ²¡æœ‰æä¾›è¿™ä¸ªå‚æ•°ï¼Œå°±ä¼šä½¿ç”¨é»˜è®¤å€¼ä½œä¸ºå‚æ•°ï¼š

```moonbit live
fn optional(~opt : Int = 42) -> Int {
  opt
}

fn init {
  println(optional()) // 42
  println(optional(opt=0)) // 0
}
```

æ¯æ¬¡ä½¿ç”¨é»˜è®¤å‚æ•°è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œéƒ½ä¼šé‡æ–°æ±‚å€¼é»˜è®¤å€¼çš„è¡¨è¾¾å¼ï¼Œä¹Ÿä¼šè¢«é‡æ–°è§¦å‘å…¶ä¸­çš„å‰¯ä½œç”¨ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn incr(~counter : Ref[Int] = { val: 0 }) -> Ref[Int] {
  counter.val = counter.val + 1
  counter
}

fn init {
  println(incr()) // 1
  println(incr()) // ä¾ç„¶æ˜¯ 1ï¼Œå› ä¸ºé‡æ–°æ±‚å€¼äº†é»˜è®¤è¡¨è¾¾å¼ï¼Œäº§ç”Ÿäº†ä¸€ä¸ªæ–°çš„ Ref
  let counter : Ref[Int] = { val: 0 }
  println(incr(~counter)) // 1
  println(incr(~counter)) // 2ï¼Œå› ä¸ºä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨äº†åŒä¸€ä¸ª Ref
}
```

å¦‚æœæƒ³è¦åœ¨å¤šæ¬¡ä¸åŒçš„å‡½æ•°è°ƒç”¨ä¹‹é—´å…±äº«é»˜è®¤å€¼ï¼Œå¯ä»¥æå‰ç”¨ `let` è®¡ç®—å¹¶ä¿å­˜é»˜è®¤å€¼ï¼š

```moonbit live
let default_counter : Ref[Int] = { val: 0 }

fn incr(~counter : Ref[Int] = default_counter) -> Int {
  counter.val = counter.val + 1
  counter.val
}

fn init {
  println(incr()) // 1
  println(incr()) // 2
}
```

é»˜è®¤å€¼å¯ä»¥ä¾èµ–äºå‰é¢çš„å‚æ•°ï¼Œä¾‹å¦‚ï¼š

```moonbit
fn sub_array[X](xs : Array[X], ~offset : Int, ~len : Int = xs.length() - offset) -> Array[X] {
  ... // ç”Ÿæˆ xs çš„ä¸€ä¸ªä» offset å¼€å§‹ã€é•¿åº¦ä¸º len çš„å­æ•°ç»„
}

fn init {
  println(sub_array([1, 2, 3], offset=1)) // [2, 3]
  println(sub_array([1, 2, 3], offset=1, len=1)) // [2]
}
```

### è‡ªåŠ¨å¡«å……çš„å‚æ•°

MoonBit èƒ½å¤Ÿè‡ªåŠ¨åœ¨æ¯æ¬¡å‡½æ•°è°ƒç”¨æ—¶å¡«å……æŸäº›ç‰¹å®šç±»å‹çš„å‚æ•°ï¼Œä¾‹å¦‚å‡½æ•°è°ƒç”¨åœ¨æºç ä¸­çš„ä½ç½®ã€‚è¦å£°æ˜è¿™ç§è‡ªåŠ¨å¡«å……çš„å‚æ•°ï¼Œåªéœ€è¦ä½¿ç”¨ `_` ä½œä¸ºå‚æ•°çš„é»˜è®¤å€¼å³å¯ã€‚å¦‚æœåœ¨è°ƒç”¨æ—¶æ²¡æœ‰æä¾›è¿™ä¸ªå‚æ•°ï¼ŒMoonBit å°±ä¼šè‡ªåŠ¨æ ¹æ®è°ƒç”¨å¤„çš„ä¸Šä¸‹æ–‡å¡«å……è¿™ä¸ªå‚æ•°ã€‚

ç›®å‰ MoonBit æ”¯æŒä¸¤ç§ç±»å‹çš„è‡ªåŠ¨å¡«å……å‚æ•°ã€‚ä»£è¡¨æ•´ä¸ªå‡½æ•°è°ƒç”¨åœ¨æºç ä¸­ä½ç½®çš„ `SourceLoc` ç±»å‹ï¼Œä»¥åŠåŒ…å«æ¯ä¸ªå‚æ•°å„è‡ªçš„ä½ç½®çš„ `ArgsLoc` ç±»å‹ï¼š

```moonbit
fn f(_x : Int, _y : Int, ~loc : SourceLoc = _, ~args_loc : ArgsLoc = _) -> Unit {
  println("æ•´ä¸ªå‡½æ•°è°ƒç”¨çš„ä½ç½®ï¼š\{loc}")
  println("å„ä¸ªå‚æ•°çš„ä½ç½®ï¼š\{args_loc}")
}

fn init {
  f(1, 2)
  // æ•´ä¸ªå‡½æ•°è°ƒç”¨çš„ä½ç½®ï¼š<æ–‡ä»¶å>:7:3-7:10
  // å„ä¸ªå‚æ•°çš„ä½ç½®ï¼š[Some(<æ–‡ä»¶å>:7:5-7:6), Some(<æ–‡ä»¶å>:7:8-7:9), None, None]
}
```

è‡ªåŠ¨å¡«å……çš„å‚æ•°å¯ä»¥ç”¨äºç¼–å†™è°ƒè¯•å’Œæµ‹è¯•ç”¨çš„å·¥å…·å‡½æ•°ã€‚

## æ§åˆ¶ç»“æ„

### æ¡ä»¶è¡¨è¾¾å¼

æ¡ä»¶è¡¨è¾¾å¼ç”±æ¡ä»¶ã€ç»“æœå’Œä¸€ä¸ªå¯é€‰çš„ `else` å­å¥ç»„æˆã€‚

```moonbit
if x == y {
  expr1
} else {
  expr2
}

if x == y {
  expr1
}
```

`else` å­å¥ä¹Ÿå¯ä»¥åŒ…å«å¦ä¸€ä¸ª `if-else` è¡¨è¾¾å¼ï¼š

```moonbit
if x == y {
  expr1
} else if z == k {
  expr2
}
```

èŠ±æ‹¬å·ç”¨äºåœ¨ç»“æœæˆ– `else` å­å¥ä¸­ç»„åˆè¡¨è¾¾å¼ã€‚

æ³¨æ„ï¼Œåœ¨ MoonBit ä¸­ï¼Œæ¡ä»¶è¡¨è¾¾å¼æ€»æ˜¯è¿”å›ä¸€ä¸ªå€¼ï¼Œå…¶ç»“æœå’Œ `else` å­å¥çš„è¿”å›å€¼ç±»å‹å¿…é¡»ç›¸åŒã€‚

### While å¾ªç¯

MoonBit ä¸­æ”¯æŒ`while`å¾ªç¯ã€‚`while`åçš„å¾ªç¯æ¡ä»¶ä¼šåœ¨å¾ªç¯ä½“ä¹‹å‰æ‰§è¡Œï¼Œå½“å¾ªç¯æ¡ä»¶ä¸ºçœŸæ—¶, æ‰§è¡Œå¾ªç¯ä½“ï¼š

```moonbit
let mut i = 5
while i > 0 {
  println(i)
  i = i - 1
}
```

å¾ªç¯ä½“å†…æ”¯æŒ`break`å’Œ`continue`ã€‚ä½¿ç”¨`break`èƒ½å¤Ÿè·³å‡ºå½“å‰å¾ªç¯ï¼›ä½¿ç”¨`continue`è·³è¿‡æœ¬æ¬¡å¾ªç¯çš„å‰©ä½™éƒ¨åˆ†ï¼Œæå‰è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚

```moonbit
let mut i = 5
while i > 0 {
  i = i - 1
  if i == 4 { continue }
  if i == 1 { break }
  println(i)
}
```

è¾“å‡º:

```plaintext
3
2
```

`while` å¾ªç¯ä¹Ÿæ”¯æŒå¯é€‰çš„`else`å­å¥ã€‚å½“å¾ªç¯æ¡ä»¶è½¬å˜ä¸ºå‡æ—¶ï¼Œå°†ä¼šæ‰§è¡Œ`else`å­å¥ï¼Œç„¶åå¾ªç¯ç»“æŸã€‚

```moonbit
let mut i = 2
while i > 0 {
  println(i)
  i = i - 1
} else {
  println(i)
}
```

è¾“å‡º:

```plaintext
2
1
0
```

å½“å­˜åœ¨ `else` å­å¥æ—¶ï¼Œ`while` å¾ªç¯ä¹Ÿå¯ä»¥è¿”å›ä¸€ä¸ªå€¼ï¼Œè¿”å›å€¼æ˜¯ `else` å­å¥è¯­å¥å—çš„æ±‚å€¼ç»“æœã€‚æ­¤æ—¶å¦‚æœä½¿ç”¨`break`è·³å‡ºå¾ªç¯ï¼Œéœ€è¦åœ¨`break`åæä¾›ä¸€ä¸ªè¿”å›å€¼ï¼Œç±»å‹ä¸`else`å­å¥çš„è¿”å›å€¼ç±»å‹ä¸€è‡´ï¼š

```moonbit
  let mut i = 10
  let r1 =
    while i > 0 {
      i = i - 1
      if i % 2 == 0 { break 5 } // è·³å‡ºå¾ªç¯å¹¶è¿”å› 5
    } else {
      7
    }
  println(r1) //output: 5
```

```moonbit
  let mut i = 10
  let r2 =
    while i > 0 {
      i = i - 1
    } else {
      7
    }
  println(r2) //output: 7
```

## For å¾ªç¯

MoonBit ä¹Ÿæ”¯æŒ C é£æ ¼çš„ For å¾ªç¯ã€‚å…³é”®å­—`for`åä¾æ¬¡è·Ÿéšä»¥åˆ†å·é—´éš”çš„å˜é‡åˆå§‹åŒ–å­å¥ã€å¾ªç¯æ¡ä»¶å’Œæ›´æ–°å­å¥ã€‚ä¸‰è€…ä¸éœ€è¦ä½¿ç”¨åœ†æ‹¬å·åŒ…è£¹ã€‚
ä¾‹å¦‚ä¸‹é¢çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å˜é‡ç»‘å®š`i`, å®ƒçš„ä½œç”¨åŸŸåœ¨æ•´ä¸ªå¾ªç¯ä¸­ï¼Œä¸”æ˜¯ä¸å¯å˜çš„ã€‚è¿™æ›´åˆ©äºç¼–å†™æ¸…æ™°çš„ä»£ç å’Œæ¨ç†ï¼š

```moonbit
for i = 0; i < 5; i = i + 1 {
  println(i)
}
// output:
// 0
// 1
// 2
```

å˜é‡åˆå§‹åŒ–å­å¥ä¸­å¯ä»¥åˆ›å»ºå¤šä¸ªç»‘å®šï¼š

```moonbit
for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {
  println(i)
}
```

éœ€è¦æ³¨æ„çš„æ˜¯åœ¨æ›´æ–°å­å¥ä¸­ï¼Œå¯¹äºå¤šä¸ªç»‘å®šå˜é‡å…·æœ‰åŒæ—¶æ›´æ–°çš„è¯­ä¹‰ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæ›´æ–°å­å¥å¹¶ä¸æ˜¯é¡ºåºæ‰§è¡Œ`i = i + 1`ã€`j = j + 1`ï¼Œè€Œæ˜¯åŒæ—¶ä»¤`i`ã€`j`è‡ªå¢ã€‚å› æ­¤ï¼Œåœ¨æ›´æ–°å­å¥ä¸­è¯»å–ç»‘å®šå˜é‡å¾—åˆ°çš„å€¼æ°¸è¿œæ˜¯ä¸Šä¸€æ¬¡å¾ªç¯æ›´æ–°åçš„å€¼ã€‚

å˜é‡åˆå§‹åŒ–å­å¥ã€å¾ªç¯æ¡ä»¶å’Œæ›´æ–°å­å¥éƒ½æ˜¯å¯é€‰çš„ã€‚ä¾‹å¦‚ä¸‹é¢ä¸¤ä¸ªæ— é™å¾ªç¯ï¼š

```moonbit
for i=1;; i=i+1 {
  println(i) // loop forever!
}
```

```moonbit
for {
  println("loop forever!")
}
```

`for` å¾ªç¯åŒæ ·æ”¯æŒ`continue`ã€`break`å’Œ`else`å­å¥ã€‚å’Œ`while`å¾ªç¯ä¸€æ ·ï¼Œ`for` å¾ªç¯åŒæ ·
æ”¯æŒä½¿ç”¨`break`å’Œ`else`å­å¥ä½¿`for`è¯­å¥è¿”å›ä¸€ä¸ªå€¼ã€‚

ä½¿ç”¨`continue`è¯­å¥å°†è·³è¿‡`for`æœ¬æ¬¡å¾ªç¯çš„å‰©ä½™éƒ¨åˆ†ï¼ˆåŒ…æ‹¬æ›´æ–°å­å¥ï¼‰æå‰è¿›å…¥ä¸‹æ¬¡å¾ªç¯ã€‚`continue`è¯­å¥
ä¹Ÿæ”¯æŒåŒæ—¶æ›´æ–°`for`å¾ªç¯çš„ç»‘å®šå˜é‡ï¼Œåªè¦åœ¨`continue`åé¢è·Ÿéšå’Œç»‘å®šå˜é‡æ•°é‡ä¸€è‡´çš„è¡¨è¾¾å¼ï¼Œå¤šä¸ªè¡¨è¾¾å¼ä½¿ç”¨é€—å·åˆ†éš”ã€‚

ä¾‹å¦‚ï¼Œä¸‹é¢çš„ç¨‹åºè®¡ç®—æ•°å­— 1 åˆ° 6 ä¸­çš„å¶æ•°çš„å’Œï¼š

```moonbit live
fn main {
  let sum =
    for i = 1, acc = 0; i <= 6; i = i + 1 {
      if i % 2 == 0 {
        println("even: \{i}")
        continue i + 1, acc + i
      }
    } else {
      acc
    }
  println(sum)
}
```

è¾“å‡ºï¼š

```plaintext
even: 2
even: 4
even: 6
12
```

### `for .. in` å¾ªç¯
MoonBit ä½¿ç”¨ `for .. in` å¾ªç¯è¯­æ³•æ¥éå†å„ç§æ•°æ®ç»“æ„å’Œåºåˆ—ï¼š

```moonbit
for x in [ 1, 2, 3 ] {
  println(x)
}
```

`for .. in` å¾ªç¯ä¼šè¢«ç¿»è¯‘æˆ MoonBit æ ‡å‡†åº“ä¸­çš„è¿­ä»£å™¨ç±»å‹ `Iter`ã€‚åªè¦ä¸€ä¸ªç±»å‹æœ‰æ–¹æ³• `.iter() : Iter[T]`ï¼Œå°±å¯ä»¥ä½¿ç”¨ `for .. in` å¾ªç¯æ¥éå†å…¶ä¸­çš„å…ƒç´ ã€‚å¦‚æœæƒ³äº†è§£è¿­ä»£å™¨çš„æ›´å¤šä¿¡æ¯ï¼Œå¯ä»¥é˜…è¯»æœ¬æ–‡æ¡£çš„ [è¿­ä»£å™¨](#è¿­ä»£å™¨) ä¸€èŠ‚ã€‚

é™¤äº†å•ä¸ªå…ƒç´ çš„åºåˆ—ï¼ŒMoonBit è¿˜èƒ½ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„ `Iter2` ç±»å‹æ¥éå†æœ‰ä¸¤ä¸ªå…ƒç´ çš„åºåˆ—ï¼Œä¾‹å¦‚å­—å…¸ `Map`ã€‚
å¦‚æœä¸€ä¸ªç±»å‹æœ‰æ–¹æ³• `.iter2() : Iter2[A, B]`ï¼Œå°±å¯ä»¥ä½¿ç”¨æœ‰ä¸¤ä¸ªå¾ªç¯å˜é‡çš„ `for .. in` å¾ªç¯æ¥éå†å®ƒï¼š

```moonbit
for k, v in { "x": 1, "y": 2, "z": 3 } {
  println("\{k} => \{v}")
}
```

ä¸‹é¢æ˜¯å¦ä¸€ä¸ªæœ‰ä¸¤ä¸ªå¾ªç¯å˜é‡çš„ `for .. in` çš„ä¾‹å­ï¼Œåœ¨éå†ä¸€ä¸ªæ•°ç»„çš„åŒæ—¶è¿½è¸ªè¿™æ˜¯æ•°ç»„ä¸­çš„ç¬¬å‡ ä¸ªå…ƒç´ ï¼š
```moonbit
for index, elem in [ 4, 5, 6 ] {
  let i = index + 1
  println("æ•°ç»„çš„ç¬¬ \{i} ä¸ªå…ƒç´ æ˜¯ \{elem}")
}
```

`for .. in` çš„å¾ªç¯ä½“ä¸­å¯ä»¥ä½¿ç”¨ `return`ï¼Œ`break` å’Œé”™è¯¯å¤„ç†ç­‰æ§åˆ¶æµæ“ä½œï¼š

```moonbit live
test "map test" {
  let map = { "x": 1, "y": 2, "z": 3 }
  for k, v in map {
    assert_eq!(map[k], Some(v))
  }
}
```

æœ€åï¼Œå¦‚æœå¾ªç¯å˜é‡æ²¡æœ‰è¢«ä½¿ç”¨åˆ°ï¼Œå¯ä»¥ç”¨ `_` æ¥å¿½ç•¥å®ƒã€‚

### å‡½æ•°å¼å¾ªç¯

å‡½æ•°å¼å¾ªç¯æ˜¯ MoonBit ä¸­ä¸€ä¸ªå¼ºå¤§çš„ç‰¹æ€§ï¼Œå®ƒèƒ½è®©æ‚¨ä»¥å‡½æ•°å¼é£æ ¼ç¼–å†™å¾ªç¯ã€‚

å‡½æ•°å¼å¾ªç¯æ¥å—å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚å®ƒä½¿ç”¨ `loop` å…³é”®å­—å®šä¹‰ï¼Œåè·Ÿå…¶å‚æ•°å’Œå¾ªç¯ä½“ã€‚
å¾ªç¯ä½“æ˜¯ä¸€ç³»åˆ—å­å¥ï¼Œæ¯ä¸ªå­å¥ç”±æ¨¡å¼å’Œè¡¨è¾¾å¼ç»„æˆã€‚
ä¸è¾“å…¥åŒ¹é…çš„æ¨¡å¼ä¼šè¢«æ‰§è¡Œï¼Œå¹¶ä¸”å¾ªç¯å°†è¿”å›è¡¨è¾¾å¼çš„å€¼ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…çš„æ¨¡å¼ï¼Œå¾ªç¯å°†æŠ›å‡ºå¼‚å¸¸ã€‚
å¯ä»¥ä½¿ç”¨ `continue` å…³é”®å­—å’Œå‚æ•°å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯è¿­ä»£ï¼Œä½¿ç”¨ `break` å…³é”®å­—å’Œå‚æ•°æ¥ä»å¾ªç¯ä¸­è¿”å›ä¸€ä¸ªå€¼ã€‚
å¦‚æœå€¼æ˜¯å¾ªç¯ä½“ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåˆ™å¯ä»¥çœç•¥ `break` å…³é”®å­—ã€‚

```moonbit live
fn sum(xs: List[Int]) -> Int {
  loop xs, 0 {
    Nil, acc => break acc // break å¯ä»¥çœç•¥
    Cons(x, rest), acc => continue rest, x + acc
  }
}

fn init {
  println(sum(Cons(1, Cons(2, Cons(3, Nil)))))
}
```

## è¿­ä»£å™¨

è¿­ä»£å™¨ï¼ˆIteratorï¼‰æ˜¯ä¸€ä¸ªç”¨æ¥éå†è®¿é—®æŸä¸ªåºåˆ—çš„å…ƒç´ çš„å¯¹è±¡ã€‚ä¼ ç»Ÿé¢å‘å¯¹è±¡è¯­è¨€ï¼ˆä¾‹å¦‚ Javaï¼‰ï¼Œä½¿ç”¨ `Iterator<T>` å’Œ `next()`
`hasNext()` æ¥æ­¥è¿›ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ï¼›è€Œå‡½æ•°å¼è¯­è¨€ï¼ˆä¾‹å¦‚ JavaScript çš„ `forEach`ï¼ŒLisp çš„
`mapcar`ï¼‰åˆ™æ˜¯é€šè¿‡æ¥æ”¶æŸä¸ªæ“ä½œå’Œåºåˆ—ï¼Œå¹¶åœ¨éå†è¿‡ç¨‹ä¸­å°†æ“ä½œåº”ç”¨äºè¯¥åºåˆ—çš„é«˜é˜¶å‡½æ•°æ¥å®ç°è¿­ä»£å™¨ã€‚
å‰è€…å«åšå¤–éƒ¨è¿­ä»£å™¨ï¼ˆå¯¹ç”¨æˆ·å¯è§ï¼‰ï¼›åè€…ç§°ä¸ºå†…éƒ¨è¿­ä»£å™¨ï¼ˆå¯¹ç”¨æˆ·ä¸å¯è§ï¼‰ã€‚

MoonBit çš„å†…ç½®ç±»å‹ `Iter[T]` æä¾›äº†è¿­ä»£å™¨æ”¯æŒã€‚åŸºæœ¬ä¸Šæ‰€æœ‰çš„å†…ç½®åºåˆ—ç»“æ„éƒ½å®ç°äº† Iterï¼š

```moonbit
fn filter_even(l : Array[Int]) -> Array[Int] {
  let l_iter: Iter[Int] = l.iter()
  l_iter.filter(fn { x => if (x & 1) == 1 { true } else { false } }).collect()
}

fn fact(n : Int) -> Int {
  let start = 1
  start.until(n).fold(Int::op_mul, init=start)
}
```

å¸¸ç”¨çš„æ–¹æ³•åŒ…æ‹¬ï¼š

- `each`ï¼šéå†è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶å°†æ¥æ”¶çš„å‡½æ•°åº”ç”¨äºæ¯ä¸ªå…ƒç´ ä¸Š
- `fold`ï¼šç”¨ç»™å®šçš„å‡½æ•°å’Œä¸€ä¸ªåˆå§‹å€¼æŠ˜å ï¼ˆå½’çº¦ï¼‰æŸä¸ªè¿­ä»£å™¨
- `collect`ï¼šå°†è¿­ä»£å™¨ä¸­çš„å…ƒç´ æ”¶é›†åˆ°ä¸€ä¸ª `Array` ä¸­

- `filter`ï¼šï¼ˆæƒ°æ€§ï¼‰ç”¨æŸä¸ªå‡½æ•°ï¼ˆè°“è¯ï¼‰è¿‡æ»¤è¿­ä»£å™¨çš„å…ƒç´ 
- `map`ï¼šï¼ˆæƒ°æ€§ï¼‰ç”¨æŸä¸ªå‡½æ•°è½¬åŒ–è¿­ä»£å™¨ä¸­çš„å…ƒç´ 
- `concat`ï¼šï¼ˆæƒ°æ€§ï¼‰å°†ä¸€ä¸ªè¿­ä»£å™¨ä¸­çš„å…ƒç´ å…¨éƒ¨åŠ åˆ°å¦ä¸€ä¸ªçš„å°¾éƒ¨

ç±»ä¼¼ `filter` `map` è¿™æ ·çš„æ–¹æ³•åœ¨åºåˆ—ç»“æ„ä¸Šå¾ˆå¸¸è§ã€‚ä½†æ˜¯ Iter ç‰¹åˆ«çš„åœ°æ–¹åœ¨äºä»»ä½•æ„é€ ä¸€ä¸ªæ–° Iter çš„æ–¹æ³•éƒ½æ˜¯æƒ°æ€§çš„ï¼ˆå³è°ƒç”¨æ–¹æ³•ä¸ä¼šç«‹å³æ‰§è¡Œè¿­ä»£ï¼Œå› ä¸ºå¥—äº†ä¸€å±‚å‡½æ•°ï¼‰ï¼Œè¿™ç§æ€§è´¨æ˜¯ Iter ä¸äº§ç”Ÿä¸­é—´å€¼çš„ä½“ç°ã€‚è¿™å°±æ˜¯åœ¨éå†åºåˆ—ä¸Š Iter çš„ä¼˜åŠ¿ï¼šæ²¡æœ‰é¢å¤–å¼€é”€ã€‚MoonBit é¼“åŠ±ç”¨æˆ·ä½¿ç”¨ Iter åœ¨å‡½æ•°é—´ä¼ å‚ï¼Œè€Œä¸æ˜¯ä½¿ç”¨åºåˆ—æœ¬èº«ã€‚

ä¾‹å¦‚ `Array` è¿™æ ·é¢„å®šä¹‰çš„åºåˆ—ç»“æ„å’Œå…¶è‡ªå¸¦çš„è¿­ä»£å™¨åº”å½“è¶³å¤Ÿä½¿ç”¨ã€‚ä½†è¦è®©ä¸Šé¢çš„æ–¹æ³•ä¹Ÿé€‚ç”¨äºè‡ªå®šä¹‰çš„åºåˆ—ç»“æ„ï¼Œå°±éœ€è¦æ‰‹åŠ¨å®ç° Iterï¼Œä»¥ `Bytes` ä¸ºä¾‹ï¼š

```moonbit
fn iter(data : Bytes) -> Iter[Byte] {
  Iter::new(
    fn(yield) {
      // The code that actually does the iteration
      /////////////////////////////////////////////
      for i = 0, len = data.length(); i < len; i = i + 1 {
        if yield(data[i]) == IterEnd {
          break IterEnd
        }
      /////////////////////////////////////////////
      } else {
        IterContinue
      }
    },
  )
}
```

åŸºæœ¬ä¸Šæ‰€æœ‰çš„ `Iter` å®ç°éƒ½å’Œä¸Šè¿° `Bytes` çš„ç›¸ä¼¼ï¼Œå”¯ä¸€çš„ä¸åŒç‚¹åœ¨äºå®é™…ç”¨äºè¿­ä»£çš„ä»£ç éƒ¨åˆ†ã€‚

### å®ç°ç»†èŠ‚

`Iter[T]` å®é™…ä¸Šæ˜¯ `((T) -> IterResult)->IterResult`
çš„ç±»å‹åˆ«åï¼Œå³ä¸€ä¸ªæ¥æ”¶æŸä¸ªæ“ä½œçš„é«˜é˜¶å‡½æ•°ã€‚

`IterResult` æ˜¯ä¸€ä¸ªè®°å½•è¿­ä»£è¿‡ç¨‹çŠ¶æ€çš„ `enum` å¯¹è±¡ï¼Œå…¶åŒ…å«ä¸¤ä¸ªè¿­ä»£çŠ¶æ€ï¼š

- `IterEnd`ï¼šè¡¨ç¤ºè¿­ä»£ç»ˆç‚¹
- `IterContinue`ï¼šè¡¨ç¤ºè¿­ä»£å°šæœªåˆ°è¾¾ç»ˆç‚¹ï¼Œå³è¿­ä»£åœ¨è¿™ä¸ªçŠ¶æ€ä¸‹ä¼šè¿›è¡Œä¸‹å»ã€‚

ç®€å•æ¥è¯´ï¼Œ`Iter[T]` æ¥æ”¶ä¸€ä¸ªå‡½æ•° `(T) -> IterResult` å¹¶åˆ©ç”¨å…¶è½¬æ¢è‡ªèº«çš„çŠ¶æ€ï¼ˆ`IterResult`ï¼‰ï¼Œè½¬æ¢åçš„çŠ¶æ€æ˜¯ä¸¤è€…ä¸­çš„å“ªä¸€ä¸ªåˆ™ç”±è¿™ä¸ªå‡½æ•°å†³å®šã€‚

è¿­ä»£å™¨ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ–¹æ³•ç”¨äºåºåˆ—ç»“æ„çš„è¿­ä»£ï¼Œ
ä¸”æ„é€ è¿™æ ·çš„è¿­ä»£å™¨æ˜¯å‡ ä¹æ²¡æœ‰é¢å¤–å¼€é”€çš„ï¼šåªè¦ `fn(yield)` æ²¡æœ‰æ‰§è¡Œï¼Œé‚£ä¹ˆè¿­ä»£å°±ä¸ä¼šå¼€å§‹ã€‚

åœ¨å†…éƒ¨å®ç°ä¸­ `Iter::run()` æ˜¯ç”¨äºè§¦å‘è¿­ä»£çš„ã€‚ä¸²æ¥å„ç§ Iter çš„æ–¹æ³•å¯èƒ½åœ¨å†™æ³•ä¸Šæ˜¾å¾—ååˆ†ä¼˜é›…ï¼Œä½†ä¹Ÿéœ€è¦æ³¨æ„æ–¹æ³•æŠ½è±¡ä¹‹ä¸‹çš„è¿­ä»£è¿‡ç¨‹ã€‚

ä¸å¤–éƒ¨è¿­ä»£å™¨ä¸åŒï¼Œå†…éƒ¨è¿­ä»£å™¨åªè¦è¿­ä»£è¿‡ç¨‹ä¸€å¼€å§‹å°±æ— æ³•åœæ­¢ï¼Œé™¤éåˆ°è¾¾è¿­ä»£ç»ˆç‚¹ã€‚
ç±»ä¼¼ `count()` ï¼ˆè¿”å›æŸä¸ªè¿­ä»£å™¨å…ƒç´ æ•°ç›®ï¼‰ä¹‹ç±»çš„æ–¹æ³•çœ‹ä¸Šå»æ˜¯ `O(1)`ï¼Œ
å®é™…ä¸Šå´æ˜¯çº¿æ€§å¤æ‚åº¦ã€‚å› æ­¤å¯¹äºå†…éƒ¨è¿­ä»£å™¨éœ€è¦å°å¿ƒä½¿ç”¨ï¼Œå¦åˆ™å¯èƒ½äº§ç”Ÿæ€§èƒ½é—®é¢˜ã€‚

## å†…ç½®æ•°æ®ç»“æ„

### å¸ƒå°”å€¼

MoonBit å†…ç½®äº†å¸ƒå°”ç±»å‹ï¼Œå®ƒæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ã€‚å¸ƒå°”ç±»å‹ç”¨äºæ¡ä»¶è¡¨è¾¾å¼å’Œæ§åˆ¶ç»“æ„ã€‚

```moonbit
let a = true
let b = false
let c = a && b
let d = a || b
let e = not(a)
```

### æ•°å­—

MoonBit æ”¯æŒæ•´å‹å’Œæµ®ç‚¹ç±»å‹ï¼š

| ç±»å‹     | æè¿°                         | ä¾‹å­    |
| -------- | ---------------------------- | ------- |
| `Int`    | 32 ä½æœ‰ç¬¦å·æ•´æ•°              | `42`    |
| `Int64`  | 64 ä½æœ‰ç¬¦å·æ•´æ•°              | `1000L` |
| `UInt`   | 32 ä½æ— ç¬¦å·æ•´æ•°              | `14U`   |
| `UInt64` | 64 ä½æ— ç¬¦å·æ•´æ•°              | `14UL`  |
| `Double` | 64 ä½æµ®ç‚¹æ•°ï¼Œç”± IEEE754 å®šä¹‰ | `3.14`  |

MoonBit æ”¯æŒçš„æ•°å­—å­—é¢é‡ï¼ŒåŒ…æ‹¬åè¿›åˆ¶ã€äºŒè¿›åˆ¶ã€å…«è¿›åˆ¶å’Œåå…­è¿›åˆ¶ã€‚

ä¸ºäº†æå‡å¯è¯»æ€§ï¼Œä½ å¯ä»¥åœ¨æ•°å­—å­—é¢é‡å†…æ’å…¥ä¸‹åˆ’çº¿ï¼Œä¾‹å¦‚ `1_000_000`ã€‚
æ³¨æ„ï¼Œä¸‹åˆ’çº¿å¯ä»¥æ’å…¥åˆ°æ•°å­—ä¹‹é—´çš„ä»»ä½•ä½ç½®ï¼Œè€Œéåªèƒ½åœ¨æ¯ä¸‰ä¸ªæ•°å­—ä¹‹é—´ã€‚

- åè¿›åˆ¶æ•°å’Œå¾€å¸¸ä¸€æ ·ã€‚

  ```moonbit
  let a = 1234
  let b = 1_000_000 + a
  let large_num = 9_223_372_036_854_775_807L // Int64 ç±»å‹çš„æ•´æ•°å¿…é¡»åç¼€â€œLâ€
  let unsigned_num = 4_294_967_295U // UInt ç±»å‹çš„æ•´æ•°å¿…é¡»æœ‰åç¼€â€Uâ€œ
  ```

- å…«è¿›åˆ¶æ•°çš„å‰ç¼€æ˜¯ 0 åæ¥å­—æ¯ Oï¼Œä¹Ÿå°±æ˜¯ `0o` æˆ– `0O`ã€‚æ³¨æ„åœ¨ `0o` æˆ– `0O`
  ä¹‹åå‡ºç°çš„æ•°å­—åªèƒ½åœ¨ `0` åˆ° `7` ä¹‹é—´ã€‚

  ```moonbit
  let octal = 0o1234
  let another_octal = 0O1234
  ```

- åå…­è¿›åˆ¶æ•°çš„å‰ç¼€æ˜¯ 0 åæ¥å­—æ¯ Xï¼Œä¹Ÿå°±æ˜¯ `0x` æˆ– `0X`ã€‚æ³¨æ„åœ¨ `0x` æˆ– `0X`
  ä¹‹åå‡ºç°çš„æ•°å­—åªèƒ½æ˜¯ `0123456789ABCDEF` ä¹‹ä¸€ã€‚

  ```moonbit
  let hex = 0XA
  let another_hex = 0xA
  ```

#### æ•´æ•°å­—é¢é‡é‡è½½

åœ¨çŸ¥é“éœ€è¦ä»€ä¹ˆç±»å‹æ—¶ï¼ŒMoonBit èƒ½å¤Ÿè‡ªåŠ¨é‡è½½æ•´æ•°å­—é¢é‡ï¼Œä¸éœ€è¦é€šè¿‡åç¼€æ¥åŒºåˆ†ä¸åŒç±»å‹çš„æ•´æ•°å­—é¢é‡ï¼š

```moonbit
let int : Int = 42
let uint : UInt = 42
let int64 : Int64 = 42
let double : Double = 42
```

### å­—ç¬¦ä¸²

å­—ç¬¦ä¸²`String`å†…éƒ¨ä¿å­˜äº† UTF-16 ç¼–ç å•å…ƒåºåˆ—ã€‚å¯ä»¥ä½¿ç”¨åŒå¼•å·æ¥è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ–è€…é€šè¿‡`#|`æ¥ä¹¦å†™å¤šè¡Œå­—ç¬¦ä¸²ã€‚

```moonbit
let a = "å…”rabbit"
println(a[0]) // output: å…”
println(a[1]) // output: r
```

```moonbit
let b =
  #| Hello
  #| MoonBit
  #|
```

åœ¨åŒå¼•å·åŒ…å›´çš„å­—ç¬¦ä¸²ä¹‹é—´æ”¯æŒä½¿ç”¨`\`è¡¨ç¤ºç‰¹æ®Šå­—ç¬¦è½¬ä¹‰ï¼š

| è½¬ä¹‰åºåˆ—             | è§£é‡Š                         |
| -------------------- | ---------------------------- |
| `\n`,`\r`,`\t`,`\b`  | æ¢è¡Œã€å›è½¦ã€æ°´å¹³åˆ¶è¡¨ç¬¦ã€é€€æ ¼ |
| `\\`                 | åæ–œæ                        |
| `\x41`               | 16 è¿›åˆ¶è½¬ä¹‰åºåˆ—              |
| `\o102`              | 8 è¿›åˆ¶è½¬ä¹‰åºåˆ—               |
| `\u5154`,`\u{1F600}` | Unicode å­—ç¬¦è½¬ä¹‰åºåˆ—         |

MoonBit æ”¯æŒå­—ç¬¦ä¸²æ’å€¼ï¼Œå®ƒå¯ä»¥æŠŠå­—ç¬¦ä¸²ä¸­å†…æ’çš„å˜é‡æ›¿æ¢ä¸ºå˜é‡å…·ä½“çš„å€¼ã€‚
è¿™ä¸ªç‰¹æ€§èƒ½å¤Ÿç®€åŒ–åŠ¨æ€æ‹¼æ¥å­—ç¬¦ä¸²çš„è¿‡ç¨‹ã€‚

```moonbit live
fn init {
  let x = 42
  println("The answer is \{x}")
}
```

ç”¨äºå­—ç¬¦ä¸²å†…æ’çš„å˜é‡å¿…é¡»æ”¯æŒ `to_string` æ–¹æ³•ã€‚

### å­—ç¬¦

å­—ç¬¦`Char`æ˜¯è¡¨ç¤ºä¸€ä¸ª Unicode å­—ç¬¦çš„æ•´æ•°ã€‚

```moonbit
let a : Char = 'A'
let b = '\x41'
let c = 'ğŸ°'
let zero = '\u{30}'
let zero = '\u0030'
```

### å­—èŠ‚

åœ¨ MoonBit ä¸­ï¼Œå­—èŠ‚å­—é¢é‡å¯ä»¥æ˜¯ä¸€ä¸ª ASCII å­—ç¬¦æˆ–ä¸€ä¸ªè½¬ä¹‰åºåˆ—ï¼Œå®ƒä»¬è¢«å•å¼•å·`'`åŒ…å›´ï¼Œå¹¶ä¸”å‰é¢æœ‰å­—ç¬¦`b`ã€‚å­—èŠ‚å­—é¢é‡çš„ç±»å‹æ˜¯ Byteã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn init {
  let b1 : Byte = b'a'
  println(b1.to_int())
  let b2 = b'\xff'
  println(b2.to_int())
}
```

### å…ƒç»„

å…ƒç»„æ˜¯ä¸€ä¸ªæœ‰é™å€¼çš„æœ‰åºé›†åˆï¼Œä½¿ç”¨åœ†æ‹¬å· `()` æ„é€ ï¼Œå…¶ä¸­çš„å…ƒç´ ç”±é€—å· `,` åˆ†éš”ã€‚
å…ƒç´ çš„é¡ºåºå¾ˆé‡è¦ï¼Œä¾‹å¦‚ `(1, true)` å’Œ `(true, 1)` æ˜¯ä¸åŒçš„ç±»å‹ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```moonbit live
fn pack(a: Bool, b: Int, c: String, d: Double) -> (Bool, Int, String, Double) {
    (a, b, c, d)
}
fn init {
    let quad = pack(false, 100, "text", 3.14)
    let (bool_val, int_val, str, float_val) = quad
    println("\{bool_val} \{int_val} \{str} \{float_val}")
}
```

å¯ä»¥é€šè¿‡æ¨¡å¼åŒ¹é…æˆ–ç´¢å¼•æ¥è®¿é—®å…ƒç»„ï¼š

```moonbit live
fn f(t : (Int, Int)) -> Unit {
  let (x1, y1) = t  // é€šè¿‡æ¨¡å¼åŒ¹é…è®¿é—®
  // é€šè¿‡ç´¢å¼•è®¿é—®
  let x2 = t.0
  let y2 = t.1
  if (x1 == x2 && y1 == y2) {
    println("yes")
  } else {
    println("no")
  }
}

fn init {
  f((1, 2))
}
```

### æ•°ç»„

æ•°ç»„æ˜¯ç”±æ–¹æ‹¬å· `[]` æ„é€ çš„æœ‰é™å€¼åºåˆ—ï¼Œå…¶ä¸­å…ƒç´ ç”±é€—å· `,` åˆ†éš”ã€‚ä¾‹å¦‚ï¼š

```moonbit
let numbers = [1, 2, 3, 4]
```

å¯ä»¥ç”¨ `numbers[x]` æ¥å¼•ç”¨ç¬¬ `x` ä¸ªå…ƒç´ ã€‚ç´¢å¼•ä»é›¶å¼€å§‹ã€‚

```moonbit live
fn init {
  let numbers = [1, 2, 3, 4]
  let a = numbers[2]
  numbers[3] = 5
  let b = a + numbers[3]
  println(b)  // æ‰“å° 8
}
```

### Map

MoonBit æ ‡å‡†åº“æä¾›ä¸€ä¸ªä¿æŒæ’å…¥é¡ºåºçš„å“ˆå¸Œè¡¨æ•°æ®ç»“æ„ `Map`ã€‚`Map` å¯ä»¥é€šè¿‡å­—é¢é‡ä¾¿æ·åœ°åˆ›å»ºï¼š

```moonbit
let map : Map[String, Int] = { "x": 1, "y": 2, "z": 3 }
```

ç›®å‰ï¼Œ`Map` å­—é¢é‡ä¸­é”®çš„éƒ¨åˆ†å¿…é¡»æ˜¯å¸¸é‡ã€‚`Map` ä¹Ÿå¯ä»¥ç”¨æ¨¡å¼åŒ¹é…ä¼˜é›…åœ°è§£æ„ï¼Œè§ [é”®å€¼å¯¹æ¨¡å¼åŒ¹é…](#é”®å€¼å¯¹æ¨¡å¼åŒ¹é…)ã€‚

## Json å­—é¢é‡

MoonBit é€šè¿‡é‡è½½å­—é¢é‡çš„å½¢å¼æ”¯æŒ json å­—é¢é‡ï¼Œèƒ½å¤Ÿä¾¿æ·åœ°åˆ›å»ºå’Œæ“ä½œ json æ•°æ®ã€‚å½“é¢„æœŸç±»å‹æ˜¯ `@json.JsonValue` æ—¶ï¼Œæ•°å­—ã€å­—ç¬¦ä¸²ã€æ•°ç»„å’Œ `Map` å­—é¢é‡å¯ä»¥è¢«ç”¨äºåˆ›å»º json æ•°æ®ï¼š

```moonbit
let moon_pkg_json_example : @json.JsonValue = {
  "import": [ "moonbitlang/core/builtin", "moonbitlang/core/coverage" ],
  "test-import": [ "moonbitlang/core/random" ]
}
```

Json æ•°æ®ä¹Ÿå¯ä»¥è¢«æ¨¡å¼åŒ¹é…ï¼Œè§ [Json æ¨¡å¼åŒ¹é…](#json-æ¨¡å¼)ã€‚

## å˜é‡ç»‘å®š

å˜é‡å¯ä»¥é€šè¿‡ `let mut` æˆ– `let` åˆ†åˆ«å£°æ˜ä¸ºå¯å˜æˆ–ä¸å¯å˜ã€‚
å¯å˜å˜é‡å¯ä»¥é‡æ–°èµ‹å€¼ï¼Œä¸å¯å˜å˜é‡åˆ™ä¸èƒ½ã€‚

```moonbit live
let zero = 0

fn init {
  let mut i = 10
  i = 20
  println(i + zero)
}
```

## æ•°æ®ç±»å‹

åˆ›å»ºæ–°æ•°æ®ç±»å‹çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼š`struct` å’Œ `enum`ã€‚

### ç»“æ„

åœ¨ MoonBit ä¸­ï¼Œç»“æ„ä¸å…ƒç»„ç±»ä¼¼ï¼Œä½†å®ƒä»¬çš„å­—æ®µç”±å­—æ®µåç´¢å¼•ã€‚
ç»“æ„ä½“å¯ä»¥ä½¿ç”¨ç»“æ„ä½“å­—é¢é‡æ„é€ ï¼Œç»“æ„ä½“å­—é¢é‡ç”±ä¸€ç»„å¸¦æœ‰æ ‡ç­¾çš„å€¼ç»„æˆï¼Œå¹¶ç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ã€‚
å¦‚æœç»“æ„ä½“å­—é¢é‡çš„å­—æ®µå®Œå…¨åŒ¹é…ç±»å‹å®šä¹‰ï¼Œåˆ™å…¶ç±»å‹å¯ä»¥è¢«è‡ªåŠ¨æ¨æ–­ã€‚
ä½¿ç”¨ç‚¹è¯­æ³• `s.f` å¯ä»¥è®¿é—®ç»“æ„ä½“å­—æ®µã€‚
å¦‚æœä¸€ä¸ªå­—æ®µä½¿ç”¨å…³é”®å­— `mut` æ ‡è®°ä¸ºå¯å˜ï¼Œé‚£ä¹ˆå¯ä»¥ç»™å®ƒèµ‹äºˆæ–°çš„å€¼ã€‚

```moonbit live
struct User {
  id: Int
  name: String
  mut email: String
}

fn init {
  let u = { id: 0, name: "John Doe", email: "john@doe.com" }
  u.email = "john@doe.name"
  println(u.id)
  println(u.name)
  println(u.email)
}
```

#### åˆ›å»ºç»“æ„ä½“çš„ç®€å†™å½¢å¼

å¦‚æœå·²ç»æœ‰å’Œç»“æ„ä½“çš„å­—æ®µåŒåçš„å˜é‡ï¼Œå¹¶ä¸”æƒ³ä½¿ç”¨è¿™äº›å˜é‡ä½œä¸ºç»“æ„ä½“åŒåå­—æ®µçš„å€¼ï¼Œ
é‚£ä¹ˆåˆ›å»ºç»“æ„ä½“æ—¶ï¼Œå¯ä»¥åªå†™å­—æ®µåï¼Œä¸éœ€è¦æŠŠåŒä¸€ä¸ªåå­—é‡å¤ä¸¤æ¬¡ã€‚ä¾‹å¦‚ï¼š

```moonbit live
fn init{
  let name = "john"
  let email = "john@doe.com"
  let u = { id: 0, name, email } // ç­‰ä»·äº { id: 0, name: name, email: email }
}
```

#### æ›´æ–°ç»“æ„ä½“çš„è¯­æ³•

å¦‚æœæƒ³è¦åŸºäºç°æœ‰çš„ç»“æ„ä½“æ¥åˆ›å»ºæ–°çš„ç»“æ„ä½“ï¼Œåªéœ€ä¿®æ”¹ç°æœ‰ç»“æ„ä½“çš„ä¸€éƒ¨åˆ†å­—æ®µï¼Œå…¶ä»–å­—æ®µçš„å€¼ä¿æŒä¸å˜ï¼Œ
å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼š

```moonbit live
struct User {
  id: Int
  name: String
  email: String
} derive(Show)

fn init {
  let user = { id: 0, name: "John Doe", email: "john@doe.com" }
  let updated_user = { ..user, email: "john@doe.name" }
  println(user)          // è¾“å‡º: { id: 0, name: "John Doe", email: "john@doe.com" }
  println(updated_user)  // è¾“å‡º: { id: 0, name: "John Doe", email: "john@doe.name" }
}
```

### æšä¸¾

æšä¸¾ç±»å‹å¯¹åº”äºä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼ŒADTï¼‰ï¼Œ
ç†Ÿæ‚‰ C/C++ çš„äººå¯èƒ½æ›´ä¹ æƒ¯å«å®ƒå¸¦æ ‡ç­¾çš„è”åˆä½“ï¼ˆtagged unionï¼‰ã€‚

æšä¸¾ç”±ä¸€ç»„åˆ†æ”¯ï¼ˆæ„é€ å™¨ï¼‰ç»„æˆï¼Œæ¯ä¸ªåˆ†æ”¯éƒ½æœ‰ä¸€ä¸ªåå­—ï¼ˆå¿…é¡»ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼‰ï¼Œå¯ä»¥ç”¨è¿™ä¸ªåå­—æ¥æ„é€ å¯¹åº”åˆ†æ”¯çš„å€¼ï¼Œ
æˆ–è€…åœ¨æ¨¡å¼åŒ¹é…ä¸­ä½¿ç”¨è¿™ä¸ªåå­—æ¥åˆ¤æ–­æŸä¸ªæšä¸¾å€¼å±äºå“ªä¸ªåˆ†æ”¯ï¼š

```moonbit live
// ä¸€ä¸ªè¡¨ç¤ºä¸¤ä¸ªå€¼ä¹‹é—´çš„æœ‰åºå…³ç³»çš„æšä¸¾ç±»å‹ï¼Œæœ‰ â€œå°äºâ€ã€â€œå¤§äºâ€ã€â€œç­‰äºâ€ ä¸‰ä¸ªåˆ†æ”¯
enum Relation {
  Smaller
  Greater
  Equal
}

// è®¡ç®—ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„é¡ºåºå…³ç³»
fn compare_int(x: Int, y: Int) -> Relation {
  if x < y {
    // åˆ›å»ºæšä¸¾æ—¶ï¼Œå¦‚æœçŸ¥é“æƒ³è¦ä»€ä¹ˆç±»å‹ï¼Œå¯ä»¥ç›´æ¥å†™åˆ†æ”¯/æ„é€ å™¨çš„åå­—æ¥åˆ›å»º
    Smaller
  } else if x > y {
    // ä½†å¦‚æœä¸çŸ¥é“ç±»å‹ï¼Œæ°¸è¿œå¯ä»¥é€šè¿‡ `ç±»å‹åå­—::æ„é€ å™¨` çš„è¯­æ³•æ¥æ— æ­§ä¹‰åœ°åˆ›å»ºæšä¸¾å€¼
    Relation::Greater
  } else {
    Equal
  }
}

// è¾“å‡ºä¸€ä¸ª `Relation` ç±»å‹çš„å€¼
fn print_relation(r: Relation) -> Unit {
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…åˆ¤æ–­ r å±äºå“ªä¸ªåˆ†æ”¯
  match r {
    // æ¨¡å¼åŒ¹é…æ—¶ï¼Œå¦‚æœçŸ¥é“ç±»å‹ï¼Œç›´æ¥ä½¿ç”¨æ„é€ å™¨åå­—å³å¯
    Smaller => println("smaller!")
    // ä½†ä¹Ÿå¯ä»¥ç”¨ `ç±»å‹åå­—::æ„é€ å™¨` çš„è¯­æ³•è¿›è¡Œæ¨¡å¼åŒ¹é…
    Relation::Greater => println("greater!")
    Equal => println("equal!")
  }
}

fn init {
  print_relation(compare_int(0, 1)) // è¾“å‡º smaller!
  print_relation(compare_int(1, 1)) // è¾“å‡º equal!
  print_relation(compare_int(2, 1)) // è¾“å‡º greater!
}
```

æšä¸¾çš„åˆ†æ”¯è¿˜å¯ä»¥æºå¸¦é¢å¤–çš„æ•°æ®ã€‚ä¸‹é¢æ˜¯ç”¨æšä¸¾å®šä¹‰æ•´æ•°åˆ—è¡¨ç±»å‹çš„ä¸€ä¸ªä¾‹å­ï¼š

```moonbit live
enum List {
  Nil
  // æ„é€ å™¨ `Cons` æºå¸¦äº†é¢å¤–çš„æ•°æ®ï¼šåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå’Œåˆ—è¡¨å‰©ä½™çš„éƒ¨åˆ†
  Cons (Int, List)
}

fn init {
  // ä½¿ç”¨ `Cons` åˆ›å»ºåˆ—è¡¨æ—¶ï¼Œéœ€è¦æä¾› `Cons` è¦æ±‚çš„é¢å¤–æ•°æ®ï¼šç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä½™çš„åˆ—è¡¨
  let l: List = Cons(1, Cons(2, Nil))
  println(is_singleton(l))
  print_list(l)
}

fn print_list(l: List) -> Unit {
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†å¸¦é¢å¤–æ•°æ®çš„æšä¸¾æ—¶ï¼Œé™¤äº†åˆ¤æ–­å€¼å±äºå“ªä¸ªåˆ†æ”¯ï¼Œ
  // è¿˜å¯ä»¥æŠŠå¯¹åº”åˆ†æ”¯æºå¸¦çš„æ•°æ®æå–å‡ºæ¥
  match l {
    Nil => println("nil")
    // è¿™é‡Œçš„ `x` å’Œ `xs` ä¸æ˜¯ç°æœ‰å˜é‡ï¼Œè€Œæ˜¯æ–°çš„å˜é‡ã€‚
    // å¦‚æœ `l` æ˜¯ä¸€ä¸ª `Cons`ï¼Œé‚£ä¹ˆ `Cons` ä¸­æºå¸¦çš„é¢å¤–æ•°æ®ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä½™éƒ¨åˆ†ï¼‰
    // ä¼šåˆ†åˆ«è¢«ç»‘å®šåˆ° `x` å’Œ `xs`
    Cons(x, xs) => {
      println(x)
      println(",")
      print_list(xs)
    }
  }
}

// é™¤äº†å˜é‡ï¼Œè¿˜å¯ä»¥å¯¹æ„é€ å™¨ä¸­æºå¸¦çš„æ•°æ®è¿›è¡Œè¿›ä¸€æ­¥çš„åŒ¹é…ã€‚
// ä¾‹å¦‚ï¼Œä¸‹é¢çš„å‡½æ•°åˆ¤æ–­ä¸€ä¸ªåˆ—è¡¨æ˜¯å¦åªæœ‰ä¸€ä¸ªå…ƒç´ 
fn is_singleton(l: List) -> Bool {
  match l {
    // è¿™ä¸ªåˆ†æ”¯åªä¼šåŒ¹é…å½¢å¦‚ `Cons(_, Nil)` çš„å€¼ï¼Œä¹Ÿå°±æ˜¯é•¿åº¦ä¸º 1 çš„åˆ—è¡¨
    Cons(_, Nil) => true
    // ç”¨ `_` æ¥åŒ¹é…å‰©ä¸‹çš„æ‰€æœ‰å¯èƒ½æ€§
    _ => false
  }
}
```

#### å¸¦æ ‡ç­¾çš„æ„é€ å™¨å‚æ•°

æšä¸¾æ„é€ å™¨å¯ä»¥æœ‰å¸¦æ ‡ç­¾çš„å‚æ•°ï¼š

```moonbit live
enum E {
  // `x` å’Œ `y` æ˜¯å¸¦æ ‡ç­¾çš„å‚æ•°
  C(~x : Int, ~y : Int)
}

// æ¨¡å¼åŒ¹é…æœ‰å¸¦æ ‡ç­¾å‚æ•°çš„æ„é€ å™¨
fn f(e : E) -> Unit {
  match e {
    // `æ ‡ç­¾=åŒ¹é…å‚æ•°çš„æ¨¡å¼`
    C(x=0, y=0) => println("0!")
    // `~x` æ˜¯ `x=x` çš„ç®€å†™
    // æœªè¢«åŒ¹é…çš„å¸¦æ ‡ç­¾å‚æ•°å¯ä»¥ç”¨ `..` æ¥å¿½ç•¥
    C(~x, ..) => println(x)
  }
}

// åˆ›å»ºæœ‰å¸¦æ ‡ç­¾å‚æ•°çš„æ„é€ å™¨
fn init {
  f(C(x=0, y=0)) // `æ ‡ç­¾=å‚æ•°çš„å€¼`
  let x = 0
  f(C(~x, y=1)) // `~x` æ˜¯ `x=x` çš„ç®€å†™
}
```

åœ¨æ¨¡å¼åŒ¹é…ä¸­ï¼Œè¿˜å¯ä»¥åƒè®¿é—®ç»“æ„ä½“çš„å­—æ®µä¸€æ ·ç›´è®¿é—®å–æ„é€ å™¨çš„å¸¦æ ‡ç­¾å‚æ•°ï¼š

```moonbit live
enum Object {
  Point(~x : Double, ~y : Double)
  Circle(~x : Double, ~y : Double, ~radius : Double)
}

fn distance_with(self : Object, other : Object) -> Double {
  match (self, other) {
    // å¦‚æœé€šè¿‡ `Point(..) as p` çš„æ–¹å¼å®šä¹‰ä¸€ä¸ªå˜é‡ `p`ï¼Œ
    // ç¼–è¯‘å™¨çŸ¥é“ `p` ä¸€å®šæ˜¯æ„é€ å™¨ `Point`ï¼Œ
    // æ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ `p.x`ã€`p.y` è®¿é—® `Point` çš„å¸¦æ ‡ç­¾å‚æ•°
    (Point(_) as p1, Point(_) as p2) => {
      let dx = p2.x - p1.x
      let dy = p2.y - p1.y
      (dx * dx + dy * dy).sqrt()
    }
    (Point(_), Circle(_)) | (Circle(_) | Point(_)) | (Circle(_), Circle(_)) => abort("not implemented")
  }
}

fn init {
  let p1 : Point = Point(x=0, y=0)
  let p2 : Point = Point(x=3, y=4)
  println(p1.distance_with(p2)) // 5.0
}
```

#### æ„é€ å™¨çš„å¯å˜å­—æ®µ

MoonBit æ”¯æŒç»™æ„é€ å™¨å£°æ˜å¯å˜çš„å­—æ®µã€‚è¿™å¯¹å®ç°å¯å˜æ•°æ®ç»“æ„éå¸¸æœ‰ç”¨ï¼š

```moonbit live
// ä¸€ä¸ªå¸¦çˆ¶èŠ‚ç‚¹æŒ‡é’ˆçš„å¯å˜äºŒå‰æœç´¢æ ‘çš„ç±»å‹
enum Tree[X] {
  Nil
  // only labelled arguments can be mutable
  Node(mut ~value : X, mut ~left : Tree[X], mut ~right : Tree[X], mut ~parent : Tree[X])
}

// ä¸€ä¸ªä½¿ç”¨å¯å˜çš„äºŒå‰æœç´¢æ ‘å®ç°çš„é›†åˆ
struct Set[X] {
  mut root : Tree[X]
}

fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {
  self.root = self.root.insert(x, parent=Nil)
}

// åƒä¸€æ£µå¯å˜çš„äºŒå‰æœç´¢æ ‘ä¸­æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´ ã€‚
// è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘æ–°çš„æ ¹èŠ‚ç‚¹
fn Tree::insert[X : Compare](self : Tree[X], x : X, ~parent : Tree[X]) -> Tree[X] {
  match self {
    Nil => Node(value=x, left=Nil, right=Nil, ~parent)
    Node(_) as node => {
      let order = x.compare(node.value)
      if order == 0 {
        // ä¿®æ”¹æ„é€ å™¨ä¸­çš„å­—æ®µ
        node.value = x
      } else if order < 0 {
        // è¿™é‡Œåœ¨ `node` å’Œ `node.left` ä¹‹é—´åˆ›å»ºäº†ä¸€ä¸ªç¯
        node.left = node.left.insert(x, parent=node)
      } else {
        node.right = node.right.insert(x, parent=node)
      }
      // è¿™æ£µäºŒå‰æ ‘æ˜¯éç©ºçš„ï¼Œæ‰€ä»¥æ ¹èŠ‚ç‚¹è¿˜æ˜¯åŸæ¥é‚£ä¸ª
      node
    }
  }
}
```

### æ–°ç±»å‹

MoonBit æ”¯æŒä¸€ç§ç‰¹æ®Šçš„æšä¸¾ç±»å‹ï¼Œç§°ä¸ºæ–°ç±»å‹ï¼ˆnewtypeï¼‰ï¼š

```moonbit
// `UserId` æ˜¯ä¸€ä¸ªå…¨æ–°çš„ç±»å‹ï¼Œè€Œä¸”ç”¨æˆ·å¯ä»¥ç»™ `UserId` å®šä¹‰æ–°çš„æ–¹æ³•ç­‰
// ä½†ä¸æ­¤åŒæ—¶ï¼Œ`UserId` çš„å†…éƒ¨è¡¨ç¤ºå’Œ `Int` æ˜¯å®Œå…¨ä¸€è‡´çš„
type UserId Int
type UserName String
```

æ–°ç±»å‹å’Œåªæœ‰ä¸€ä¸ªæ„é€ å™¨ï¼ˆä¸ç±»å‹åŒåï¼‰çš„æšä¸¾ç±»å‹éå¸¸ç›¸ä¼¼ã€‚
å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨æ„é€ å™¨æ¥åˆ›å»ºæ–°ç±»å‹çš„å€¼ã€ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥æå–æ–°ç±»å‹çš„å†…éƒ¨è¡¨ç¤ºï¼š

```moonbit
fn init {
  let id: UserId = UserId(1)
  let name: UserName = UserName("John Doe")
  let UserId(uid) = id        // `uid` çš„ç±»å‹æ˜¯ `Int`
  let UserName(uname) = name  // `uname` çš„ç±»å‹æ˜¯ `String`
  println(uid)
  println(uname)
}
```

é™¤äº†æ¨¡å¼åŒ¹é…ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `.0` æå–æ–°ç±»å‹çš„å†…éƒ¨è¡¨ç¤ºï¼š

```moonbit
fn init {
  let id: UserId = UserId(1)
  let uid: Int = id.0
  println(uid)
}
```

## æ¨¡å¼åŒ¹é…

æˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•å¯¹æšä¸¾è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼Œä½†æ¨¡å¼åŒ¹é…å¹¶ä¸ä»…é™äºæšä¸¾ã€‚
ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹å¸ƒå°”å€¼ã€æ•°å­—ã€å­—ç¬¦ã€å­—ç¬¦ä¸²ã€å…ƒç»„ã€æ•°ç»„å’Œç»“æ„ä½“å­—é¢é‡è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚
ç”±äºè¿™äº›ç±»å‹å’Œæšä¸¾ä¸åŒï¼Œå®ƒä»¬åªæœ‰ä¸€ç§æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ `let` ç»‘å®šæ¥å¯¹å®ƒä»¬è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ `match` ä¸­ç»‘å®šçš„å˜é‡çš„ä½œç”¨åŸŸä»…é™äºå¼•å…¥è¯¥å˜é‡çš„æƒ…å†µåˆ†æ”¯ï¼Œè€Œ `let`
ç»‘å®šä¼šå°†æ¯ä¸ªå˜é‡éƒ½å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ `_` ä½œä¸ºæˆ‘ä»¬ä¸å…³å¿ƒçš„å€¼çš„é€šé…ç¬¦ã€‚

```moonbit
let id = match u {
  { id: id, name: _, email: _ } => id
}
// ç­‰ä»·äº
let { id: id, name: _, email: _ } = u
```

æ¨¡å¼åŒ¹é…è¿˜æœ‰ä¸€äº›æœ‰ç”¨çš„æ„é€ ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `as` ä¸ºæŸä¸ªæ¨¡å¼æŒ‡å®šä¸€ä¸ªåç§°ï¼Œ
å¹¶ä¸”å¯ä»¥ä½¿ç”¨ `|` åŒæ—¶åŒ¹é…å¤šä¸ªæƒ…å†µã€‚

```moonbit
match expr {
  Lit(n) as a => ...
  Add(e1, e2) | Mul(e1, e2) => ...
  _ => ...
}
```

### é”®å€¼å¯¹æ¨¡å¼åŒ¹é…

MoonBit å…è®¸æ¨¡å¼åŒ¹é…å­—å…¸ç­‰å…·æœ‰é”®å€¼å¯¹ç»“æ„çš„æ•°æ®ç»“æ„ã€‚åœ¨ä¸€ä¸ªå­—å…¸æ¨¡å¼é‡Œï¼Œ`key : value` è¯­æ³•å¯ä»¥ç”¨æ¥åŒ¹é… `key` å­˜åœ¨çš„æƒ…å†µï¼Œ`value` ä¼šè¢«ç”¨äºåŒ¹é… `key` åœ¨é”®å€¼å¯¹ä¸­çš„å€¼ã€‚`key? : value` è¯­æ³•æ— è®º `key` æ˜¯å¦å­˜åœ¨éƒ½èƒ½åŒ¹é…ï¼Œ`value` ä¼šè¢«ç”¨äºåŒ¹é… `map[key]` çš„å€¼ï¼ˆä¸€ä¸ª `Option` ç±»å‹çš„å€¼ï¼‰ï¼š

```moonbit
match map {
  // åŒ¹é…é”® "b" å­˜åœ¨çš„æƒ…å†µ
  { "b": _ } => ..
  // åŒ¹é… "b" ä¸å­˜åœ¨ä¸” "a" å­˜åœ¨çš„æƒ…å†µï¼Œ
  // åŒ¹é…æˆåŠŸæ—¶ï¼ŒæŠŠ "a" çš„å€¼ç»‘å®šåˆ° `x`
  { "b"? : None, "a": x } => ..
  // ç¼–è¯‘å™¨æŒ‡å‡ºä¸‹åˆ—æƒ…å†µæ²¡æœ‰è¢«åŒ¹é…åˆ°ï¼š{ "b"? : None, "a"? : None }
}
```

- å¦‚æœè¦ç”¨å­—å…¸æ¨¡å¼åŒ¹é…ç±»å‹ `T`ï¼Œå¿…é¡»ç»™ç±»å‹ `T` å®ç°æ–¹æ³• `op_get`ã€‚`op_get` çš„ç±»å‹å¿…é¡»æ˜¯ `(Self, K) -> Option[V]`ï¼Œå…¶ä¸­ `K` æ˜¯é”®çš„ç±»å‹ï¼Œ`V` æ˜¯å€¼çš„ç±»å‹
- ç›®å‰ï¼Œå­—å…¸æ¨¡å¼çš„é”®éƒ¨åˆ†å¿…é¡»æ˜¯ä¸€ä¸ªå¸¸é‡
- å­—å…¸æ¨¡å¼æ°¸è¿œæ˜¯å¼€æ”¾çš„ï¼šæœªè¢«åŒ¹é…åˆ°çš„é”®ä¼šè¢«å¿½ç•¥
- å­—å…¸æ¨¡å¼ä¼šè¢«ç¼–è¯‘æˆé«˜æ•ˆçš„ä»£ç ï¼šæ¯ä¸ªé”®è‡³å¤šè¢«æŸ¥è¯¢ä¸€æ¬¡

### Json æ¨¡å¼åŒ¹é…

å½“æ¨¡å¼åŒ¹é…ç±»å‹æ˜¯ `@json.JsonValue` çš„å€¼æ˜¯ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨å„ç§å­—é¢é‡æ¨¡å¼æ¥åŒ¹é…ï¼š

```moonbit
match json {
  { "version": "1.0.0", "import": [..] as imports } => ...
  _ => ...
}
```

## æ“ä½œç¬¦

### è¿ç®—ç¬¦é‡è½½

MoonBit æ”¯æŒé€šè¿‡æ–¹æ³•é‡è½½å†…ç½®è¿ç®—ç¬¦ã€‚ä¸è¿ç®—ç¬¦ `<op>` ç›¸å¯¹åº”çš„æ–¹æ³•åæ˜¯ `op_<op>`ã€‚ä¾‹å¦‚ï¼š

```moonbit live
struct T {
  x:Int
} derive(Show)

fn op_add(self: T, other: T) -> T {
  { x: self.x + other.x }
}

fn init {
  let a = { x:0, }
  let b = { x:2, }
  println(a + b)
}
```

å¦ä¸€ä¸ªä¾‹å­ï¼ˆå…³äº`op_get`å’Œ`op_set`ï¼‰:

```moonbit live
struct Coord {
  mut x: Int
  mut y: Int
} derive(Show)

fn op_get(self: Coord, key: String) -> Int {
  match key {
    "x" => self.x
    "y" => self.y
  }
}

fn op_set(self: Coord, key: String, val: Int) -> Unit {
    match key {
    "x" => self.x = val
    "y" => self.y = val
  }
}

fn init {
  let c = { x: 1, y: 2 }
  println(c)
  println(c["y"])
  c["x"] = 23
  println(c)
  println(c["x"])
}
```

ç›®å‰ï¼Œä»¥ä¸‹è¿ç®—ç¬¦å¯ä»¥è¢«é‡è½½ï¼š

| è¿ç®—ç¬¦åç§°           | æ–¹æ³•å       |
| -------------------- | ------------ |
| `+`                  | `op_add`     |
| `-`                  | `op_sub`     |
| `*`                  | `op_mul`     |
| `/`                  | `op_div`     |
| `%`                  | `op_mod`     |
| `=`                  | `op_equal`   |
| `-`ï¼ˆä¸€å…ƒè¿ç®—ç¬¦ï¼‰    | `op_neg`     |
| `_[_]`ï¼ˆè·å–é¡¹ï¼‰     | `op_get`     |
| `_[_] = _`ï¼ˆè®¾ç½®é¡¹ï¼‰ | `op_set`     |
| `_[_:_]`ï¼ˆè§†å›¾ï¼‰     | `op_as_view` |

### ç®¡é“è¿ç®—ç¬¦

MoonBit æä¾›äº†ä¾¿åˆ©çš„ç®¡é“è¿ç®—ç¬¦ `|>`ï¼Œå¯ä»¥ç”¨äºé“¾å¼è°ƒç”¨æ™®é€šå‡½æ•°ï¼š

```moonbit
fn init {
  x |> f     // ç­‰ä»·äº f(x)
  x |> f(y)  // ç­‰ä»·äº f(x, y)

  // åˆ†å¸ƒåœ¨å¤šè¡Œçš„é“¾å¼è°ƒç”¨
  arg_val
  |> f1 // ç­‰ä»·äº f1(arg_val)
  |> f2(other_args) // ç­‰ä»·äº f2(f1(arg_val), other_args)
}
```

### çº§è”æ“ä½œç¬¦

çº§è”è¿ç®—ç¬¦`..`ç”¨äºè¿ç»­å¯¹åŒä¸€ä¸ªå€¼è¿›è¡Œä¸€ç³»åˆ—å¯å˜çš„æ“ä½œ, è¯­æ³•å¦‚ä¸‹ï¼š

```moonbit
x..f()
```

`x..f()..g()`ç›¸å½“äº`{x.f(); x.g(); x}`ã€‚

è€ƒè™‘è¿™æ ·çš„éœ€æ±‚ï¼šå¯¹äºä¸€ä¸ªæ‹¥æœ‰`add_string`ã€
`add_char`ã€`add_int` ç­‰æ–¹æ³•çš„ `MyStringBuilder` ç±»å‹ï¼Œæˆ‘ä»¬å¸¸å¸¸éœ€è¦å¯¹åŒä¸€ä¸ª
`MyStringBuilder` ç±»å‹çš„å€¼è¿›è¡Œä¸€ç³»åˆ—æ“ä½œï¼š

```moonbit
let builder = MyStringBuilder::new()
builder.add_char('a')
builder.add_char('a')
builder.add_int(1001)
builder.add_string("abcdef")
let result = builder.to_string()
```

ä¸ºäº†é¿å…é‡å¤é”®å…¥`builder`ï¼Œå®ƒçš„æ–¹æ³•å¸¸å¸¸è¢«è®¾è®¡ä¸ºè¿”å›`self`æœ¬èº«ï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç”¨`.`è¿ç®—ç¬¦å°†æ“ä½œä¸²è¿èµ·æ¥ã€‚
ä¸ºäº†åŒºåˆ†ä¸å¯å˜ä¸å¯å˜æ“ä½œï¼Œåœ¨ MoonBit ä¸­ï¼Œå¯¹äºæ‰€æœ‰è¿”å›`Unit`çš„æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨çº§è”è¿ç®—ç¬¦è¿›è¡Œè¿ç»­çš„æ“ä½œï¼Œ
è€Œä¸éœ€è¦ä¸“é—¨ä¿®æ”¹æ–¹æ³•çš„è¿”å›ç±»å‹ã€‚

ä¸ºäº†é¿å…é‡å¤é”®å…¥ä¸Šå›¾ä¸­çš„`array`, å’ŒåŒºåˆ†ä¸å¯å˜ä¸å¯å˜æ“ä½œï¼ŒMoonBit å¼•å…¥äº†çº§è”è¿ç®—ç¬¦ã€‚å¯¹äºä¸€ä¸ªç±»å‹ä¸­çš„æ‰€æœ‰è¿”å›`Unit`çš„æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨`..`å°†è¿™äº›æ–¹æ³•çš„è°ƒç”¨ä¸²è”èµ·æ¥ï¼Œ
è€Œä¸éœ€è¦ä¸“é—¨ä¿®æ”¹è¿™äº›æ–¹æ³•çš„è¿”å›ç±»å‹ã€‚ `array..push(5)..sort()`ç›¸å½“äºä¾æ¬¡è°ƒç”¨äº†å¯å˜æ“ä½œ`array.push(5)`å’Œ`array.sort()`, æœ€ç»ˆè¿”å›`array`ã€‚

```moonbit
let result =
  MyStringBuilder::new()
    ..add_char('a')
    ..add_char('a')
    ..add_int(1001)
    ..add_string("abcdef")
    .to_string()
```

### ä½è¿ç®—ç¬¦

MoonBit æ”¯æŒ C é£æ ¼çš„ä½è¿ç®—ç¬¦ï¼Œå¯ç”¨äº 32 ä½å’Œ 64 ä½çš„ `Int` å’Œ `UInt`ï¼Œæ ¼å¼åŒ–å·¥å…·ä¼šè‡ªåŠ¨æ·»åŠ æ‹¬å·æ¥é¿å…æ­§ä¹‰ã€‚

| è¿ç®—ç¬¦ | æ“ä½œ   |
| ------ | ------ |
| `&`    | `land` |
| `\|`   | `lor`  |
| `^`    | `lxor` |
| `<<`   | `lsl`  |
| `>>`   | `lsr`  |

## é”™è¯¯å¤„ç†

### é”™è¯¯ç±»å‹

åœ¨ MoonBit ä¸­ä½¿ç”¨çš„é”™è¯¯å€¼å¿…é¡»å…·æœ‰é”™è¯¯ç±»å‹ã€‚é”™è¯¯ç±»å‹å¯ä»¥é€šè¿‡ä»¥ä¸‹å½¢å¼å®šä¹‰ï¼š

```moonbit
type! E1 Int  // é”™è¯¯ç±»å‹ E1 å…·æœ‰ä¸€ä¸ªæ„é€ å‡½æ•° E1ï¼Œå¹¶å¸¦æœ‰ä¸€ä¸ª Int è´Ÿè½½
type! E2      // é”™è¯¯ç±»å‹ E2 å…·æœ‰ä¸€ä¸ªæ²¡æœ‰è´Ÿè½½çš„æ„é€ å‡½æ•° E2
type! E3 {    // é”™è¯¯ç±»å‹ E3 ç±»ä¼¼äºæ™®é€šçš„æšä¸¾ç±»å‹ï¼Œæœ‰ä¸‰ä¸ªæ„é€ å‡½æ•°
  A
  B(Int, ~x : String)
  C(mut ~x : String, Char, ~y : Bool)
}

```

å‡½æ•°çš„è¿”å›ç±»å‹å¯ä»¥åŒ…å«é”™è¯¯ç±»å‹ï¼Œä»¥è¡¨æ˜å‡½æ•°å¯èƒ½è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹å‡½æ•° `div`
å¯èƒ½è¿”å›ä¸€ä¸ªç±»å‹ä¸º `DivError` çš„é”™è¯¯ï¼š

```moonbit
type! DivError String
fn div(x: Int, y: Int) -> Int!DivError {
  if y == 0 {
    raise DivError("division by zero")
  }
  x / y
}
```

è¿™é‡Œä½¿ç”¨äº†å…³é”®å­— `raise` æ¥ä¸­æ–­å‡½æ•°æ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

### é»˜è®¤é”™è¯¯ç±»å‹

MoonBit æä¾›äº†ä¸€ä¸ªé»˜è®¤çš„é”™è¯¯ç±»å‹ `Error`ï¼Œå½“å…·ä½“çš„é”™è¯¯ç±»å‹ä¸é‡è¦æ—¶å¯ä»¥ä½¿ç”¨è¯¥ç±»å‹ã€‚
ä¸ºäº†æ–¹ä¾¿ï¼Œä½ å¯ä»¥åœ¨å‡½æ•°åæˆ–è¿”å›ç±»å‹ååŠ ä¸Š ! æ¥è¡¨æ˜ä½¿ç”¨äº† `Error` ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹å‡½
æ•°ç­¾åæ˜¯ç­‰ä»·çš„ï¼š

```moonbit
fn f() -> Unit! { .. }
fn f!() -> Unit { .. }
fn f() -> Unit!Error { .. }
```

å¯¹äºåŒ¿åå‡½æ•°å’ŒçŸ©é˜µå‡½æ•°ï¼Œä½ å¯ä»¥åœ¨å…³é”®å­— `fn` ååŠ ä¸Š `!` æ¥å®ç°ç›¸åŒçš„æ•ˆæœã€‚ä¾‹å¦‚ï¼š

```moonbit
type! IntError Int
fn h(f: (x: Int) -> Int!, x: Int) -> Unit { .. }

fn main {
  let _ = h(fn! { x => raise(IntError(x)) }, 0)     // çŸ©é˜µå‡½æ•°
  let _ = h(fn! (x) { x => raise(IntError(x)) }, 0) // åŒ¿åå‡½æ•°
}
```

å¦‚ä¸Šä¾‹æ‰€ç¤ºï¼Œç”± `type!` å®šä¹‰çš„é”™è¯¯ç±»å‹å¯ä»¥ç”¨ä½œ `Error` ç±»å‹çš„å€¼ï¼Œå½“é”™è¯¯è¢«æŠ›å‡ºæ—¶ã€‚

è¯·æ³¨æ„ï¼Œåªæœ‰é”™è¯¯ç±»å‹æˆ– `Error` ç±»å‹å¯ä»¥ç”¨ä½œé”™è¯¯ã€‚å¯¹äºé”™è¯¯ç±»å‹æ˜¯æ³›å‹çš„å‡½æ•°ï¼Œå¯ä»¥ä½¿
ç”¨ `Error` çº¦æŸæ¥å®ç°ã€‚ä¾‹å¦‚ï¼š

```moonbit
pub fn unwrap_or_error[T, E : Error](self : Result[T, E]) -> T!E {
  match self {
    Ok(x) => x
    Err(e) => raise e
  }
}
```

ç”±äº Error ç±»å‹å¯ä»¥åŒ…å«å¤šä¸ªé”™è¯¯ç±»å‹ï¼Œå› æ­¤åœ¨å¯¹ Error ç±»å‹è¿›è¡Œæ¨¡å¼åŒ¹é…æ—¶ï¼Œå¿…é¡»ä½¿ç”¨
é€šé…ç¬¦ \_ æ¥åŒ¹é…æ‰€æœ‰é”™è¯¯ç±»å‹ã€‚ä¾‹å¦‚ï¼š

```moonbit
type! E1
type! E2
fn f(e: Error) -> Unit {
  match e {
    E1 => println("E1")
    E2 => println("E2")
    _ => println("unknown error")
  }
}
```

### å¤„ç†é”™è¯¯

æœ‰ä¸‰ç§æ–¹å¼å¯ä»¥å¤„ç†é”™è¯¯ï¼š

- åœ¨å‡½æ•°è°ƒç”¨æ—¶åœ¨å‡½æ•°ååé¢æ·»åŠ  `!` ä»¥ç›´æ¥é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œä¾‹å¦‚ï¼š

```moonbit
fn div_reraise(x: Int, y: Int) -> Int!DivError {
  div!(x, y) // å¦‚æœ `div` æŠ›å‡ºé”™è¯¯ï¼Œåˆ™é‡æ–°æŠ›å‡ºè¯¥é”™è¯¯
}
```

- åœ¨å‡½æ•°ååé¢æ·»åŠ  `?` ä»¥å°†ç»“æœè½¬æ¢ä¸º `Result` ç±»å‹çš„å€¼ï¼Œä¾‹å¦‚ï¼š

```moonbit
test {
  let res = div?(6, 3)
  inspect!(res, content="Ok(2)")
  let res = div?(6, 0)
  inspect!(res, content="Err(division by zero)")
}
```

- ä½¿ç”¨ `try` å’Œ `catch` æ¥æ•è·å’Œå¤„ç†é”™è¯¯ï¼Œä¾‹å¦‚ï¼š

```moonbit
fn main {
  try {
    div!(42, 0)
  } catch {
    DivError(s) => println(s)
  } else {
    v => println(v)
  }
}
```

è¿™é‡Œï¼Œ`try` ç”¨äºè°ƒç”¨å¯èƒ½æŠ›å‡ºé”™è¯¯çš„å‡½æ•°ï¼Œè€Œ `catch` ç”¨äºåŒ¹é…å’Œå¤„ç†æ•è·çš„é”™è¯¯ã€‚å¦‚æœæ²¡
æœ‰æ•è·åˆ°é”™è¯¯ï¼Œåˆ™ä¸ä¼šæ‰§è¡Œ `catch` å—ï¼Œè€Œæ˜¯æ‰§è¡Œ `else` å—ã€‚

å¦‚æœæ²¡æœ‰é”™è¯¯è¢«æ•è·ä¸”ä¸éœ€è¦é‡‡å–ä»»ä½•è¡ŒåŠ¨ï¼Œå¯ä»¥çœç•¥ `else` å—ã€‚ä¾‹å¦‚ï¼š

```moonbit
fn main {
  try {
    println(div!(42, 0))
  } catch {
    _ => println("Error")
  }
}
```

`catch` å…³é”®å­—æ˜¯å¯é€‰çš„ï¼Œå½“ `try` çš„ä¸»ä½“æ˜¯ä¸€ä¸ªç®€å•çš„è¡¨è¾¾å¼æ—¶ï¼Œå¯ä»¥çœç•¥èŠ±æ‹¬å·ã€‚ä¾‹
å¦‚ï¼š

```moonbit
fn main {
  let a = try div!(42, 0) { _ => 0 }
  println(a)
}
```

`!` å’Œ `?` ç¬¦å·ä¹Ÿå¯ä»¥ç”¨äºæ–¹æ³•è°ƒç”¨å’Œç®¡é“æ“ä½œç¬¦ã€‚ä¾‹å¦‚ï¼š

```moonbit
type T Int
type! E Int derive(Show)
fn f(self: T) -> Unit!E { raise E(self.0) }
fn main {
  let x = T(42)
  try f!(x) { e => println(e) }
  try x.f!() { e => println(e) }
  try x |> f!() { e => println(e) }
}
```

ç„¶è€Œï¼Œå¯¹äº `+` `*` å¯èƒ½æŠ›å‡ºé”™è¯¯çš„ä¸­ç¼€ç®—ç¬¦æ¥è¯´ï¼Œå¿…é¡»é€šè¿‡å…¶åŸæœ¬çš„å½¢å¼è°ƒç”¨ï¼Œä¾‹å¦‚ `x.op_add!(y)` `x.op_mul!(y)`ã€‚

æ­¤å¤–ï¼Œå¦‚æœå‡½æ•°çš„è¿”å›ç±»å‹åŒ…å«é”™è¯¯ç±»å‹ï¼Œåˆ™å‡½æ•°è°ƒç”¨æ—¶å¿…é¡»ä½¿ç”¨ `!` æˆ– `?` æ¥å¤„ç†é”™è¯¯ï¼Œå¦
åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

### é”™è¯¯æ¨æ–­

åœ¨ `try` å—ä¸­ï¼Œå¯ä»¥æŠ›å‡ºå‡ ç§ä¸åŒç±»å‹çš„é”™è¯¯ã€‚å½“è¿™ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼Œç¼–è¯‘å™¨ä¼šä½¿ç”¨ `Error` ç±»
å‹ä½œä¸ºé€šç”¨é”™è¯¯ç±»å‹ã€‚å› æ­¤ï¼Œå¤„ç†ç¨‹åºå¿…é¡»ä½¿ç”¨é€šé…ç¬¦ `_` æ¥ç¡®ä¿æ‰€æœ‰é”™è¯¯éƒ½è¢«æ•è·ã€‚ä¾‹å¦‚ï¼š

```moonbit
type! E1
type! E2
fn f1() -> Unit!E1 { raise E1 }
fn f2() -> Unit!E2 { raise E2 }
fn main {
  try {
    f1!()
    f2!()
  } catch {
    E1 => println("E1")
    E2 => println("E2")
    _ => println("unknown error")
  }
}
```

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ `catch!` æ¥é‡æ–°æŠ›å‡ºæœªæ•è·çš„é”™è¯¯ï¼Œè¿™å¯¹äºåªæƒ³å¤„ç†ç‰¹å®šé”™è¯¯å¹¶é‡æ–°æŠ›å‡ºå…¶ä»–
é”™è¯¯æ—¶éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼š

```moonbit
type! E1
type! E2
fn f1() -> Unit!E1 { raise E1 }
fn f2() -> Unit!E2 { raise E2 }
fn f() -> Unit! {
  try {
    f1!()
    f2!()
  } catch! {
    E1 => println("E1")
  }
}
```

## æ³›å‹

æ‚¨å¯ä»¥åœ¨é¡¶å±‚çš„å‡½æ•°å’Œæ•°æ®ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹ã€‚ç±»å‹å‚æ•°å¯ä»¥ç”±æ–¹æ‹¬å·å¼•å…¥ã€‚
æˆ‘ä»¬å¯ä»¥é‡å†™å‰é¢æåˆ°çš„æ•°æ®ç±»å‹ `List`ï¼Œæ·»åŠ ç±»å‹å‚æ•° `T`ï¼Œä»¥è·å¾—ä¸€ä¸ªæ³›å‹ç‰ˆæœ¬çš„åˆ—è¡¨ã€‚
ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ³›å‹å‡½æ•° `map` å’Œ `reduce`ï¼Œç”¨äºå¯¹åˆ—è¡¨è¿›è¡Œæ“ä½œã€‚

```moonbit
enum List[T] {
  Nil
  Cons(T, List[T])
}

fn map[S, T](self: List[S], f: (S) -> T) -> List[T] {
  match self {
    Nil => Nil
    Cons(x, xs) => Cons(f(x), map(xs, f))
  }
}

fn reduce[S, T](self: List[S], op: (T, S) -> T, init: T) -> T {
  match self {
    Nil => init
    Cons(x, xs) => reduce(xs, op, op(init, x))
  }
}
```

## è®¿é—®æ§åˆ¶

é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰å‡½æ•°å®šä¹‰å’Œå˜é‡ç»‘å®šå¯¹å…¶ä»–åŒ…éƒ½æ˜¯ _ä¸å¯è§_ çš„ï¼›
æ²¡æœ‰ä¿®é¥°ç¬¦çš„ç±»å‹æ˜¯æŠ½è±¡æ•°æ®ç±»å‹ï¼Œå…¶åç§°è¢«å¯¼å‡ºï¼Œä½†å†…éƒ¨æ˜¯ä¸å¯è§çš„ã€‚
è¿™ç§è®¾è®¡é˜²æ­¢äº†æ„å¤–æš´éœ²å®ç°ç»†èŠ‚ã€‚
æ‚¨å¯ä»¥åœ¨ `type`/`fn`/`let` å‰ä½¿ç”¨ `pub` ä¿®é¥°ç¬¦ä½¿å…¶å®Œå…¨å¯è§ï¼Œæˆ–åœ¨ `type`
å‰ä½¿ç”¨ `priv` ä¿®é¥°ç¬¦ä½¿å…¶å¯¹å…¶ä»–åŒ…å®Œå…¨ä¸å¯è§ã€‚
æ‚¨è¿˜å¯ä»¥åœ¨å­—æ®µåå‰ä½¿ç”¨ `pub` æˆ– `priv` è·å¾—æ›´ç»†ç²’åº¦çš„è®¿é—®æ§åˆ¶ã€‚
ä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼š

- åœ¨æŠ½è±¡æˆ–ç§æœ‰ç»“æ„ä½“å†…ï¼Œæ‰€æœ‰å­—æ®µéƒ½ä¸èƒ½è¢«å®šä¹‰ä¸º `pub`ï¼Œå› ä¸ºè¿™æ ·æ²¡æœ‰æ„ä¹‰ã€‚
- æšä¸¾ç±»å‹çš„æ„é€ å™¨æ²¡æœ‰å•ç‹¬çš„å¯è§æ€§ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨å®ƒä»¬å‰é¢ä½¿ç”¨ `pub` æˆ– `priv`

```moonbit
struct R1 {       // é»˜è®¤ä¸ºæŠ½è±¡æ•°æ®ç±»å‹
  x: Int          // éšå¼çš„ç§æœ‰å­—æ®µ
  pub y: Int      // ERROR: åœ¨æŠ½è±¡ç±»å‹ä¸­æ‰¾åˆ°äº† `pub` å­—æ®µï¼
  priv z: Int     // WARNING: `priv` æ˜¯å¤šä½™çš„ï¼
}

pub struct R2 {       // æ˜¾å¼çš„å…¬å…±ç»“æ„
  x: Int              // éšå¼çš„å…¬å…±å­—æ®µ
  pub y: Int          // WARNING: `pub` æ˜¯å¤šä½™çš„ï¼
  priv z: Int         // æ˜¾å¼çš„ç§æœ‰å­—æ®µ
}

priv struct R3 {       // æ˜¾å¼çš„ç§æœ‰ç»“æ„
  x: Int               // éšå¼çš„ç§æœ‰å­—æ®µ
  pub y: Int           // ERROR: `pub` å­—æ®µå‡ºç°åœ¨äº†ç§æœ‰ç±»å‹ä¸­ï¼
  priv z: Int          // WARNING: `priv` æ˜¯å¤šä½™çš„ï¼
}

enum T1 {       // é»˜è®¤ä¸ºæŠ½è±¡æ•°æ®ç±»å‹
  A(Int)        // éšå¼çš„ç§æœ‰å˜ä½“
  pub B(Int)    // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)   // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}

pub enum T2 {       // æ˜¾å¼çš„å…¬å…±æšä¸¾
  A(Int)            // éšå¼çš„å…¬å…±å˜ä½“
  pub B(Int)        // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)       // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}

priv enum T3 {       // æ˜¾å¼çš„ç§æœ‰æšä¸¾
  A(Int)             // éšå¼çš„ç§æœ‰å˜ä½“
  pub B(Int)         // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
  priv C(Int)        // ERROR: æ— ç‹¬ç«‹å¯è§æ€§ï¼
}
```

MoonBit ä¸­å¦ä¸€ä¸ªæœ‰ç”¨çš„ç‰¹æ€§æ˜¯ `pub(readonly)` ç±»å‹ï¼Œå…¶å—åˆ°äº† OCaml [private types](https://v2.ocaml.org/manual/privatetypes.html)çš„å¯å‘ã€‚ç®€è€Œè¨€ä¹‹ï¼Œ`pub(readonly)` ç±»å‹çš„å€¼å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æˆ–ç‚¹è¯­æ³•ææ„ï¼Œä½†åœ¨å…¶ä»–åŒ…ä¸­ï¼Œä¸èƒ½è¢«æ„é€ æˆ–æ”¹å˜ã€‚æ³¨æ„åˆ°åœ¨ `pub(readonly)` ç±»å‹å®šä¹‰çš„åŒä¸€ä¸ªåŒ…ä¸­ï¼Œå®ƒæ²¡æœ‰ä»»ä½•é™åˆ¶ã€‚

```moonbit
// Package A
pub(readonly) struct RO {
  field: Int
}
fn init {
  let r = { field: 4 }       // OK
  let r = { ..r, field: 8 }  // OK
}

// Package B
fn print_RO(r : RO) -> Unit {
  println("{ field: ")
  println(r.field)  // OK
  println(" }")
}
fn init {
  let r : RO = { field: 4 }  // ERROR: æ— æ³•åˆ›å»ºå…¬å…±åªè¯»ç±»å‹ RO çš„å€¼ï¼
  let r = { ..r, field: 8 }  // ERROR: æ— æ³•ä¿®æ”¹ä¸€ä¸ªå…¬å…±åªè¯»å­—æ®µï¼
}
```

MoonBit ä¸­çš„è®¿é—®æ§åˆ¶éµå¾ªè¿™æ ·ä¸€ä¸ªåŸåˆ™ï¼š`pub` ç±»å‹ã€å‡½æ•°æˆ–å˜é‡ä¸èƒ½åŸºäºç§æœ‰ç±»å‹å®šä¹‰ã€‚
è¿™æ˜¯å› ä¸ºç§æœ‰ç±»å‹å¯èƒ½ä¸æ˜¯åœ¨ä½¿ç”¨ `pub` å®ä½“çš„æ‰€æœ‰åœ°æ–¹éƒ½å¯ä»¥è¢«è®¿é—®ã€‚
MoonBit å†…å»ºäº†ä¸€äº›æ£€æŸ¥ï¼Œä»¥é˜²æ­¢è¿åè¿™ä¸€åŸåˆ™çš„ç”¨ä¾‹ã€‚

```moonbit
pub struct s {
  x: T1  // OK
  y: T2  // OK
  z: T3  // ERROR: å…¬å…±å­—æ®µæ‹¥æœ‰ç§æœ‰ç±»å‹ `T3`ï¼
}

// ERROR: å…¬å…±å‡½æ•°æ‹¥æœ‰ç§æœ‰å½¢å‚ç±»å‹ `T3`ï¼
pub fn f1(_x: T3) -> T1 { T1::A(0) }
// ERROR: å…¬å…±å‡½æ•°æ‹¥æœ‰ç§æœ‰è¿”å›ç±»å‹ `T3`ï¼
pub fn f2(_x: T1) -> T3 { T3::A(0) }
// OK
pub fn f3(_x: T1) -> T1 { T1::A(0) }

pub let a: T3  // ERROR: å…¬å…±å˜é‡æ‹¥æœ‰ç§æœ‰ç±»å‹ `T3`ï¼
```

## æ–¹æ³•ç³»ç»Ÿ

MoonBit æ”¯æŒä¸ä¼ ç»Ÿé¢å‘å¯¹è±¡è¯­è¨€ä¸åŒçš„æ–¹æ³•ï¼ˆmethodï¼‰ã€‚
æŸä¸ªç±»å‹çš„æ–¹æ³•å°±æ˜¯ä¸è¯¥ç±»å‹å…³è”çš„æ™®é€šå‡½æ•°ã€‚
å¯ä»¥ä½¿ç”¨ `fn TypeName::method_name(...) -> ...` çš„è¯­æ³•æ¥ä¸ºç±»å‹ `TypeName` å£°æ˜æ–¹æ³•ï¼š

```moonbit
enum MyList[X] {
  Nil
  Cons(X, MyList[X])
}

fn MyList::map[X, Y](xs: MyList[X], f: (X) -> Y) -> MyList[Y] { ... }
fn MyList::concat[X](xs: MyList[MyList[X]]) -> MyList[X] { ... }
```

å¦‚æœä¸€ä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°åä¸º `self`ï¼Œé‚£ä¹ˆ MoonBit ä¼šè‡ªåŠ¨å°†è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸º `self` çš„ç±»å‹ä¸Šçš„æ–¹æ³•ï¼š

```moonbit
fn map[X, Y](self: MyList[X], f: (X) -> Y) -> List[Y] { ... }
// ç­‰ä»·äº
fn MyList::map[X, Y](xs: MyList[X], f: (X) -> Y) -> List[Y] { ... }
```

æ–¹æ³•å°±æ˜¯æŸä¸ªç±»å‹æ‰€æ‹¥æœ‰çš„æ™®é€šå‡½æ•°ã€‚æ‰€ä»¥ï¼Œåœ¨æ²¡æœ‰æ­§ä¹‰æ—¶ï¼Œå®ƒä»¬ä¹Ÿå¯ä»¥åƒæ™®é€šå‡½æ•°ä¸€æ ·è°ƒç”¨ï¼š

```moonbit
fn init {
  let xs: MyList[MyList[_]] = ...
  let ys = concat(xs)
}
```

ä½†å’Œæ™®é€šå‡½æ•°ä¸åŒï¼Œæ–¹æ³•æ”¯æŒé‡è½½ã€‚ä¸åŒçš„ç±»å‹å¯ä»¥æœ‰åŒåçš„æ–¹æ³•ã€‚
å¦‚æœå½“å‰ä½œç”¨åŸŸå†…æœ‰å¤šä¸ªåŒåæ–¹æ³•ï¼Œä¾ç„¶å¯ä»¥é€šè¿‡åŠ ä¸Š `TypeName::` çš„å‰ç¼€æ¥æ˜¾å¼åœ°è°ƒç”¨ä¸€ä¸ªæ–¹æ³•ï¼š

```moonbit live
struct T1 { x1: Int }
fn T1::default() -> { { x1: 0 } }

struct T2 { x2: Int }
fn T2::default() -> { { x2: 0 } }

fn init {
  // default() æœ‰æ­§ä¹‰ï¼
  let t1 = T1::default() // å¯è¡Œ
  let t2 = T2::default() // å¯è¡Œ
}
```

## è§†å›¾

ç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„â€œåˆ‡ç‰‡â€ï¼Œè§†å›¾èƒ½å¤Ÿå¼•ç”¨æ•°ç»„ç­‰æ•°æ®ç±»å‹ä¸­çš„ç‰‡æ®µã€‚å¯ä»¥ä½¿ç”¨`data[start:end]`çš„æ–¹å¼
åˆ›å»ºä¸€ä¸ªå…³äºæ•°ç»„`data`çš„è§†å›¾ï¼Œè¿™ä¸ªè§†å›¾å¼•ç”¨äº†ä»ä¸‹æ ‡`start`å¼€å§‹åˆ°`end`ï¼ˆä¸åŒ…å«`end`ï¼‰çš„å…ƒç´ ã€‚
`start`å’Œ`end`ä¹Ÿå¯ä»¥çœç•¥:

```moonbit
fn init {
  let xs = [0,1,2,3,4,5]
  let s1 : ArrayView[Int] = xs[2:]
  print_array_view(s1)            //output: 2345
  xs[:4]  |> print_array_view()  //output: 0123
  xs[2:5] |> print_array_view()  //output: 234
  xs[:]   |> print_array_view()  //output: 012345

  // åˆ›å»ºä¸€ä¸ªè§†å›¾çš„è§†å›¾
  xs[2:5][1:] |> print_array_view() //output: 34
}

fn print_array_view[T : Show](view : ArrayView[T]) -> Unit {
  for i=0; i<view.length(); i = i + 1 {
    println(view[i])
  }
  println("\n")
}
```

è¦ä¸ºè‡ªå®šä¹‰æ•°æ®ç±»å‹æ·»åŠ è§†å›¾æ”¯æŒï¼Œéœ€è¦ä¸ºå®ƒå®ç°`length`å’Œ`op_as_view`æ–¹æ³•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```moonbit
struct MyList[A] {
  elems : Array[A]
}

struct MyListView[A] {
  ls : MyList[A]
  start : Int
  end : Int
}

pub fn length[A](self : MyList[A]) -> Int {
  self.elems.length()
}

pub fn op_as_view[A](self : MyList[A], ~start : Int, ~end : Int) -> MyListView[A] {
  println("op_as_view: [\{start},\{end})")
  if start < 0 || end > self.length() { abort("index out of bounds") }
  { ls: self, start, end }
}

fn init {
  let ls = { elems: [1,2,3,4,5] }
  ls[:] |> ignore()
  ls[1:] |> ignore()
  ls[:2] |> ignore()
  ls[1:2] |> ignore()
}
```

è¾“å‡ºï¼š

```plaintext
op_as_view: [0,5)
op_as_view: [1,5)
op_as_view: [0,2)
op_as_view: [1,2)
```

## æ¥å£ç³»ç»Ÿ

MoonBit å…·æœ‰ç”¨äºé‡è½½/ç‰¹è®¾å¤šæ€ï¼ˆad-hoc polymorphismï¼‰çš„ç»“æ„æ¥å£ç³»ç»Ÿã€‚
æ¥å£æè¿°äº†æ»¡è¶³è¯¥æ¥å£çš„ç±»å‹éœ€è¦æ”¯æŒå“ªäº›æ“ä½œã€‚æ¥å£çš„å£°æ˜æ–¹å¼å¦‚ä¸‹ï¼š

```moonbit
trait I {
  f(Self, ...) -> ...
}
```

åœ¨æ¥å£å£°æ˜ä¸­ï¼Œ`Self` æŒ‡ä»£å®ç°æ¥å£çš„é‚£ä¸ªç±»å‹ã€‚

ä¸€ä¸ªç±»å‹è¦å®ç°æŸä¸ªæ¥å£ï¼Œå°±è¦æ»¡è¶³è¯¥æ¥å£ä¸­æ‰€æœ‰çš„æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„æ¥å£æè¿°äº†ä¸€ä¸ªèƒ½å¤Ÿæ¯”è¾ƒå…ƒç´ æ˜¯å¦ç›¸ç­‰çš„ç±»å‹éœ€è¦æ»¡è¶³çš„æ–¹æ³•ï¼š

```moonbit
trait Eq {
  op_equal(Self, Self) -> Bool
}
```

æ¥å£æ— éœ€æ˜¾å¼å®ç°ï¼Œå…·æœ‰æ‰€éœ€æ–¹æ³•çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°æ¥å£ã€‚è€ƒè™‘ä»¥ä¸‹æ¥å£ï¼š

```moonbit
trait Show {
  to_string(Self) -> String
}
```

å†…ç½®ç±»å‹å¦‚ `Int` å’Œ `Double` ä¼šè‡ªåŠ¨å®ç°è¿™ä¸ªæ¥å£ã€‚

åœ¨å£°æ˜æ³›å‹å‡½æ•°æ—¶ï¼Œç±»å‹å‚æ•°å¯ä»¥ç”¨å®ƒä»¬åº”è¯¥å®ç°çš„æ¥å£ä½œä¸ºæ³¨è§£ã€‚
å¦‚æ­¤ä¾¿èƒ½å®šä¹‰åªå¯¹æŸäº›ç±»å‹å¯ç”¨çš„æ³›å‹å‡½æ•°ã€‚ä¾‹å¦‚ï¼š

```moonbit
trait Number {
  op_add(Self, Self) -> Self
  op_mul(Self, Self) -> Self
}

fn square[N: Number](x: N) -> N {
  x * x
}
```

å¦‚æœæ²¡æœ‰ `Number` çš„è¦æ±‚ï¼Œ`square` ä¸­çš„è¡¨è¾¾å¼ `x * x` ä¼šå¯¼è‡´å‡ºç°æ‰¾ä¸åˆ°æ–¹æ³•/è¿ç®—ç¬¦çš„é”™è¯¯ã€‚
ç°åœ¨ï¼Œå‡½æ•° `square` å¯ä»¥ä¸ä»»ä½•å®ç°äº† `Number` æ¥å£çš„ç±»å‹ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

```moonbit live
fn init {
  println(square(2)) // 4
  println(square(1.5)) // 2.25
  println(square({ x: 2, y: 3 })) // {x: 4, y: 9}
}

trait Number {
  op_add(Self, Self) -> Self
  op_mul(Self, Self) -> Self
}

fn square[N: Number](x: N) -> N {
  x * x
}

struct Point {
  x: Int
  y: Int
} derive(Show)

fn op_add(self: Point, other: Point) -> Point {
  { x: self.x + other.x, y: self.y + other.y }
}

fn op_mul(self: Point, other: Point) -> Point {
  { x: self.x * other.x, y: self.y * other.y }
}
```

æ¥å£ä¸­çš„æ–¹æ³•å¯ä»¥ç”¨ `Trait::method` çš„è¯­æ³•æ¥ç›´æ¥è°ƒç”¨ã€‚MoonBit ä¼šæ¨å¯¼ `Self` çš„å…·ä½“ç±»å‹ï¼Œ
å¹¶æ£€æŸ¥ `Self` æ˜¯å¦å®ç°äº† `Trait`ï¼š

```moonbit live
fn init {
  println(Show::to_string(42))
  println(Compare::compare(1.0, 2.5))
}
```

Moonbit æä¾›äº†ä»¥ä¸‹å®ç”¨çš„å†…å»ºæ¥å£ï¼š

```moonbit
trait Eq {
  op_equal(Self, Self) -> Bool
}

trait Compare {
  // `0` ä»£è¡¨ç›¸ç­‰, `-1` ä»£è¡¨å°äº, `1` ä»£è¡¨å¤§äº
  op_equal(Self, Self) -> Int
}

trait Hash {
  hash(Self) -> Int
}

trait Show {
  // å°† `Self` çš„ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºå†™å…¥ä¸€ä¸ª `Logger` ä¸­
  output(Self, Logger) -> Unit
  to_string(Self) -> String
}

trait Default {
  default() -> Self
}
```

## æ–¹æ³•çš„è®¿é—®æƒé™æ§åˆ¶ã€ç›´æ¥å®ç°æ¥å£

ä¸ºäº†ä½¿ MoonBit çš„æ¥å£ç³»ç»Ÿå…·æœ‰ä¸€è‡´æ€§ï¼ˆcoherenceï¼Œå³ä»»ä½• `Type: Trait` çš„ç»„åˆéƒ½æœ‰å…¨å±€å”¯ä¸€çš„å®ç°ï¼‰ï¼Œ
é˜²æ­¢ç¬¬ä¸‰æ–¹åŒ…æ„å¤–åœ°ä¿®æ”¹ç°æœ‰ç¨‹åºçš„è¡Œä¸ºï¼Œ**åªæœ‰ç±»å‹æ‰€åœ¨çš„åŒ…èƒ½ä¸ºå®ƒå®šä¹‰æ–¹æ³•**ã€‚
æ‰€ä»¥ç”¨æˆ·æ— æ³•ä¸ºå†…å»ºç±»å‹æˆ–æ¥è‡ªç¬¬ä¸‰æ–¹åŒ…çš„ç±»å‹å®šä¹‰æ–¹æ³•ã€‚

ç„¶è€Œï¼Œæˆ‘ä»¬æœ‰æ—¶ä¹Ÿä¼šéœ€è¦ç»™ä¸€ä¸ªç°æœ‰ç±»å‹å®ç°æ–°çš„æ¥å£ï¼Œå› æ­¤ï¼ŒMoonBit å…è®¸ä¸å®šä¹‰æ–¹æ³•ç›´æ¥å®ç°ä¸€ä¸ªæ¥å£ã€‚
è¿™ç§æ¥å£å®ç°çš„è¯­æ³•æ˜¯ `impl Trait for Type with method_name(...) { ... }`ã€‚
MoonBit å¯ä»¥æ ¹æ®æ¥å£çš„ç­¾åè‡ªåŠ¨æ¨å¯¼å‡ºå®ç°çš„å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œå› æ­¤å®ç°ä¸å¼ºåˆ¶è¦æ±‚æ ‡æ³¨ç±»å‹ã€‚
ä¾‹å¦‚ï¼Œå‡è®¾è¦ä¸ºå†…å»ºç±»å‹å®ç°ä¸€ä¸ªæ–°çš„æ¥å£ `ToMyBinaryProtocol`ï¼Œå°±å¯ä»¥ï¼ˆä¸”å¿…é¡»ï¼‰ä½¿ç”¨ `impl`ï¼š

```moonbit
trait ToMyBinaryProtocol {
  to_my_binary_protocol(Self, Buffer) -> Unit
}

impl ToMyBinaryProtocol for Int with to_my_binary_protocol(x, b) { ... }
impl ToMyBinaryProtocol for Int with to_my_binary_protocol(x, b) { ... }
impl ToMyBinaryProtocol for Int with to_my_binary_protocol(x, b) { ... }
impl[X : ToMyBinaryProtocol] for Array[X] with to_my_binary_protocol(arr, b) { ... }
```

åœ¨æœç´¢æŸä¸ªæ¥å£çš„å®ç°æ—¶ï¼Œ`impl` æ¯”æ™®é€šæ–¹æ³•æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œ
å› æ­¤ `impl` è¿˜å¯ä»¥ç”¨æ¥è¦†ç›–æ‰è¡Œä¸ºä¸èƒ½æ»¡è¶³è¦æ±‚çš„ç°æœ‰æ–¹æ³•ã€‚
`impl` åªèƒ½è¢«ç”¨äºå®ç°æŒ‡å®šçš„æ¥å£ï¼Œä¸èƒ½åƒæ™®é€šçš„æ–¹æ³•ä¸€æ ·è¢«ç›´æ¥è°ƒç”¨ã€‚
æ­¤å¤–ï¼Œ**åªæœ‰ç±»å‹æˆ–æ¥å£æ‰€åœ¨çš„åŒ…å¯ä»¥å®šä¹‰ `impl`**ã€‚
ä¾‹å¦‚ï¼Œåªæœ‰ `@pkg1` å’Œ `@pkg2` èƒ½å®šä¹‰ `impl @pkg1.Trait for @pkg2.Type with ...`ã€‚
è¿™ä¸€é™åˆ¶ä½¿å¾— MoonBit çš„æ¥å£ç³»ç»Ÿåœ¨åŠ å…¥ `impl` åï¼Œä»èƒ½ä¿æŒä¸€è‡´ã€‚

å¦‚æœéœ€è¦ç›´æ¥è°ƒç”¨ä¸€ä¸ªå®ç°ï¼Œå¯ä»¥ä½¿ç”¨ `Trait::method` è¯­æ³•ã€‚ä¾‹å¦‚ï¼š

```moonbit live
trait MyTrait {
  f(Self) -> Unit
}

fn MyTrait::f(self: Int) -> Unit {
  println("Got Int \{self}!")
}

fn init {
  MyTrait::f(42)
}
```

## è‡ªåŠ¨å®ç°å†…å»ºæ¥å£

Moonbit å¯ä»¥è‡ªåŠ¨ç”Ÿæˆä¸€äº›å†…å»ºæ¥å£çš„å®ç°:

```moonbit live
struct T {
  x: Int
  y: Int
} derive(Eq, Compare, Show, Default)

fn init {
  let t1 = T::default()
  let t2 = { x: 1, y: 1 }
  println(t1) // {x: 0, y: 0}
  println(t2) // {x: 1, y: 1}
  println(t1 == t2) // false
  println(t1 < t2) // true
}
```

## æ¥å£å¯¹è±¡

MoonBit é€šè¿‡æ¥å£å¯¹è±¡çš„å½¢å¼æ¥æ”¯æŒè¿è¡Œæ—¶å¤šæ€ã€‚
å‡è®¾ `t` çš„ç±»å‹ä¸º `T`ï¼Œä¸”ç±»å‹ `T` å®ç°äº†æ¥å£ `I`,
é‚£ä¹ˆå¯ä»¥æŠŠ `T` å®ç° `I` çš„å„ä¸ªæ–¹æ³•å’Œ `t` è‡ªå·±æ‰“åŒ…åœ¨ä¸€èµ·ï¼Œ
åˆ›å»ºä¸€ä¸ª `I` çš„æ¥å£å¯¹è±¡ `t as I`ã€‚
æ¥å£å¯¹è±¡æ“¦é™¤äº†å€¼çš„å…·ä½“ç±»å‹ï¼Œæ‰€ä»¥ä»ä¸åŒçš„å…·ä½“ç±»å‹æ‰€åˆ›å»ºçš„æ¥å£å¯¹è±¡ï¼Œ
å¯ä»¥è¢«å°è£…åœ¨åŒä¸€ä¸ªæ•°æ®ç»“æ„é‡Œï¼Œç»Ÿä¸€è¿›è¡Œå¤„ç†ï¼š

```moonbit live
trait Animal {
  speak(Self) -> Unit
}

type Duck String
fn Duck::make(name: String) -> Duck { Duck(name) }
fn speak(self: Duck) -> Unit {
  println(self.0 + ": quack!")
}

type Fox String
fn Fox::make(name: String) -> Fox { Fox(name) }
fn Fox::speak(_self: Fox) -> Unit {
  println("What does the fox say?")
}

fn init {
  let duck1 = Duck::make("duck1")
  let duck2 = Duck::make("duck2")
  let fox1 = Fox::make("fox1")
  let animals = [ duck1 as Animal, duck2 as Animal, fox1 as Animal ]
  let mut i = 0
  while i < animals.length() {
    animals[i].speak()
    i = i + 1
  }
}
```

ä¸æ˜¯æ‰€æœ‰æ¥å£éƒ½å¯ä»¥ç”¨äºåˆ›å»ºå¯¹è±¡ã€‚
â€œå¯¹è±¡å®‰å…¨â€ çš„æ¥å£çš„æ–¹æ³•å¿…é¡»æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š

- æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯ `Self`
- åœ¨æ–¹æ³•çš„ç­¾åé‡Œï¼Œ`Self` åªèƒ½å‡ºç°åœ¨ç¬¬ä¸€ä¸ªå‚æ•°

ç”¨æˆ·å¯ä»¥åƒç»™ç»“æ„ä½“å’Œæšä¸¾å®šä¹‰æ–¹æ³•ä¸€æ ·ï¼Œç»™æ¥å£å¯¹è±¡å®šä¹‰æ–°çš„æ–¹æ³•ï¼š

```moonbit
trait Logger {
  write_string(Self, String) -> Unit
}

trait CanLog {
  log(Self, Logger) -> Unit
}

fn Logger::write_object[Obj : CanLog](self : Logger, obj : Obj) -> Unit {
  obj.log(self)
}

// ä½¿ç”¨æ¥å£å¯¹è±¡ `Logger` ä¸Šçš„ `write_object` æ–¹æ³•æ¥ç®€åŒ–ä»£ç 
impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {
  let (a, b) = self
  logger
  ..write_string("(")
  ..write_object(a)
  ..write_string(", ")
  ..write_object(b)
  .write_string(")")
}
```

## æµ‹è¯•å—

MoonBit æä¾›äº† `test` ä»£ç å—ï¼Œç”¨äºç¼–å†™æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯”å¦‚

```moonbit
test "test_name" {
  @test.eq!(1 + 1, 2)
  @test.eq!(2 + 2, 4)
}
```

`test` ä»£ç å—å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¿”å› `Unit` ï¼Œä½†æ˜¯å¯èƒ½æŠ›å‡º `String` ç±»å‹é”™è¯¯çš„å‡½æ•°ï¼ˆå‡½æ•°ç­¾åä¸­è®°ä¸º `Unit!String` ï¼‰ã€‚å®ƒä¼šåœ¨æ‰§è¡Œ `moon test` çš„è¿‡ç¨‹ä¸­è¢«è°ƒç”¨ï¼Œå¹¶é€šè¿‡æ„å»ºç³»ç»Ÿè¾“å‡ºæµ‹è¯•æŠ¥å‘Šã€‚å…¶ä¸­ `@test.eq` æ˜¯ä¸€ä¸ªæ ‡å‡†åº“ä¸­çš„å‡½æ•°ï¼Œå¦‚æœæ–­è¨€å¤±è´¥ï¼Œä¼šæ‰“å°é”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢æµ‹è¯•ã€‚å­—ç¬¦ä¸² `"test_name"` ç”¨äºæ ‡è¯†æµ‹è¯•ç”¨ä¾‹ï¼Œæ˜¯å¯é€‰é¡¹ï¼Œå½“å…¶ä»¥ `"panic"` å¼€å¤´æ—¶ï¼Œè¡¨ç¤ºè¯¥æµ‹è¯•çš„æœŸæœ›è¡Œä¸ºæ˜¯è§¦å‘ panicï¼Œåªæœ‰åœ¨ panic è¢«è§¦å‘çš„æƒ…å†µä¸‹æ‰èƒ½é€šè¿‡æµ‹è¯•ï¼Œæ¯”å¦‚ï¼š

```moonbit
test "panic_test" {
  let _ : Int = Option::None.unwrap()
}
```

## æ–‡æ¡£æ³¨é‡Š

æ–‡æ¡£æ³¨é‡Šæ˜¯ä»¥ `///` å¼€å¤´çš„æ³¨é‡Šï¼Œå‡ºç°åœ¨é¡¶å±‚ç»“æ„ï¼ˆå¦‚ `fn`ã€`let`ã€`enum`ã€`struct`ã€`type`ï¼‰çš„æ¯ä¸€è¡Œå‰é¢ã€‚æ–‡æ¡£æ³¨é‡Šå†…åŒ…å« Markdown æ–‡æœ¬å’Œä»»æ„ä¸ªæ³¨è§£ã€‚

````moonbit
/// Return a new array with reversed elements.
///
/// # Example
///
/// ```
/// reverse([1,2,3,4]) |> println()
/// ```
fn reverse[T](xs : Array[T]) -> Array[T] {
  ...
}
````

### æ³¨è§£

æ³¨è§£æ˜¯æ–‡æ¡£æ³¨é‡Šä¸­ `@word ...` å½¢å¼çš„ç‰¹æ®Šæ³¨é‡Šã€‚_word_ è¡¨ç¤ºæ³¨è§£çš„ç±»å‹ï¼Œåé¢å¯ä»¥è·Ÿéšå¤šä¸ª _word_ æˆ–å­—ç¬¦ä¸²å­—é¢é‡ï¼Œæ¯æ¡æ³¨è§£ç‹¬å ä¸€è¡Œã€‚åœ¨ MoonBit ä¸­æ³¨è§£é€šå¸¸ä¸ä¼šå½±å“ç¨‹åºçš„å«ä¹‰ã€‚æ— æ³•è¯†åˆ«çš„æ³¨è§£å°†ä¼šè§¦å‘è­¦å‘Šã€‚

- `@alert`æ³¨è§£

  å½“å¼•ç”¨äº†è¢«æ ‡è®°äº†`@alert`çš„å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè§¦å‘ç›¸åº”çš„è­¦å‘Šæˆ–è€…é”™è¯¯ã€‚è¿™ç§æœºåˆ¶æä¾›äº†ä¸€ç§é€šç”¨çš„æ–¹å¼ï¼Œå°†å‡½æ•°æ ‡è®°ä¸º `deprecated` æˆ– `unsafe`ã€‚

  å®ƒçš„å½¢å¼ä¸º `@alert category "alert message..."`ã€‚

  `category`è¡¨ç¤º`@alert`çš„ç±»åˆ«ï¼Œå®ƒå¯ä»¥æ˜¯ä»»æ„æ ‡è¯†ç¬¦ã€‚å¯ä»¥é€šè¿‡é…ç½®æ¥å†³å®šå“ªäº›`alert`æ˜¯å¯ç”¨çš„æˆ–è€…æŠ¥å‘Šä¸ºé”™è¯¯ã€‚

  ```moonbit
  /// ...
  /// @alert deprecated "Use foo2 instead"
  pub fn foo() -> Unit { ... }

  /// ...
  /// @alert unsafe "Div will cause an error when y is zero"
  pub fn div(x: Int, y: Int) -> Int { ... }

  fn main {
    foo() // warning: Use foo2 instead
    div(x, y) |> ignore // warning: Div will cause an error when y is zero
  }
  ```

## MoonBit çš„æ„å»ºç³»ç»Ÿ

æ„å»ºç³»ç»Ÿçš„ä»‹ç»å‚è§ [MoonBit çš„æ„å»ºç³»ç»Ÿæ•™ç¨‹](./build-system-tutorial.md)ã€‚
